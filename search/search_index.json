{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"waku","text":"<p> <sup>waku [\u67a0 or \u308f\u304f] means framework in Japanese.</sup> </p> <p> </p> <p> </p> <p> </p> <p></p> <p>waku is a modular, type-safe Python framework for scalable, maintainable applications. Inspired by NestJS, powered by Dishka IoC.</p> <p>[!WARNING] <code>waku</code> is going through a major rewrite, so docs aren't fully up-to-date yet. Stick to this README and our examples for now.</p> <p>For more details, check out our <code>waku</code> deepwiki page.</p>"},{"location":"#why-waku","title":"Why <code>waku</code>?","text":"<ul> <li>\ud83e\udde9 Modular architecture: Group related code with explicit imports/exports for clear boundaries and responsibilities.</li> <li>\ud83d\udc89 First-class Dependency Injection: Built on Dishka with flexible provider patterns (singleton, scoped, transient); swap implementations easily.</li> <li>\ud83d\udce8 Event-driven &amp; CQRS: Handle commands, queries, and events with a comprehensive CQRS implementation, pipeline chains, and centralized processing inspired by MediatR (C#).</li> <li>\ud83d\udd0c Framework-agnostic &amp; Integrations: Works with FastAPI, Litestar, FastStream, Aiogram, and more - no vendor lock-in.</li> <li>\ud83e\uddf0 Extensions &amp; Lifecycle Hooks: Hook into the app lifecycle for logging, validation, and custom logic; precise startup/shutdown management.</li> <li>\ud83d\udee1\ufe0f Production-ready: Type-safe APIs, robust validation, and scalable testing support.</li> </ul>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<ul> <li>\ud83d\udc65 Enterprise development teams building modular, maintainable backend services or microservices</li> <li>\ud83c\udfd7\ufe0f Architects and tech leads seeking a structured framework with clear dependency boundaries and testability</li> <li>\ud83d\udc0d Python developers frustrated with monolithic codebases and looking for better separation of concerns</li> <li>\ud83c\udf0f Engineers from other ecosystems (Java Spring, C# ASP.NET, TypeScript NestJS) wanting familiar patterns in Python</li> <li>\ud83d\udcc8 Projects requiring scalability both in codebase organization and team collaboration</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>uv add waku\n# or\npip install waku\n</code></pre>"},{"location":"#understanding-the-basics","title":"Understanding the Basics","text":"<p>Waku is built around a few core concepts:</p> <ul> <li>\ud83e\udde9 Modules: Classes decorated with <code>@module()</code> that define boundaries for application components and establish clear dependency relationships.</li> <li>\ud83e\uddd1\u200d\ud83d\udd27 Providers: Injectable services and logic registered within modules.</li> <li>\ud83d\udc89 Dependency Injection: Type-safe, flexible wiring powered by Dishka IoC container.</li> <li>\ud83c\udfed WakuFactory: The entry point that creates a <code>WakuApplication</code> instance from your root module.</li> <li>\ud83d\udd04 Application Lifecycle: Initialization and shutdown phases, enhanced with extension hooks.</li> </ul> <p>This structure keeps your code clean and your dependencies explicit.</p> <p><code>waku</code> is framework-agnostic - entrypoints (such as HTTP handlers) are provided by integrations, not the core.</p>"},{"location":"#basic-example","title":"Basic Example","text":"<p>Here's a minimal example showing the core concepts:</p> <pre><code>import asyncio\n\nfrom waku import WakuFactory, module\nfrom waku.di import scoped\n\n\n# 1. Define a provider (service)\nclass GreetingService:\n    async def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n\n\n# 2. Create a module and register the provider\n@module(providers=[scoped(GreetingService)])\nclass GreetingModule:\n    pass\n\n\n# 3. Create a root module that imports other modules\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    # 4. Bootstrap the application with WakuFactory\n    app = WakuFactory(AppModule).create()\n\n    # 5. Use the application with a properly scoped container\n    async with app, app.container() as c:\n        # 6. Resolve and use dependencies\n        svc = await c.get(GreetingService)\n        print(await svc.greet('waku'))\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#more-realistic-example","title":"More Realistic Example","text":"<p>Let's add protocols and module exports:</p> <pre><code>import asyncio\nfrom typing import Protocol\n\nfrom waku import WakuFactory, module\nfrom waku.di import scoped, singleton\n\n\n# Define a protocol for loose coupling\nclass Logger(Protocol):\n    async def log(self, message: str) -&gt; None: ...\n\n\n# Implementation of the logger\nclass ConsoleLogger:\n    async def log(self, message: str) -&gt; None:\n        print(f'[LOG] {message}')\n\n\n# Service that depends on the logger\nclass UserService:\n    def __init__(self, logger: Logger) -&gt; None:\n        self.logger = logger\n\n    async def create_user(self, username: str) -&gt; str:\n        user_id = f'user_{username}'\n        await self.logger.log(f'Created user: {username}')\n        return user_id\n\n\n# Infrastructure module provides core services\n@module(\n    providers=[singleton(ConsoleLogger, provided_type=Logger)],\n    exports=[Logger],  # Export to make available to other modules\n)\nclass InfrastructureModule:\n    pass\n\n\n# Feature module for user management\n@module(\n    imports=[InfrastructureModule],  # Import dependencies from other modules\n    providers=[scoped(UserService)],\n)\nclass UserModule:\n    pass\n\n\n# Application root module\n@module(imports=[UserModule])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    app = WakuFactory(AppModule).create()\n\n    async with app, app.container() as c:\n        user_service = await c.get(UserService)\n        user_id = await user_service.create_user('alice')\n        print(f'Created user with ID: {user_id}')\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Want to learn more? Here's where to go next:</p> <ul> <li>Get familiar with module exports and imports</li> <li>Try different provider scopes</li> <li>Add CQRS for clean command handling</li> <li>Use extension hooks to customize your app</li> <li>Connect with your favorite framework</li> </ul> <p>Check our Getting Started guide and browse the examples directory for inspiration.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>Module System</li> <li>Providers</li> <li>Extensions</li> <li>CQRS</li> <li>API Reference</li> <li>Dishka Documentation</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ul> <li>Contributing Guide</li> <li>Development Setup</li> </ul>"},{"location":"#top-contributors","title":"Top contributors","text":""},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Create logo</li> <li> Improve inner architecture</li> <li> Improve documentation</li> <li> Add new and improve existing validation rules</li> <li> Provide example projects for common architectures</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>RU Telegram group</li> <li>GitHub Issues</li> <li>Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT License.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Dishka \u2013 Dependency Injection framework powering <code>waku</code> IoC container.</li> <li>NestJS \u2013 Primary inspiration for modular architecture, design patterns and some implementation details.</li> <li>MediatR (C#) \u2013 Inspiration and implementation details for the CQRS subsystem.</li> </ul>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#v0261-2025-12-08","title":"v0.26.1 (2025-12-08)","text":""},{"location":"changelog/#-bug-fixes","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Add app_extensions param to create_test_app   (<code>3bba1ac</code>)</li> </ul>"},{"location":"changelog/#v0260-2025-12-08","title":"v0.26.0 (2025-12-08)","text":""},{"location":"changelog/#-features","title":"\u2728 Features","text":"<ul> <li>Add <code>OnBeforeContainerBuild</code> extension   (<code>8803bce</code>)</li> </ul>"},{"location":"changelog/#v0250-2025-12-02","title":"v0.25.0 (2025-12-02)","text":""},{"location":"changelog/#-features_1","title":"\u2728 Features","text":"<ul> <li>Add context override support to <code>override</code> helper   (<code>30e572f</code>)</li> </ul>"},{"location":"changelog/#v0241-2025-12-01","title":"v0.24.1 (2025-12-01)","text":""},{"location":"changelog/#-performance-improvements","title":"\u26a1 Performance Improvements","text":"<ul> <li>cqrs: Use iterative pipeline execution to avoid partial chains   (<code>d98ee30</code>)</li> </ul>"},{"location":"changelog/#v0240-2025-12-01","title":"v0.24.0 (2025-12-01)","text":""},{"location":"changelog/#-features_2","title":"\u2728 Features","text":"<ul> <li>cqrs: Make event publishing noop when no handlers registered   (<code>ae73c04</code>)</li> </ul>"},{"location":"changelog/#v0230-2025-11-29","title":"v0.23.0 (2025-11-29)","text":""},{"location":"changelog/#-features_3","title":"\u2728 Features","text":"<ul> <li>Add conditional provider activation   (<code>a9aee1d</code>)</li> </ul>"},{"location":"changelog/#v0222-2025-11-29","title":"v0.22.2 (2025-11-29)","text":""},{"location":"changelog/#-bug-fixes_1","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Adjust cqrs handlers typing to support ty v0.0.1a29   (<code>526102c</code>)</li> </ul>"},{"location":"changelog/#v0221-2025-11-29","title":"v0.22.1 (2025-11-29)","text":""},{"location":"changelog/#-bug-fixes_2","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Do not trigger error on generic re-exports in modules   (<code>e1a5b56</code>)</li> </ul>"},{"location":"changelog/#v0220-2025-11-27","title":"v0.22.0 (2025-11-27)","text":""},{"location":"changelog/#-bug-fixes_3","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Allow usage of factories in many provider   (<code>bbc50a3</code>)</li> </ul>"},{"location":"changelog/#-build-system","title":"\u2699\ufe0f Build System","text":"<ul> <li>Add python 3.14.0rc1 to testing suite   (<code>442076f</code>)</li> </ul>"},{"location":"changelog/#-features_4","title":"\u2728 Features","text":"<ul> <li>Make cqrs related handlers calls positional only   (<code>386d31a</code>)</li> </ul>"},{"location":"changelog/#v0210-2025-07-20","title":"v0.21.0 (2025-07-20)","text":""},{"location":"changelog/#-features_5","title":"\u2728 Features","text":"<ul> <li>Improve providers registration interfaces   (<code>c43f2b8</code>)</li> </ul>"},{"location":"changelog/#v0200-2025-06-11","title":"v0.20.0 (2025-06-11)","text":""},{"location":"changelog/#-features_6","title":"\u2728 Features","text":"<ul> <li>tests: Make overrode container use strict validation   (<code>4089e58</code>)</li> </ul>"},{"location":"changelog/#v0190-2025-06-07","title":"v0.19.0 (2025-06-07)","text":""},{"location":"changelog/#-documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Further improve README   (<code>f4272c6</code>)</p> </li> <li> <p>Improve readme   (<code>4e19320</code>)</p> </li> <li> <p>Update examples and documentation to reflect dishka migration   (<code>3ce62e0</code>)</p> </li> </ul>"},{"location":"changelog/#-features_7","title":"\u2728 Features","text":"<ul> <li>tests: Allow to override not only application container   (<code>0d1f61e</code>)</li> </ul>"},{"location":"changelog/#v0180-2025-05-12","title":"v0.18.0 (2025-05-12)","text":""},{"location":"changelog/#-build-system_1","title":"\u2699\ufe0f Build System","text":"<ul> <li>Introduce astral-sh <code>ty</code> as additional typechecker   (<code>4eb9758</code>)</li> </ul>"},{"location":"changelog/#-documentation_1","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Fix <code>markdownlint</code> issues in README and CONTRIBUTING files   (<code>cd3821e</code>)</li> </ul>"},{"location":"changelog/#-features_8","title":"\u2728 Features","text":"<ul> <li>ext: Implement extension registry   (<code>6e88840</code>)</li> </ul>"},{"location":"changelog/#v0170-2025-05-11","title":"v0.17.0 (2025-05-11)","text":""},{"location":"changelog/#-features_9","title":"\u2728 Features","text":"<ul> <li>cqrs: Improve cqrs subsystem with pipeline behaviors   (<code>8b84864</code>)</li> </ul>"},{"location":"changelog/#-breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>cqrs: <code>mediator</code> package renamed to <code>cqrs</code></li> </ul>"},{"location":"changelog/#v0160-2025-05-04","title":"v0.16.0 (2025-05-04)","text":""},{"location":"changelog/#-features_10","title":"\u2728 Features","text":"<ul> <li>core: Group all module providers within one dishka provider   (<code>4fa6850</code>)</li> </ul>"},{"location":"changelog/#v0150-2025-05-02","title":"v0.15.0 (2025-05-02)","text":""},{"location":"changelog/#-features_11","title":"\u2728 Features","text":"<ul> <li>validation: Implement proper module re-export validation   (<code>f5e608b</code>)</li> </ul>"},{"location":"changelog/#v0140-2025-04-30","title":"v0.14.0 (2025-04-30)","text":""},{"location":"changelog/#-features_12","title":"\u2728 Features","text":"<ul> <li>validation: Make dependency accessible rule stricter and follow nestjs behaviour   (<code>574c453</code>)</li> </ul>"},{"location":"changelog/#v0130-2025-04-30","title":"v0.13.0 (2025-04-30)","text":""},{"location":"changelog/#-features_13","title":"\u2728 Features","text":"<ul> <li>Implement proper module hooks sorting   (<code>2b2a9de</code>)</li> </ul>"},{"location":"changelog/#v0121-2025-04-29","title":"v0.12.1 (2025-04-29)","text":""},{"location":"changelog/#-performance-improvements_1","title":"\u26a1 Performance Improvements","text":"<ul> <li>core: Collect module adjacency in one pass   (<code>9ad711d</code>)</li> </ul>"},{"location":"changelog/#v0120-2025-04-28","title":"v0.12.0 (2025-04-28)","text":""},{"location":"changelog/#-features_14","title":"\u2728 Features","text":"<ul> <li>core: Make module traversal post-order dfs   (<code>eb9a760</code>)</li> </ul>"},{"location":"changelog/#v0113-2025-04-28","title":"v0.11.3 (2025-04-28)","text":""},{"location":"changelog/#-bug-fixes_4","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>core: Move <code>OnModuleConfigure</code> to module definition to prevent duplications on subsequent   calls   (<code>0e6ed00</code>)</li> </ul>"},{"location":"changelog/#v0112-2025-04-28","title":"v0.11.2 (2025-04-28)","text":""},{"location":"changelog/#-bug-fixes_5","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>validation: Fix check for provided types in the current module without explicit export   (<code>a771cbb</code>)</li> </ul>"},{"location":"changelog/#v0111-2025-04-28","title":"v0.11.1 (2025-04-28)","text":""},{"location":"changelog/#-performance-improvements_2","title":"\u26a1 Performance Improvements","text":"<ul> <li>Remove duplications in module registry builder logic   (<code>8527c7d</code>)</li> </ul>"},{"location":"changelog/#v0110-2025-04-28","title":"v0.11.0 (2025-04-28)","text":""},{"location":"changelog/#-documentation_2","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Enhance contributing guide and README   (<code>6e4ddda</code>)</p> </li> <li> <p>Fix issue with mediatr link in readme   (<code>8435d2f</code>)</p> </li> <li> <p>Improve api reference docs generation; document override helper   (<code>48061d0</code>)</p> </li> <li> <p>Improve feature descriptions in README   (<code>2d18bee</code>)</p> </li> <li> <p>Update README for clarity   (<code>efaf3d5</code>)</p> </li> </ul>"},{"location":"changelog/#-features_15","title":"\u2728 Features","text":"<ul> <li>core: Replace ModuleGraph with ModuleRegistry for module management   (<code>f807f0a</code>)</li> </ul>"},{"location":"changelog/#-breaking-changes_1","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>core: All module graph operations now use <code>ModuleRegistry</code>; direct usage of <code>ModuleGraph</code> is   no longer supported. Update custom extensions and validation logic accordingly.</li> </ul>"},{"location":"changelog/#v0100-2025-04-26","title":"v0.10.0 (2025-04-26)","text":""},{"location":"changelog/#-features_16","title":"\u2728 Features","text":"<ul> <li>Re-export di related object from dishka   (<code>820ddc4</code>)</li> </ul>"},{"location":"changelog/#v091-2025-04-26","title":"v0.9.1 (2025-04-26)","text":""},{"location":"changelog/#-performance-improvements_3","title":"\u26a1 Performance Improvements","text":"<ul> <li>Optimize DependenciesAccessible rule   (<code>8eb1ae2</code>)</li> </ul>"},{"location":"changelog/#v090-2025-04-25","title":"v0.9.0 (2025-04-25)","text":""},{"location":"changelog/#-bug-fixes_6","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li> <p>Skip context providers when validation that deps accessible   (<code>12d658e</code>)</p> </li> <li> <p>Trigger release   (<code>2d31df1</code>)</p> </li> </ul>"},{"location":"changelog/#-documentation_3","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Actualize readme file   (<code>1001875</code>)</p> </li> <li> <p>Fix readme formatting   (<code>116e424</code>)</p> </li> </ul>"},{"location":"changelog/#-features_17","title":"\u2728 Features","text":"<ul> <li> <p>Add container override helper to application   (<code>1e2f216</code>)</p> </li> <li> <p>Add di helpers, add testing override helper   (<code>66d7bb5</code>)</p> </li> </ul>"},{"location":"changelog/#v080-2025-04-24","title":"v0.8.0 (2025-04-24)","text":""},{"location":"changelog/#-documentation_4","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Improve readme, add motivation section   (<code>059e5c9</code>)</li> </ul>"},{"location":"changelog/#-features_18","title":"\u2728 Features","text":"<ul> <li>Migrate to dishka as ioc provider   (<code>7296122</code>)</li> </ul>"},{"location":"changelog/#v070-2025-04-13","title":"v0.7.0 (2025-04-13)","text":""},{"location":"changelog/#-features_19","title":"\u2728 Features","text":"<ul> <li>Rename application to waku   (<code>12c9cd8</code>)</li> </ul>"},{"location":"changelog/#v060-2025-03-25","title":"v0.6.0 (2025-03-25)","text":""},{"location":"changelog/#-bug-fixes_7","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Change links to di docs in readme   (<code>0bf7086</code>)</li> </ul>"},{"location":"changelog/#-documentation_5","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Rename development section to contributing (PR#19,   <code>08ec5f5</code>)</p> </li> <li> <p>Rename di section to providers, improve its contents   (PR#111,   <code>f63c936</code>)</p> </li> <li> <p>Slightly reorganize documentation (PR#19,   <code>fe8220a</code>)</p> </li> <li> <p>di: Expand di documentation (PR#111,   <code>887e76f</code>)</p> </li> </ul>"},{"location":"changelog/#-features_20","title":"\u2728 Features","text":"<ul> <li>Add more info to provider validation error messages   (PR#113,   <code>9dced06</code>)</li> </ul>"},{"location":"changelog/#v050-2025-03-23","title":"v0.5.0 (2025-03-23)","text":""},{"location":"changelog/#-documentation_6","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Add basic modules and providers docs   (<code>9ddbc3b</code>)</p> </li> <li> <p>Further improve documentation #19 #94   (<code>3d061b6</code>)</p> </li> </ul>"},{"location":"changelog/#-features_21","title":"\u2728 Features","text":"<ul> <li>mediator: Simplify cqrs handlers registration (#105)   (PR#107,   <code>65fa07d</code>)</li> </ul>"},{"location":"changelog/#v040-2025-03-16","title":"v0.4.0 (2025-03-16)","text":""},{"location":"changelog/#-documentation_7","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Setup mkdocs and improve documentation   (<code>d5166d7</code>)</li> </ul>"},{"location":"changelog/#-features_22","title":"\u2728 Features","text":"<ul> <li>Add ability to pass custom context to dependency provider   (<code>a0e055f</code>)</li> </ul>"},{"location":"changelog/#v031-2025-02-13","title":"v0.3.1 (2025-02-13)","text":""},{"location":"changelog/#-bug-fixes_8","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Do not unwrap generic annotations in <code>collect_dependencies</code>   (<code>c5f1b7c</code>)</li> </ul>"},{"location":"changelog/#v030-2025-02-10","title":"v0.3.0 (2025-02-10)","text":""},{"location":"changelog/#-features_23","title":"\u2728 Features","text":"<ul> <li>Refactor module system   (<code>43a102a</code>)</li> </ul>"},{"location":"changelog/#v020-2025-01-12","title":"v0.2.0 (2025-01-12)","text":""},{"location":"changelog/#-documentation_8","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Add docstrings to mediator related stuff   (<code>10728c0</code>)</p> </li> <li> <p>Deploy mkdocs to github pages #17   (<code>23872d7</code>)</p> </li> <li> <p>Improve readme and contributing guide   (<code>93529d1</code>)</p> </li> <li> <p>Trigger docs deploy #17   (<code>096876f</code>)</p> </li> <li> <p>Use org bot for pages deploy #17   (<code>dfd1786</code>)</p> </li> </ul>"},{"location":"changelog/#-features_24","title":"\u2728 Features","text":"<ul> <li> <p>Eliminate maps usage in mediator   (<code>16679d7</code>)</p> </li> <li> <p>Refactor mediator extension, add events handling support   (<code>3441375</code>)</p> </li> </ul>"},{"location":"changelog/#v016-2024-12-20","title":"v0.1.6 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_9","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Skip ci in release commit   (<code>9adbc58</code>)</li> </ul>"},{"location":"changelog/#v015-2024-12-20","title":"v0.1.5 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_10","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Remove unused version var from init, run gitlint only for prs   (<code>7a270d4</code>)</li> </ul>"},{"location":"changelog/#v014-2024-12-20","title":"v0.1.4 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_11","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Attempt to fix contextvar from different context error   (<code>d98c2f8</code>)</li> </ul>"},{"location":"changelog/#v013-2024-12-20","title":"v0.1.3 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_12","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>ext: Make mediator middlewares work   (<code>4e4a593</code>)</li> </ul>"},{"location":"changelog/#-build-system_2","title":"\u2699\ufe0f Build System","text":"<ul> <li>Make patch release only for <code>fix</code> &amp; <code>perf</code> tags   (<code>b9cf6bf</code>)</li> </ul>"},{"location":"changelog/#-documentation_9","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Add readme and contributing guide   (<code>32043d7</code>)</li> </ul>"},{"location":"changelog/#v012-2024-12-19","title":"v0.1.2 (2024-12-19)","text":""},{"location":"changelog/#v011-2024-12-19","title":"v0.1.1 (2024-12-19)","text":""},{"location":"changelog/#-features_25","title":"\u2728 Features","text":"<ul> <li>validation: Add ValidationRule protocol, implement DIScopeMismatch   (<code>4cfdd23</code>)</li> </ul>"},{"location":"changelog/#v010-2024-12-18","title":"v0.1.0 (2024-12-18)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#creating-your-first-waku-application","title":"Creating Your First <code>waku</code> Application","text":"<p>Let's create a simple application that demonstrates <code>waku</code> core concepts.</p>"},{"location":"getting-started/#step-1-create-the-basic-structure","title":"Step 1: Create the Basic Structure","text":"<p>Create a new directory for your project and set up your files:</p> <pre><code>project/\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 services.py\n</code></pre>"},{"location":"getting-started/#step-2-define-your-services","title":"Step 2: Define Your Services","text":"<p>In <code>services.py</code>, let's define a simple service:</p> services.py<pre><code>class GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n</code></pre>"},{"location":"getting-started/#step-3-create-modules","title":"Step 3: Create Modules","text":"<p>In <code>app.py</code>, let's define our modules and application setup:</p> app.py<pre><code>import asyncio\n\nfrom waku import WakuApplication, WakuFactory, module\nfrom waku.di import Injected, inject, scoped\n\nfrom project.services import GreetingService\n\n\n# Define a feature module\n@module(\n    providers=[scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n\n\n# Define the root application module\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\n# Define a function that will use our service\n@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n\n\n# Bootstrap the application\ndef bootstrap() -&gt; WakuApplication:\n    return WakuFactory(AppModule).create()\n\n\n# Run the application\nasync def main() -&gt; None:\n    application = bootstrap()\n\n    # Create a context for our application\n    async with application, application.container() as container:\n        # Use our service\n        message = await greet_user()  # type: ignore[call-arg]\n        print(message)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-4-run-your-application","title":"Step 4: Run Your Application","text":"<p>Run the application with:</p> <pre><code>python app.py\n</code></pre> <p>You should see the output:</p> <pre><code>Hello, waku!\n</code></pre>"},{"location":"getting-started/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what's happening in our simple application:</p>"},{"location":"getting-started/#modules","title":"Modules","text":"<p>Modules are the building blocks of a <code>waku</code> application. Each module encapsulates a specific feature or functionality.</p> <pre><code>@module(\n    providers=[scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre> <p>In this example:</p> <ul> <li><code>providers</code> defines which providers this module creates and manages</li> <li><code>exports</code> makes these providers (or imported modules) available to other modules that import this one</li> <li><code>scoped</code> indicates this provider should be created once for every container context entrance.</li> </ul> <p>Info</p> <p>For more information on providers and scopes, see Providers.</p>"},{"location":"getting-started/#application-bootstrap","title":"Application Bootstrap","text":"<p>The application is created using a <code>WakuFactory</code>:</p> <pre><code>def bootstrap() -&gt; WakuApplication:\n    return WakuFactory(AppModule).create()\n</code></pre> <p>This creates an application instance with <code>AppModule</code> as the root module.</p>"},{"location":"getting-started/#dependency-injection","title":"Dependency Injection","text":"<p>Providers are injected into functions using the @inject decorator:</p> <pre><code>@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n</code></pre> <p>The <code>Injected[GreetingService]</code> type annotation tells <code>waku</code> which provider to inject.</p>"},{"location":"getting-started/#context-management","title":"Context Management","text":"<p><code>waku</code> uses context managers to manage the lifecycle of your application and its providers:</p> <pre><code>async with application, application.container() as container:\n    message = await greet_user()\n</code></pre> <p>In real applications, you would typically use this context managers in <code>lifespan</code> of your framework.</p>"},{"location":"getting-started/#creating-a-more-realistic-application","title":"Creating a More Realistic Application","text":"<p>Let's extend our example to demonstrate a more realistic scenario with multiple modules and configuration.</p>"},{"location":"getting-started/#step-1-enhanced-structure","title":"Step 1: Enhanced Structure","text":"<p>Create a more complete project structure:</p> <pre><code>app/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __main__.py\n\u251c\u2500\u2500 application.py\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 greetings/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 services.py\n\u2502   \u2502   \u2514\u2500\u2500 module.py\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 services.py\n\u2502       \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 settings.py\n</code></pre>"},{"location":"getting-started/#step-2-add-configuration-module","title":"Step 2: Add Configuration Module","text":"<p>Define an application settings class and configuration module for providing settings object to your application:</p> app/settings.py<pre><code>from dataclasses import dataclass\nfrom typing import Literal\n\nfrom waku import DynamicModule, module\nfrom waku.di import Object\n\nEnvironment = Literal['dev', 'prod']\n\n\n# You may consider using `pydantic-settings` or similar libs for settings management\n@dataclass(kw_only=True)\nclass AppSettings:\n    environment: Environment\n    debug: bool\n\n\n@module(is_global=True)\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: Environment) -&gt; DynamicModule:\n        settings = AppSettings(\n            environment=env,\n            debug=env == 'dev',\n        )\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Object(settings)],\n        )\n</code></pre>"},{"location":"getting-started/#step-3-creating-modules","title":"Step 3: Creating Modules","text":""},{"location":"getting-started/#greeting-module","title":"Greeting Module","text":"app/modules/greetings/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Greeting:\n    language: str\n    template: str\n</code></pre> app/modules/greetings/services.py<pre><code>from app.config import AppConfig\nfrom app.modules.greetings.models import Greeting\n\n\nclass GreetingService:\n    def __init__(self, config: AppConfig) -&gt; None:\n        self.config = config\n        self.greetings: dict[str, Greeting] = {\n            'en': Greeting(language='en', template='Hello, {}!'),\n            'es': Greeting(language='es', template='\u00a1Hola, {}!'),\n            'fr': Greeting(language='fr', template='Bonjour, {}!'),\n        }\n\n    def get_greeting(self, language: str = 'en') -&gt; Greeting:\n        # If in debug mode and language not found, return default\n        if self.config.debug and language not in self.greetings:\n            return self.greetings['en']\n        return self.greetings.get(language, self.greetings['en'])\n\n    def greet(self, name: str, language: str = 'en') -&gt; str:\n        greeting = self.get_greeting(language)\n        return greeting.template.format(name)\n\n    def available_languages(self) -&gt; list[str]:\n        return list(self.greetings.keys())\n</code></pre> app/modules/greetings/module.py<pre><code>from waku import module\nfrom waku.di import Singleton\n\nfrom app.modules.greetings.services import GreetingService\n\n\n@module(\n    providers=[Singleton(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre>"},{"location":"getting-started/#user-module","title":"User Module","text":"app/modules/users/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: str\n    name: str\n    preferred_language: str = 'en'\n</code></pre> app/modules/users/services.py<pre><code>from app.modules.users.models import User\n\n\nclass UserService:\n    def __init__(self) -&gt; None:\n        # Mock database\n        self.users: dict[str, User] = {\n            '1': User(id='1', name='Alice', preferred_language='en'),\n            '2': User(id='2', name='Bob', preferred_language='fr'),\n            '3': User(id='3', name='Carlos', preferred_language='es'),\n        }\n\n    def get_user(self, user_id: str) -&gt; User | None:\n        return self.users.get(user_id)\n</code></pre> app/modules/users/module.py<pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.users.services import UserService\n\n\n@module(\n    providers=[Scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n</code></pre>"},{"location":"getting-started/#step-4-create-the-application-module","title":"Step 4: Create the Application Module","text":"<p>Define the application module and bootstrap function for initializing your application:</p> app/application.py<pre><code>from waku import WakuApplication, WakuFactory, module\n\nfrom app.settings import ConfigModule\nfrom app.greetings.module import GreetingModule\nfrom app.users.module import UserModule\n\n\n@module(\n    # Import all top-level modules\n    imports=[\n        ConfigModule.register(env='dev'),\n        GreetingModule,\n        UserModule,\n    ],\n)\nclass AppModule:\n    pass\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    return WakuFactory(AppModule).create()\n</code></pre>"},{"location":"getting-started/#step-5-create-the-main-entrypoint","title":"Step 5: Create the Main Entrypoint","text":"<p>In real world scenarios, you would use a framework like FastAPI, Flask, etc. for defining your entry points, also known as handlers. For the sake of simplicity, we don't use any framework in this example.</p> app/__main__.py<pre><code>import asyncio\n\nfrom waku.di import Injected, inject\n\nfrom app.application import bootstrap_application\nfrom app.modules.users.services import UserService\nfrom app.modules.greetings.services import GreetingService\n\n\n@inject\nasync def greet_user_by_id(\n    user_id: str,\n    user_service: Injected[UserService],\n    greeting_service: Injected[GreetingService],\n) -&gt; str:\n    user = user_service.get_user(user_id)\n    if not user:\n        return f'User {user_id} not found'\n\n    return greeting_service.greet(name=user.name, language=user.preferred_language)\n\n\nasync def main() -&gt; None:\n    application = bootstrap_application()\n\n    async with application, application.container() as container:\n        # Greet different users\n        for user_id in ['1', '2', '3', '4']:  # '4' doesn't exist\n            greeting = await greet_user_by_id(user_id)  # type: ignore[call-arg]\n            print(greeting)\n\n        # Get service directly for demonstration\n        greeting_service = await container.get(GreetingService)\n        print(f'Available languages: {greeting_service.available_languages()}')\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-6-run-your-application","title":"Step 6: Run Your Application","text":"<pre><code>python -m app\n</code></pre> <p>Expected output:</p> <pre><code>Hello, Alice!\nBonjour, Bob!\n\u00a1Hola, Carlos!\nUser 4 not found\nAvailable languages: ['en', 'es', 'fr']\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of <code>waku</code>, you can:</p> <ol> <li>Explore more advanced features like Mediator (CQRS)</li> <li>Learn about Extensions for adding functionality to your application</li> <li>Integrate with web frameworks like FastAPI</li> <li>Understand Module System in depth</li> <li>Explore Dependency Injection techniques</li> </ol> <p><code>waku</code> modular architecture allows your application to grow while maintaining clear separation of concerns and a clean, maintainable codebase.</p> <p>Note</p> <p>This guide is a starting point. It's highly recommended to read The Software Architecture Chronicles by Herberto Gra\u00e7a. He distills all popular software architectural styles into a single one to rule them all. It's a great read and will help you understand the principles behind <code>waku</code>.</p> <p>Happy coding with <code>waku</code>!</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#waku","title":"waku","text":""},{"location":"reference/#waku.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extension_registry = extension_registry\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.WakuApplication.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def close(self) -&gt; None:\n    if not self._initialized:\n        return\n    await self._call_on_shutdown_extensions()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n    provider_filter: IProviderFilter | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n    provider_filter: IProviderFilter | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n    self._provider_filter = provider_filter\n</code></pre>"},{"location":"reference/#waku.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(self) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(\n        self._root_module_type,\n        context=self._context,\n        provider_filter=self._provider_filter,\n        app_extensions=self._extensions,\n    ).build()\n\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extension_registry=self._build_extension_registry(registry.modules),\n    )\n</code></pre>"},{"location":"reference/#waku.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[ProviderSpec] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[ProviderSpec] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.Module","title":"Module","text":"<pre><code>Module(module_type: ModuleType, metadata: ModuleMetadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n\n    self.providers: Final[Sequence[ProviderSpec]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[type[object] | ModuleType | DynamicModule]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n\n    self._provider: BaseProvider | None = None\n</code></pre>"},{"location":"reference/#waku.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Final[UUID] = id\n</code></pre>"},{"location":"reference/#waku.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: Final[ModuleType] = module_type\n</code></pre>"},{"location":"reference/#waku.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers: Final[Sequence[ProviderSpec]] = providers\n</code></pre>"},{"location":"reference/#waku.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports: Final[Sequence[ModuleType | DynamicModule]] = (\n    imports\n)\n</code></pre>"},{"location":"reference/#waku.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports: Final[\n    Sequence[type[object] | ModuleType | DynamicModule]\n] = exports\n</code></pre>"},{"location":"reference/#waku.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Final[Sequence[ModuleExtension]] = extensions\n</code></pre>"},{"location":"reference/#waku.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: Final[bool] = is_global\n</code></pre>"},{"location":"reference/#waku.Module.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/#waku.Module.provider","title":"provider  <code>property</code>","text":"<pre><code>provider: BaseProvider\n</code></pre> <p>Get the aggregated provider for this module.</p> <p>This property returns the provider created by create_provider(). Must be called after create_provider() has been invoked.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If create_provider() has not been called yet.</p>"},{"location":"reference/#waku.Module.create_provider","title":"create_provider","text":"<pre><code>create_provider(\n    context: dict[Any, Any] | None,\n    builder: ActivationBuilder,\n    provider_filter: IProviderFilter,\n) -&gt; BaseProvider\n</code></pre> <p>Create aggregated provider with activation filtering applied.</p> PARAMETER DESCRIPTION <code>context</code> <p>Context dict for activation decisions.</p> <p> TYPE: <code>dict[Any, Any] | None</code> </p> <code>builder</code> <p>Activation builder for checking if types are registered.</p> <p> TYPE: <code>ActivationBuilder</code> </p> <code>provider_filter</code> <p>Filter strategy for conditional provider activation.</p> <p> TYPE: <code>IProviderFilter</code> </p> RETURNS DESCRIPTION <code>BaseProvider</code> <p>BaseProvider with only active providers aggregated.</p> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def create_provider(\n    self,\n    context: dict[Any, Any] | None,\n    builder: ActivationBuilder,\n    provider_filter: IProviderFilter,\n) -&gt; BaseProvider:\n    \"\"\"Create aggregated provider with activation filtering applied.\n\n    Args:\n        context: Context dict for activation decisions.\n        builder: Activation builder for checking if types are registered.\n        provider_filter: Filter strategy for conditional provider activation.\n\n    Returns:\n        BaseProvider with only active providers aggregated.\n    \"\"\"\n    active_providers = provider_filter.filter(\n        list(self.providers),\n        context=context,\n        module_type=self.target,\n        builder=builder,\n    )\n\n    cls = cast('type[_ModuleProvider]', type(f'{self.name}Provider', (_ModuleProvider,), {}))\n    self._provider = cls(active_providers)\n    return self._provider\n</code></pre>"},{"location":"reference/#waku.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[ProviderSpec] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        type[object] | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[ProviderSpec]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[type[object] | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[ProviderSpec] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[type[object] | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.application","title":"application","text":""},{"location":"reference/#waku.application.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extension_registry = extension_registry\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def close(self) -&gt; None:\n    if not self._initialized:\n        return\n    await self._call_on_shutdown_extensions()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.cqrs","title":"cqrs","text":""},{"location":"reference/#waku.cqrs.NextHandlerType","title":"NextHandlerType  <code>module-attribute</code>","text":"<pre><code>NextHandlerType: TypeAlias = Callable[\n    [RequestT], Awaitable[ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event(*, event_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>INotification</code></p> <p>Convenience base class for events with auto-generated ID.</p> <p>Use this class when you want automatic event_id generation. For custom identification strategies, implement INotification directly.</p> <p>Example::</p> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass UserCreated(Event):\n    user_id: str\n    email: str\n</code></pre>"},{"location":"reference/#waku.cqrs.Event.event_id","title":"event_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.INotification","title":"INotification","text":"<p>               Bases: <code>Protocol</code></p> <p>Marker interface for notification-type objects (events).</p> <p>This is a pure marker protocol with no required attributes or methods. Implement this protocol for domain events that need custom identification strategies or no identification at all.</p> <p>MediatR equivalent: INotification</p> <p>Example::</p> <pre><code>@dataclass(frozen=True)\nclass OrderPlaced(INotification):\n    order_id: str\n    customer_id: str\n\n\n# Or with custom identification:\n@dataclass(frozen=True)\nclass DomainEvent(INotification):\n    aggregate_id: str\n    occurred_at: datetime\n\n\n@dataclass(frozen=True)\nclass OrderPlaced(DomainEvent):\n    order_id: str\n</code></pre>"},{"location":"reference/#waku.cqrs.IPipelineBehavior","title":"IPipelineBehavior","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Interface for pipeline behaviors that wrap request handling.</p>"},{"location":"reference/#waku.cqrs.IPipelineBehavior.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(\n    request: RequestT,\n    /,\n    next_handler: NextHandlerType[RequestT, ResponseT],\n) -&gt; ResponseT\n</code></pre> <p>Handle the request and call the next handler in the pipeline.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to handle</p> <p> TYPE: <code>RequestT</code> </p> <code>next_handler</code> <p>Function to call the next handler in the pipeline</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The response from the pipeline</p> Source code in <code>src/waku/cqrs/contracts/pipeline.py</code> <pre><code>@abstractmethod\nasync def handle(self, request: RequestT, /, next_handler: NextHandlerType[RequestT, ResponseT]) -&gt; ResponseT:\n    \"\"\"Handle the request and call the next handler in the pipeline.\n\n    Args:\n        request: The request to handle\n        next_handler: Function to call the next handler in the pipeline\n\n    Returns:\n        The response from the pipeline\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.IRequest","title":"IRequest","text":"<p>               Bases: <code>Protocol[ResponseT]</code></p> <p>Marker interface for request-type objects (commands/queries).</p> <p>This is a pure marker protocol with no required attributes or methods. Implement this protocol for requests that need custom identification strategies or no identification at all.</p> <p>MediatR equivalent: IRequest <p>Example::</p> <pre><code>@dataclass(frozen=True)\nclass GetUserQuery(IRequest[UserDTO]):\n    user_id: str\n\n\n@dataclass(frozen=True)\nclass CreateOrderCommand(IRequest[OrderId]):\n    customer_id: str\n    items: list[OrderItem]\n</code></pre>"},{"location":"reference/#waku.cqrs.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>IRequest[ResponseT]</code>, <code>Generic[ResponseT]</code></p> <p>Convenience base class for requests with auto-generated ID.</p> <p>Use this class when you want automatic request_id generation. For custom identification strategies, implement IRequest directly.</p> <p>Example::</p> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass GetUserQuery(Request[UserDTO]):\n    user_id: str\n</code></pre>"},{"location":"reference/#waku.cqrs.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.cqrs.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>INotificationHandler[NotificationT]</code>, <code>ABC</code>, <code>Generic[NotificationT]</code></p> <p>Abstract base class for event handlers.</p> <p>Use this class when you want explicit ABC inheritance and type checking. For structural subtyping, implement INotificationHandler directly.</p> <p>Example::</p> <pre><code>class UserJoinedEventHandler(EventHandler[UserJoinedEvent]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, event: UserJoinedEvent, /) -&gt; None:\n        await self._meetings_api.notify_room(event.meeting_id, 'New user joined!')\n</code></pre>"},{"location":"reference/#waku.cqrs.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: NotificationT) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: NotificationT, /) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.INotificationHandler","title":"INotificationHandler","text":"<p>               Bases: <code>Protocol[NotificationT]</code></p> <p>Protocol for notification/event handlers.</p> <p>MediatR equivalent: INotificationHandler <p>This protocol allows structural subtyping - any class with a matching <code>handle</code> method signature is compatible.</p> <p>Example::</p> <pre><code>class OrderPlacedHandler(INotificationHandler[OrderPlaced]):\n    async def handle(self, event: OrderPlaced, /) -&gt; None:\n        await self._send_confirmation_email(event.order_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.INotificationHandler.handle","title":"handle  <code>async</code>","text":"<pre><code>handle(event: NotificationT) -&gt; None\n</code></pre> <p>Handle the notification/event.</p> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>async def handle(self, event: NotificationT, /) -&gt; None:\n    \"\"\"Handle the notification/event.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n    request_map: RequestMap,\n    event_map: EventMap,\n    behavior_map: PipelineBehaviorMap,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default CQRS implementation.</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>def __init__(\n    self,\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n    request_map: RequestMap,\n    event_map: EventMap,\n    behavior_map: PipelineBehaviorMap,\n) -&gt; None:\n    self._container = container\n    self._event_publisher = event_publisher\n    self._request_map = request_map\n    self._event_map = event_map\n    self._behavior_map = behavior_map\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: IRequest[None]) -&gt; None\n</code></pre><pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <pre><code>send(request: IRequest[Any]) -&gt; Any\n</code></pre> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def send(self, request: IRequest[Any], /) -&gt; Any:\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)  # pyrefly: ignore[bad-argument-type]\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(notification: INotification) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def publish(self, notification: INotification, /) -&gt; None:\n    event_type = type(notification)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, notification)\n</code></pre>"},{"location":"reference/#waku.cqrs.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a cqrs to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.cqrs.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(notification: INotification) -&gt; None\n</code></pre> <p>Asynchronously send notification to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, notification: INotification, /) -&gt; None:\n    \"\"\"Asynchronously send notification to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: IRequest[None]) -&gt; None\n</code></pre><pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: IRequest[ResponseT], /) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish notification through the cqrs to be handled by multiple handlers.</p>"},{"location":"reference/#waku.cqrs.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(notification: INotification) -&gt; None\n</code></pre> <p>Asynchronously send notification to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, notification: INotification, /) -&gt; None:\n    \"\"\"Asynchronously send notification to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the cqrs middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.cqrs.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: IRequest[None]) -&gt; None\n</code></pre><pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: IRequest[ResponseT], /) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    pipeline_behaviors: Sequence[\n        type[IPipelineBehavior[Any, Any]]\n    ] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the cqrs pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the cqrs interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>pipeline_behaviors</code> <p>A sequence of pipeline behavior configurations that will be applied to the cqrs pipeline. Behaviors are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[IPipelineBehavior[Any, Any]]]</code> </p> Example <pre><code>config = MediatorConfig(\n    pipeline_behaviors=[\n        LoggingBehavior,\n        ValidationBehavior,\n    ]\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.pipeline_behaviors","title":"pipeline_behaviors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pipeline_behaviors: Sequence[\n    type[IPipelineBehavior[Any, Any]]\n] = ()\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n    self._behavior_map = PipelineBehaviorMap()\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.request_map","title":"request_map  <code>property</code>","text":"<pre><code>request_map: RequestMap\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.event_map","title":"event_map  <code>property</code>","text":"<pre><code>event_map: EventMap\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.behavior_map","title":"behavior_map  <code>property</code>","text":"<pre><code>behavior_map: PipelineBehaviorMap\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: type[RequestHandler[RequestT, Any]],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, Any]]]\n    | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: type[RequestHandler[RequestT, Any]],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, Any]]] | None = None,\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    if behaviors:\n        self._behavior_map.bind(request_type, behaviors)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[NotificationT],\n    handler_types: list[type[EventHandler[NotificationT]]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[NotificationT],\n    handler_types: list[type[EventHandler[NotificationT]]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n            self._create_pipeline_behavior_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.cqrs.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=[\n            *cls._create_mediator_providers(config_),\n            *cls._create_pipeline_behavior_providers(config_),\n        ],\n        extensions=[RequestMapAggregator(), EventMapAggregator(), PipelineBehaviorMapAggregator()],\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.IRequestHandler","title":"IRequestHandler","text":"<p>               Bases: <code>Protocol[RequestT, ResponseT]</code></p> <p>Protocol for request handlers (commands/queries).</p> <p>MediatR equivalent: IRequestHandler <p>This protocol allows structural subtyping - any class with a matching <code>handle</code> method signature is compatible.</p> <p>Example::</p> <pre><code>class GetUserQueryHandler(IRequestHandler[GetUserQuery, UserDTO]):\n    async def handle(self, request: GetUserQuery, /) -&gt; UserDTO:\n        return await self._repository.get(request.user_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.IRequestHandler.handle","title":"handle  <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> <p>Handle the request and return a response.</p> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>async def handle(self, request: RequestT, /) -&gt; ResponseT:\n    \"\"\"Handle the request and return a response.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>IRequestHandler[RequestT, ResponseT]</code>, <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Abstract base class for request handlers.</p> <p>Use this class when you want explicit ABC inheritance and type checking. For structural subtyping, implement IRequestHandler directly.</p> <p>Command handler example::</p> <pre><code>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, request: JoinMeetingCommand, /) -&gt; None:\n        await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <pre><code>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, request: ReadMeetingQuery, /) -&gt; ReadMeetingQueryResult:\n        link = await self._meetings_api.get_link(request.meeting_id)\n        return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT, /) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts","title":"contracts","text":""},{"location":"reference/#waku.cqrs.contracts.NotificationT","title":"NotificationT  <code>module-attribute</code>","text":"<pre><code>NotificationT = TypeVar(\n    'NotificationT', bound=INotification, contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.NextHandlerType","title":"NextHandlerType  <code>module-attribute</code>","text":"<pre><code>NextHandlerType: TypeAlias = Callable[\n    [RequestT], Awaitable[ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.RequestT","title":"RequestT  <code>module-attribute</code>","text":"<pre><code>RequestT = TypeVar(\n    'RequestT', bound=IRequest[Any], contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.ResponseT","title":"ResponseT  <code>module-attribute</code>","text":"<pre><code>ResponseT = TypeVar(\n    'ResponseT',\n    bound='Response | None',\n    default=None,\n    covariant=True,\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event(*, event_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>INotification</code></p> <p>Convenience base class for events with auto-generated ID.</p> <p>Use this class when you want automatic event_id generation. For custom identification strategies, implement INotification directly.</p> <p>Example::</p> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass UserCreated(Event):\n    user_id: str\n    email: str\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.Event.event_id","title":"event_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.INotification","title":"INotification","text":"<p>               Bases: <code>Protocol</code></p> <p>Marker interface for notification-type objects (events).</p> <p>This is a pure marker protocol with no required attributes or methods. Implement this protocol for domain events that need custom identification strategies or no identification at all.</p> <p>MediatR equivalent: INotification</p> <p>Example::</p> <pre><code>@dataclass(frozen=True)\nclass OrderPlaced(INotification):\n    order_id: str\n    customer_id: str\n\n\n# Or with custom identification:\n@dataclass(frozen=True)\nclass DomainEvent(INotification):\n    aggregate_id: str\n    occurred_at: datetime\n\n\n@dataclass(frozen=True)\nclass OrderPlaced(DomainEvent):\n    order_id: str\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.IPipelineBehavior","title":"IPipelineBehavior","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Interface for pipeline behaviors that wrap request handling.</p>"},{"location":"reference/#waku.cqrs.contracts.IPipelineBehavior.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(\n    request: RequestT,\n    /,\n    next_handler: NextHandlerType[RequestT, ResponseT],\n) -&gt; ResponseT\n</code></pre> <p>Handle the request and call the next handler in the pipeline.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to handle</p> <p> TYPE: <code>RequestT</code> </p> <code>next_handler</code> <p>Function to call the next handler in the pipeline</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The response from the pipeline</p> Source code in <code>src/waku/cqrs/contracts/pipeline.py</code> <pre><code>@abstractmethod\nasync def handle(self, request: RequestT, /, next_handler: NextHandlerType[RequestT, ResponseT]) -&gt; ResponseT:\n    \"\"\"Handle the request and call the next handler in the pipeline.\n\n    Args:\n        request: The request to handle\n        next_handler: Function to call the next handler in the pipeline\n\n    Returns:\n        The response from the pipeline\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.IRequest","title":"IRequest","text":"<p>               Bases: <code>Protocol[ResponseT]</code></p> <p>Marker interface for request-type objects (commands/queries).</p> <p>This is a pure marker protocol with no required attributes or methods. Implement this protocol for requests that need custom identification strategies or no identification at all.</p> <p>MediatR equivalent: IRequest <p>Example::</p> <pre><code>@dataclass(frozen=True)\nclass GetUserQuery(IRequest[UserDTO]):\n    user_id: str\n\n\n@dataclass(frozen=True)\nclass CreateOrderCommand(IRequest[OrderId]):\n    customer_id: str\n    items: list[OrderItem]\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>IRequest[ResponseT]</code>, <code>Generic[ResponseT]</code></p> <p>Convenience base class for requests with auto-generated ID.</p> <p>Use this class when you want automatic request_id generation. For custom identification strategies, implement IRequest directly.</p> <p>Example::</p> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass GetUserQuery(Request[UserDTO]):\n    user_id: str\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.cqrs.contracts.event","title":"event","text":""},{"location":"reference/#waku.cqrs.contracts.event.NotificationT","title":"NotificationT  <code>module-attribute</code>","text":"<pre><code>NotificationT = TypeVar(\n    'NotificationT', bound=INotification, contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.event.INotification","title":"INotification","text":"<p>               Bases: <code>Protocol</code></p> <p>Marker interface for notification-type objects (events).</p> <p>This is a pure marker protocol with no required attributes or methods. Implement this protocol for domain events that need custom identification strategies or no identification at all.</p> <p>MediatR equivalent: INotification</p> <p>Example::</p> <pre><code>@dataclass(frozen=True)\nclass OrderPlaced(INotification):\n    order_id: str\n    customer_id: str\n\n\n# Or with custom identification:\n@dataclass(frozen=True)\nclass DomainEvent(INotification):\n    aggregate_id: str\n    occurred_at: datetime\n\n\n@dataclass(frozen=True)\nclass OrderPlaced(DomainEvent):\n    order_id: str\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.event.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event(*, event_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>INotification</code></p> <p>Convenience base class for events with auto-generated ID.</p> <p>Use this class when you want automatic event_id generation. For custom identification strategies, implement INotification directly.</p> <p>Example::</p> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass UserCreated(Event):\n    user_id: str\n    email: str\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.event.Event.event_id","title":"event_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.notification","title":"notification","text":""},{"location":"reference/#waku.cqrs.contracts.notification.NotificationT","title":"NotificationT  <code>module-attribute</code>","text":"<pre><code>NotificationT = TypeVar(\n    'NotificationT', bound=INotification, contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.notification.INotification","title":"INotification","text":"<p>               Bases: <code>Protocol</code></p> <p>Marker interface for notification-type objects (events).</p> <p>This is a pure marker protocol with no required attributes or methods. Implement this protocol for domain events that need custom identification strategies or no identification at all.</p> <p>MediatR equivalent: INotification</p> <p>Example::</p> <pre><code>@dataclass(frozen=True)\nclass OrderPlaced(INotification):\n    order_id: str\n    customer_id: str\n\n\n# Or with custom identification:\n@dataclass(frozen=True)\nclass DomainEvent(INotification):\n    aggregate_id: str\n    occurred_at: datetime\n\n\n@dataclass(frozen=True)\nclass OrderPlaced(DomainEvent):\n    order_id: str\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.pipeline","title":"pipeline","text":""},{"location":"reference/#waku.cqrs.contracts.pipeline.NextHandlerType","title":"NextHandlerType  <code>module-attribute</code>","text":"<pre><code>NextHandlerType: TypeAlias = Callable[\n    [RequestT], Awaitable[ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.pipeline.IPipelineBehavior","title":"IPipelineBehavior","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Interface for pipeline behaviors that wrap request handling.</p>"},{"location":"reference/#waku.cqrs.contracts.pipeline.IPipelineBehavior.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(\n    request: RequestT,\n    /,\n    next_handler: NextHandlerType[RequestT, ResponseT],\n) -&gt; ResponseT\n</code></pre> <p>Handle the request and call the next handler in the pipeline.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to handle</p> <p> TYPE: <code>RequestT</code> </p> <code>next_handler</code> <p>Function to call the next handler in the pipeline</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The response from the pipeline</p> Source code in <code>src/waku/cqrs/contracts/pipeline.py</code> <pre><code>@abstractmethod\nasync def handle(self, request: RequestT, /, next_handler: NextHandlerType[RequestT, ResponseT]) -&gt; ResponseT:\n    \"\"\"Handle the request and call the next handler in the pipeline.\n\n    Args:\n        request: The request to handle\n        next_handler: Function to call the next handler in the pipeline\n\n    Returns:\n        The response from the pipeline\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request","title":"request","text":""},{"location":"reference/#waku.cqrs.contracts.request.ResponseT","title":"ResponseT  <code>module-attribute</code>","text":"<pre><code>ResponseT = TypeVar(\n    'ResponseT',\n    bound='Response | None',\n    default=None,\n    covariant=True,\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.RequestT","title":"RequestT  <code>module-attribute</code>","text":"<pre><code>RequestT = TypeVar(\n    'RequestT', bound=IRequest[Any], contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.IRequest","title":"IRequest","text":"<p>               Bases: <code>Protocol[ResponseT]</code></p> <p>Marker interface for request-type objects (commands/queries).</p> <p>This is a pure marker protocol with no required attributes or methods. Implement this protocol for requests that need custom identification strategies or no identification at all.</p> <p>MediatR equivalent: IRequest <p>Example::</p> <pre><code>@dataclass(frozen=True)\nclass GetUserQuery(IRequest[UserDTO]):\n    user_id: str\n\n\n@dataclass(frozen=True)\nclass CreateOrderCommand(IRequest[OrderId]):\n    customer_id: str\n    items: list[OrderItem]\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>IRequest[ResponseT]</code>, <code>Generic[ResponseT]</code></p> <p>Convenience base class for requests with auto-generated ID.</p> <p>Use this class when you want automatic request_id generation. For custom identification strategies, implement IRequest directly.</p> <p>Example::</p> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass GetUserQuery(Request[UserDTO]):\n    user_id: str\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.cqrs.events","title":"events","text":""},{"location":"reference/#waku.cqrs.events.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>INotificationHandler[NotificationT]</code>, <code>ABC</code>, <code>Generic[NotificationT]</code></p> <p>Abstract base class for event handlers.</p> <p>Use this class when you want explicit ABC inheritance and type checking. For structural subtyping, implement INotificationHandler directly.</p> <p>Example::</p> <pre><code>class UserJoinedEventHandler(EventHandler[UserJoinedEvent]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, event: UserJoinedEvent, /) -&gt; None:\n        await self._meetings_api.notify_room(event.meeting_id, 'New user joined!')\n</code></pre>"},{"location":"reference/#waku.cqrs.events.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: NotificationT) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: NotificationT, /) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.events.EventPublisher","title":"EventPublisher","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.cqrs.events.GroupEventPublisher","title":"GroupEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.events.SequentialEventPublisher","title":"SequentialEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.events.handler","title":"handler","text":""},{"location":"reference/#waku.cqrs.events.handler.INotificationHandler","title":"INotificationHandler","text":"<p>               Bases: <code>Protocol[NotificationT]</code></p> <p>Protocol for notification/event handlers.</p> <p>MediatR equivalent: INotificationHandler <p>This protocol allows structural subtyping - any class with a matching <code>handle</code> method signature is compatible.</p> <p>Example::</p> <pre><code>class OrderPlacedHandler(INotificationHandler[OrderPlaced]):\n    async def handle(self, event: OrderPlaced, /) -&gt; None:\n        await self._send_confirmation_email(event.order_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.events.handler.INotificationHandler.handle","title":"handle  <code>async</code>","text":"<pre><code>handle(event: NotificationT) -&gt; None\n</code></pre> <p>Handle the notification/event.</p> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>async def handle(self, event: NotificationT, /) -&gt; None:\n    \"\"\"Handle the notification/event.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.events.handler.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>INotificationHandler[NotificationT]</code>, <code>ABC</code>, <code>Generic[NotificationT]</code></p> <p>Abstract base class for event handlers.</p> <p>Use this class when you want explicit ABC inheritance and type checking. For structural subtyping, implement INotificationHandler directly.</p> <p>Example::</p> <pre><code>class UserJoinedEventHandler(EventHandler[UserJoinedEvent]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, event: UserJoinedEvent, /) -&gt; None:\n        await self._meetings_api.notify_room(event.meeting_id, 'New user joined!')\n</code></pre>"},{"location":"reference/#waku.cqrs.events.handler.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: NotificationT) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: NotificationT, /) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map","title":"map","text":""},{"location":"reference/#waku.cqrs.events.map.EventMapRegistry","title":"EventMapRegistry  <code>module-attribute</code>","text":"<pre><code>EventMapRegistry: TypeAlias = MutableMapping[\n    type[INotification], EventMapEntry[INotification]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMapEntry","title":"EventMapEntry  <code>dataclass</code>","text":"<pre><code>EventMapEntry(\n    di_lookup_type: type[EventHandler[_EventT]],\n    handler_types: list[\n        type[EventHandler[_EventT]]\n    ] = list(),\n)\n</code></pre> <p>               Bases: <code>Generic[_EventT]</code></p>"},{"location":"reference/#waku.cqrs.events.map.EventMapEntry.di_lookup_type","title":"di_lookup_type  <code>instance-attribute</code>","text":"<pre><code>di_lookup_type: type[EventHandler[_EventT]]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMapEntry.handler_types","title":"handler_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>handler_types: list[type[EventHandler[_EventT]]] = field(\n    default_factory=list\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap","title":"EventMap","text":"<pre><code>EventMap()\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: EventMapRegistry = {}\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: EventMapRegistry\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.bind","title":"bind","text":"<pre><code>bind(\n    event_type: type[NotificationT],\n    handler_types: list[type[EventHandler[NotificationT]]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def bind(self, event_type: type[NotificationT], handler_types: list[type[EventHandler[NotificationT]]]) -&gt; Self:\n    if event_type not in self._registry:\n        di_lookup_type = EventHandler[event_type]  # type: ignore[valid-type]\n        self._registry[event_type] = EventMapEntry(di_lookup_type=di_lookup_type)  # type: ignore[type-abstract]\n\n    entry = self._registry[event_type]\n    for handler_type in handler_types:\n        if handler_type in entry.handler_types:\n            raise EventHandlerAlreadyRegistered(event_type, handler_type)\n        entry.handler_types.append(handler_type)  # type: ignore[arg-type]\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.merge","title":"merge","text":"<pre><code>merge(other: EventMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def merge(self, other: EventMap) -&gt; Self:\n    for event_type, entry in other._registry.items():\n        self.bind(event_type, entry.handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.has_handlers","title":"has_handlers","text":"<pre><code>has_handlers(event_type: type[INotification]) -&gt; bool\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def has_handlers(self, event_type: type[INotification]) -&gt; bool:\n    return event_type in self._registry and len(self._registry[event_type].handler_types) &gt; 0\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.get_handler_type","title":"get_handler_type","text":"<pre><code>get_handler_type(\n    event_type: type[INotification],\n) -&gt; type[EventHandler[INotification]]\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def get_handler_type(self, event_type: type[INotification]) -&gt; type[EventHandler[INotification]]:\n    return self._registry[event_type].di_lookup_type\n</code></pre>"},{"location":"reference/#waku.cqrs.events.publish","title":"publish","text":""},{"location":"reference/#waku.cqrs.events.publish.EventPublisher","title":"EventPublisher","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.cqrs.events.publish.SequentialEventPublisher","title":"SequentialEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.events.publish.GroupEventPublisher","title":"GroupEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.cqrs.exceptions.MediatorError","title":"MediatorError","text":"<p>               Bases: <code>WakuError</code></p> <p>Base exception for all cqrs-related errors.</p>"},{"location":"reference/#waku.cqrs.exceptions.ImproperlyConfiguredError","title":"ImproperlyConfiguredError","text":"<p>               Bases: <code>MediatorError</code></p> <p>Raised when cqrs configuration is invalid.</p>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered","title":"RequestHandlerAlreadyRegistered","text":"<pre><code>RequestHandlerAlreadyRegistered(\n    request_type: type[IRequest[Any]],\n    handler_type: type[IRequestHandler[Any, Any]],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a request handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[IRequest[Any]], handler_type: type[IRequestHandler[Any, Any]]) -&gt; None:\n    self.request_type = request_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerNotFound","title":"RequestHandlerNotFound","text":"<pre><code>RequestHandlerNotFound(request_type: type[IRequest[Any]])\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when a request handler is not found.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[IRequest[Any]]) -&gt; None:\n    self.request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerNotFound.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered","title":"EventHandlerAlreadyRegistered","text":"<pre><code>EventHandlerAlreadyRegistered(\n    event_type: type[INotification],\n    handler_type: type[INotificationHandler[Any]],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when an notification handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of notification that caused the error.</p> <p> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, event_type: type[INotification], handler_type: type[INotificationHandler[Any]]) -&gt; None:\n    self.event_type = event_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type = event_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered","title":"PipelineBehaviorAlreadyRegistered","text":"<pre><code>PipelineBehaviorAlreadyRegistered(\n    request_type: type[IRequest[Any]],\n    behavior_type: type[IPipelineBehavior[Any, Any]],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a pipeline behavior is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> <code>behavior_type</code> <p>The type of behavior that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[IRequest[Any]], behavior_type: type[IPipelineBehavior[Any, Any]]) -&gt; None:\n    self.request_type = request_type\n    self.behavior_type = behavior_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered.behavior_type","title":"behavior_type  <code>instance-attribute</code>","text":"<pre><code>behavior_type = behavior_type\n</code></pre>"},{"location":"reference/#waku.cqrs.impl","title":"impl","text":""},{"location":"reference/#waku.cqrs.impl.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n    request_map: RequestMap,\n    event_map: EventMap,\n    behavior_map: PipelineBehaviorMap,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default CQRS implementation.</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>def __init__(\n    self,\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n    request_map: RequestMap,\n    event_map: EventMap,\n    behavior_map: PipelineBehaviorMap,\n) -&gt; None:\n    self._container = container\n    self._event_publisher = event_publisher\n    self._request_map = request_map\n    self._event_map = event_map\n    self._behavior_map = behavior_map\n</code></pre>"},{"location":"reference/#waku.cqrs.impl.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: IRequest[None]) -&gt; None\n</code></pre><pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <pre><code>send(request: IRequest[Any]) -&gt; Any\n</code></pre> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def send(self, request: IRequest[Any], /) -&gt; Any:\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)  # pyrefly: ignore[bad-argument-type]\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.cqrs.impl.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(notification: INotification) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def publish(self, notification: INotification, /) -&gt; None:\n    event_type = type(notification)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, notification)\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces","title":"interfaces","text":""},{"location":"reference/#waku.cqrs.interfaces.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the cqrs middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.cqrs.interfaces.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: IRequest[None]) -&gt; None\n</code></pre><pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: IRequest[ResponseT], /) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish notification through the cqrs to be handled by multiple handlers.</p>"},{"location":"reference/#waku.cqrs.interfaces.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(notification: INotification) -&gt; None\n</code></pre> <p>Asynchronously send notification to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, notification: INotification, /) -&gt; None:\n    \"\"\"Asynchronously send notification to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a cqrs to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.cqrs.interfaces.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(notification: INotification) -&gt; None\n</code></pre> <p>Asynchronously send notification to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, notification: INotification, /) -&gt; None:\n    \"\"\"Asynchronously send notification to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: IRequest[None]) -&gt; None\n</code></pre><pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <pre><code>send(request: IRequest[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: IRequest[ResponseT], /) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.modules","title":"modules","text":""},{"location":"reference/#waku.cqrs.modules.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    pipeline_behaviors: Sequence[\n        type[IPipelineBehavior[Any, Any]]\n    ] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the cqrs pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the cqrs interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>pipeline_behaviors</code> <p>A sequence of pipeline behavior configurations that will be applied to the cqrs pipeline. Behaviors are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[IPipelineBehavior[Any, Any]]]</code> </p> Example <pre><code>config = MediatorConfig(\n    pipeline_behaviors=[\n        LoggingBehavior,\n        ValidationBehavior,\n    ]\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.pipeline_behaviors","title":"pipeline_behaviors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pipeline_behaviors: Sequence[\n    type[IPipelineBehavior[Any, Any]]\n] = ()\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.cqrs.modules.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=[\n            *cls._create_mediator_providers(config_),\n            *cls._create_pipeline_behavior_providers(config_),\n        ],\n        extensions=[RequestMapAggregator(), EventMapAggregator(), PipelineBehaviorMapAggregator()],\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n    self._behavior_map = PipelineBehaviorMap()\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.request_map","title":"request_map  <code>property</code>","text":"<pre><code>request_map: RequestMap\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.event_map","title":"event_map  <code>property</code>","text":"<pre><code>event_map: EventMap\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.behavior_map","title":"behavior_map  <code>property</code>","text":"<pre><code>behavior_map: PipelineBehaviorMap\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: type[RequestHandler[RequestT, Any]],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, Any]]]\n    | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: type[RequestHandler[RequestT, Any]],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, Any]]] | None = None,\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    if behaviors:\n        self._behavior_map.bind(request_type, behaviors)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[NotificationT],\n    handler_types: list[type[EventHandler[NotificationT]]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[NotificationT],\n    handler_types: list[type[EventHandler[NotificationT]]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n            self._create_pipeline_behavior_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.RequestMapAggregator","title":"RequestMapAggregator","text":"<p>               Bases: <code>OnModuleRegistration</code></p>"},{"location":"reference/#waku.cqrs.modules.RequestMapAggregator.on_module_registration","title":"on_module_registration","text":"<pre><code>on_module_registration(\n    registry: ModuleMetadataRegistry,\n    owning_module: ModuleType,\n    context: Mapping[Any, Any] | None,\n) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@override\ndef on_module_registration(\n    self,\n    registry: ModuleMetadataRegistry,\n    owning_module: 'ModuleType',\n    context: Mapping[Any, Any] | None,\n) -&gt; None:\n    aggregated = RequestMap()\n    for _module_type, ext in registry.find_extensions(MediatorExtension):\n        aggregated.merge(ext.request_map)\n    registry.add_provider(owning_module, object_(aggregated))\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.EventMapAggregator","title":"EventMapAggregator","text":"<p>               Bases: <code>OnModuleRegistration</code></p>"},{"location":"reference/#waku.cqrs.modules.EventMapAggregator.on_module_registration","title":"on_module_registration","text":"<pre><code>on_module_registration(\n    registry: ModuleMetadataRegistry,\n    owning_module: ModuleType,\n    context: Mapping[Any, Any] | None,\n) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@override\ndef on_module_registration(\n    self,\n    registry: ModuleMetadataRegistry,\n    owning_module: 'ModuleType',\n    context: Mapping[Any, Any] | None,\n) -&gt; None:\n    aggregated = EventMap()\n    for _module_type, ext in registry.find_extensions(MediatorExtension):\n        aggregated.merge(ext.event_map)\n    registry.add_provider(owning_module, object_(aggregated))\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.PipelineBehaviorMapAggregator","title":"PipelineBehaviorMapAggregator","text":"<p>               Bases: <code>OnModuleRegistration</code></p>"},{"location":"reference/#waku.cqrs.modules.PipelineBehaviorMapAggregator.on_module_registration","title":"on_module_registration","text":"<pre><code>on_module_registration(\n    registry: ModuleMetadataRegistry,\n    owning_module: ModuleType,\n    context: Mapping[Any, Any] | None,\n) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@override\ndef on_module_registration(\n    self,\n    registry: ModuleMetadataRegistry,\n    owning_module: 'ModuleType',\n    context: Mapping[Any, Any] | None,\n) -&gt; None:\n    aggregated = PipelineBehaviorMap()\n    for _module_type, ext in registry.find_extensions(MediatorExtension):\n        aggregated.merge(ext.behavior_map)\n    registry.add_provider(owning_module, object_(aggregated))\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline","title":"pipeline","text":""},{"location":"reference/#waku.cqrs.pipeline.PipelineBehaviorWrapper","title":"PipelineBehaviorWrapper","text":"<pre><code>PipelineBehaviorWrapper(\n    behaviors: Sequence[\n        IPipelineBehavior[RequestT, ResponseT]\n    ],\n)\n</code></pre> <p>               Bases: <code>Generic[RequestT, ResponseT]</code></p> <p>Composes pipeline behaviors into a processing chain.</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def __init__(self, behaviors: Sequence[IPipelineBehavior[RequestT, ResponseT]]) -&gt; None:\n    self._behaviors = tuple(behaviors)\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.PipelineBehaviorWrapper.wrap","title":"wrap","text":"<pre><code>wrap(\n    handle: NextHandlerType[RequestT, ResponseT],\n) -&gt; NextHandlerType[RequestT, ResponseT]\n</code></pre> <p>Create a pipeline that wraps the handler function with behaviors.</p> <p>Pipeline behaviors are executed in the order they are provided.</p> PARAMETER DESCRIPTION <code>handle</code> <p>The handler function to wrap with behaviors</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>NextHandlerType[RequestT, ResponseT]</code> <p>A function that executes the entire pipeline</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def wrap(self, handle: NextHandlerType[RequestT, ResponseT]) -&gt; NextHandlerType[RequestT, ResponseT]:\n    \"\"\"Create a pipeline that wraps the handler function with behaviors.\n\n    Pipeline behaviors are executed in the order they are provided.\n\n    Args:\n        handle: The handler function to wrap with behaviors\n\n    Returns:\n        A function that executes the entire pipeline\n    \"\"\"\n    if not self._behaviors:\n        return handle\n\n    behaviors = self._behaviors\n\n    async def pipeline(request: RequestT) -&gt; ResponseT:\n        async def execute(req: RequestT, idx: int) -&gt; ResponseT:\n            if idx &gt;= len(behaviors):\n                return await handle(req)\n            return await behaviors[idx].handle(req, next_handler=lambda r: execute(r, idx + 1))\n\n        return await execute(request, 0)\n\n    return pipeline\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.chain","title":"chain","text":""},{"location":"reference/#waku.cqrs.pipeline.chain.PipelineBehaviorWrapper","title":"PipelineBehaviorWrapper","text":"<pre><code>PipelineBehaviorWrapper(\n    behaviors: Sequence[\n        IPipelineBehavior[RequestT, ResponseT]\n    ],\n)\n</code></pre> <p>               Bases: <code>Generic[RequestT, ResponseT]</code></p> <p>Composes pipeline behaviors into a processing chain.</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def __init__(self, behaviors: Sequence[IPipelineBehavior[RequestT, ResponseT]]) -&gt; None:\n    self._behaviors = tuple(behaviors)\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.chain.PipelineBehaviorWrapper.wrap","title":"wrap","text":"<pre><code>wrap(\n    handle: NextHandlerType[RequestT, ResponseT],\n) -&gt; NextHandlerType[RequestT, ResponseT]\n</code></pre> <p>Create a pipeline that wraps the handler function with behaviors.</p> <p>Pipeline behaviors are executed in the order they are provided.</p> PARAMETER DESCRIPTION <code>handle</code> <p>The handler function to wrap with behaviors</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>NextHandlerType[RequestT, ResponseT]</code> <p>A function that executes the entire pipeline</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def wrap(self, handle: NextHandlerType[RequestT, ResponseT]) -&gt; NextHandlerType[RequestT, ResponseT]:\n    \"\"\"Create a pipeline that wraps the handler function with behaviors.\n\n    Pipeline behaviors are executed in the order they are provided.\n\n    Args:\n        handle: The handler function to wrap with behaviors\n\n    Returns:\n        A function that executes the entire pipeline\n    \"\"\"\n    if not self._behaviors:\n        return handle\n\n    behaviors = self._behaviors\n\n    async def pipeline(request: RequestT) -&gt; ResponseT:\n        async def execute(req: RequestT, idx: int) -&gt; ResponseT:\n            if idx &gt;= len(behaviors):\n                return await handle(req)\n            return await behaviors[idx].handle(req, next_handler=lambda r: execute(r, idx + 1))\n\n        return await execute(request, 0)\n\n    return pipeline\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map","title":"map","text":""},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMapRegistry","title":"PipelineBehaviorMapRegistry  <code>module-attribute</code>","text":"<pre><code>PipelineBehaviorMapRegistry: TypeAlias = MutableMapping[\n    type[RequestT], PipelineBehaviorMapEntry\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMapEntry","title":"PipelineBehaviorMapEntry  <code>dataclass</code>","text":"<pre><code>PipelineBehaviorMapEntry(\n    di_lookup_type: type[IPipelineBehavior[Any, Any]],\n    behavior_types: list[\n        type[IPipelineBehavior[Any, Any]]\n    ] = list(),\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMapEntry.di_lookup_type","title":"di_lookup_type  <code>instance-attribute</code>","text":"<pre><code>di_lookup_type: type[IPipelineBehavior[Any, Any]]\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMapEntry.behavior_types","title":"behavior_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>behavior_types: list[type[IPipelineBehavior[Any, Any]]] = (\n    field(default_factory=list)\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMap","title":"PipelineBehaviorMap","text":"<pre><code>PipelineBehaviorMap()\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: PipelineBehaviorMapRegistry[Any] = {}\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: PipelineBehaviorMapRegistry[Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    behavior_types: list[\n        type[IPipelineBehavior[RequestT, ResponseT]]\n    ],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def bind(\n    self,\n    request_type: type[RequestT],\n    behavior_types: list[type[IPipelineBehavior[RequestT, ResponseT]]],\n) -&gt; Self:\n    if request_type not in self._registry:\n        response_type = get_request_response_type(request_type)\n        di_lookup_type = IPipelineBehavior[request_type, response_type]  # type: ignore[valid-type]\n        self._registry[request_type] = PipelineBehaviorMapEntry(di_lookup_type=di_lookup_type)  # type: ignore[type-abstract]\n\n    entry = self._registry[request_type]\n    for behavior_type in behavior_types:\n        if behavior_type in entry.behavior_types:\n            raise PipelineBehaviorAlreadyRegistered(request_type, behavior_type)\n        entry.behavior_types.append(behavior_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMap.merge","title":"merge","text":"<pre><code>merge(other: PipelineBehaviorMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def merge(self, other: PipelineBehaviorMap) -&gt; Self:\n    for request_type, entry in other._registry.items():\n        self.bind(request_type, entry.behavior_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMap.has_behaviors","title":"has_behaviors","text":"<pre><code>has_behaviors(request_type: type[RequestT]) -&gt; bool\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def has_behaviors(self, request_type: type[RequestT]) -&gt; bool:\n    return request_type in self._registry and len(self._registry[request_type].behavior_types) &gt; 0\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMap.get_lookup_type","title":"get_lookup_type","text":"<pre><code>get_lookup_type(\n    request_type: type[RequestT],\n) -&gt; type[IPipelineBehavior[Any, Any]]\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def get_lookup_type(self, request_type: type[RequestT]) -&gt; type[IPipelineBehavior[Any, Any]]:\n    return self._registry[request_type].di_lookup_type\n</code></pre>"},{"location":"reference/#waku.cqrs.requests","title":"requests","text":""},{"location":"reference/#waku.cqrs.requests.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>IRequestHandler[RequestT, ResponseT]</code>, <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Abstract base class for request handlers.</p> <p>Use this class when you want explicit ABC inheritance and type checking. For structural subtyping, implement IRequestHandler directly.</p> <p>Command handler example::</p> <pre><code>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, request: JoinMeetingCommand, /) -&gt; None:\n        await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <pre><code>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, request: ReadMeetingQuery, /) -&gt; ReadMeetingQueryResult:\n        link = await self._meetings_api.get_link(request.meeting_id)\n        return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT, /) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler","title":"handler","text":""},{"location":"reference/#waku.cqrs.requests.handler.IRequestHandler","title":"IRequestHandler","text":"<p>               Bases: <code>Protocol[RequestT, ResponseT]</code></p> <p>Protocol for request handlers (commands/queries).</p> <p>MediatR equivalent: IRequestHandler <p>This protocol allows structural subtyping - any class with a matching <code>handle</code> method signature is compatible.</p> <p>Example::</p> <pre><code>class GetUserQueryHandler(IRequestHandler[GetUserQuery, UserDTO]):\n    async def handle(self, request: GetUserQuery, /) -&gt; UserDTO:\n        return await self._repository.get(request.user_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler.IRequestHandler.handle","title":"handle  <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> <p>Handle the request and return a response.</p> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>async def handle(self, request: RequestT, /) -&gt; ResponseT:\n    \"\"\"Handle the request and return a response.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>IRequestHandler[RequestT, ResponseT]</code>, <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Abstract base class for request handlers.</p> <p>Use this class when you want explicit ABC inheritance and type checking. For structural subtyping, implement IRequestHandler directly.</p> <p>Command handler example::</p> <pre><code>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, request: JoinMeetingCommand, /) -&gt; None:\n        await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <pre><code>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult]):\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    async def handle(self, request: ReadMeetingQuery, /) -&gt; ReadMeetingQueryResult:\n        link = await self._meetings_api.get_link(request.meeting_id)\n        return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT, /) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map","title":"map","text":""},{"location":"reference/#waku.cqrs.requests.map.RequestMapRegistry","title":"RequestMapRegistry  <code>module-attribute</code>","text":"<pre><code>RequestMapRegistry: TypeAlias = MutableMapping[\n    type[IRequest[Response | None]],\n    RequestMapEntry[\n        IRequest[Response | None], Response | None\n    ],\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMapEntry","title":"RequestMapEntry  <code>dataclass</code>","text":"<pre><code>RequestMapEntry(\n    handler_type: type[RequestHandler[_MapReqT, _MapResT]],\n    di_lookup_type: type[\n        RequestHandler[_MapReqT, _MapResT]\n    ],\n)\n</code></pre> <p>               Bases: <code>Generic[_MapReqT, _MapResT]</code></p>"},{"location":"reference/#waku.cqrs.requests.map.RequestMapEntry.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type: type[RequestHandler[_MapReqT, _MapResT]]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMapEntry.di_lookup_type","title":"di_lookup_type  <code>instance-attribute</code>","text":"<pre><code>di_lookup_type: type[RequestHandler[_MapReqT, _MapResT]]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry = {}\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: RequestMapRegistry\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    handler_type: type[RequestHandler[RequestT, ResponseT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def bind(\n    self,\n    request_type: type[RequestT],\n    handler_type: type[RequestHandler[RequestT, ResponseT]],\n) -&gt; Self:\n    if request_type in self._registry:\n        raise RequestHandlerAlreadyRegistered(request_type, handler_type)\n    response_type = get_request_response_type(request_type)\n    di_lookup_type = RequestHandler[request_type, response_type]  # type: ignore[valid-type]\n    self._registry[request_type] = RequestMapEntry(handler_type, di_lookup_type)  # type: ignore[type-abstract, arg-type]\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.merge","title":"merge","text":"<pre><code>merge(other: RequestMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, entry in other._registry.items():\n        if request_type in self._registry:\n            raise RequestHandlerAlreadyRegistered(request_type, entry.handler_type)\n        self._registry[request_type] = RequestMapEntry(entry.handler_type, entry.di_lookup_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.has_handler","title":"has_handler","text":"<pre><code>has_handler(request_type: type[RequestT]) -&gt; bool\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def has_handler(self, request_type: type[RequestT]) -&gt; bool:\n    return request_type in self._registry\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.get_handler_type","title":"get_handler_type","text":"<pre><code>get_handler_type(\n    request_type: type[RequestT],\n) -&gt; type[RequestHandler[RequestT, Response | None]]\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def get_handler_type(self, request_type: type[RequestT]) -&gt; type[RequestHandler[RequestT, Response | None]]:\n    return self._registry[request_type].di_lookup_type\n</code></pre>"},{"location":"reference/#waku.cqrs.utils","title":"utils","text":""},{"location":"reference/#waku.cqrs.utils.get_request_response_type","title":"get_request_response_type  <code>cached</code>","text":"<pre><code>get_request_response_type(\n    request_type: type[IRequest[ResponseT]],\n) -&gt; type[ResponseT]\n</code></pre> <p>Extract the response type from an IRequest implementation.</p> <p>Searches through the class hierarchy to find IRequest or its subclasses, supporting direct implementations, Request subclasses, and nested inheritance.</p> RAISES DESCRIPTION <code>TypeError</code> <p>if response type cannot be extracted from the request type.</p> Source code in <code>src/waku/cqrs/utils.py</code> <pre><code>@functools.cache\ndef get_request_response_type(request_type: type[IRequest[ResponseT]]) -&gt; type[ResponseT]:\n    \"\"\"Extract the response type from an IRequest implementation.\n\n    Searches through the class hierarchy to find IRequest or its subclasses,\n    supporting direct implementations, Request subclasses, and nested inheritance.\n\n    Raises:\n        TypeError: if response type cannot be extracted from the request type.\n    \"\"\"\n    for cls in request_type.__mro__:\n        if cls is object:\n            break\n        if response_type := _extract_response_from_bases(cls):\n            return response_type  # type: ignore[return-value]\n\n    msg = f'Could not extract response type from {request_type.__name__}'\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/#waku.di","title":"di","text":""},{"location":"reference/#waku.di.Activator","title":"Activator  <code>module-attribute</code>","text":"<pre><code>Activator: TypeAlias = Callable[[ActivationContext], bool]\n</code></pre>"},{"location":"reference/#waku.di.ProviderSpec","title":"ProviderSpec  <code>module-attribute</code>","text":"<pre><code>ProviderSpec: TypeAlias = Provider | ConditionalProvider\n</code></pre>"},{"location":"reference/#waku.di.ActivationBuilder","title":"ActivationBuilder","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.di.ActivationBuilder.has_active","title":"has_active  <code>abstractmethod</code>","text":"<pre><code>has_active(type_: Any) -&gt; bool\n</code></pre> Source code in <code>src/waku/di/_activation.py</code> <pre><code>@abstractmethod\ndef has_active(self, type_: Any) -&gt; bool:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.di.ActivationContext","title":"ActivationContext","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Context passed to activators for provider activation decisions.</p>"},{"location":"reference/#waku.di.ActivationContext.container_context","title":"container_context  <code>instance-attribute</code>","text":"<pre><code>container_context: dict[Any, Any] | None\n</code></pre>"},{"location":"reference/#waku.di.ActivationContext.module_type","title":"module_type  <code>instance-attribute</code>","text":"<pre><code>module_type: ModuleType | DynamicModule\n</code></pre>"},{"location":"reference/#waku.di.ActivationContext.provided_type","title":"provided_type  <code>instance-attribute</code>","text":"<pre><code>provided_type: Any\n</code></pre>"},{"location":"reference/#waku.di.ActivationContext.builder","title":"builder  <code>instance-attribute</code>","text":"<pre><code>builder: ActivationBuilder\n</code></pre>"},{"location":"reference/#waku.di.ConditionalProvider","title":"ConditionalProvider  <code>dataclass</code>","text":"<pre><code>ConditionalProvider(\n    provider: Provider, when: Activator, provided_type: Any\n)\n</code></pre> <p>Provider with activation condition.</p>"},{"location":"reference/#waku.di.ConditionalProvider.provider","title":"provider  <code>instance-attribute</code>","text":"<pre><code>provider: Provider\n</code></pre>"},{"location":"reference/#waku.di.ConditionalProvider.when","title":"when  <code>instance-attribute</code>","text":"<pre><code>when: Activator\n</code></pre>"},{"location":"reference/#waku.di.ConditionalProvider.provided_type","title":"provided_type  <code>instance-attribute</code>","text":"<pre><code>provided_type: Any\n</code></pre>"},{"location":"reference/#waku.di.Has","title":"Has  <code>dataclass</code>","text":"<pre><code>Has(type_: Any)\n</code></pre> <p>Activator that checks if a provider for a type is registered.</p>"},{"location":"reference/#waku.di.Has.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_: Any\n</code></pre>"},{"location":"reference/#waku.di.IProviderFilter","title":"IProviderFilter","text":"<p>               Bases: <code>Protocol</code></p> <p>Strategy for filtering providers based on activation context.</p>"},{"location":"reference/#waku.di.IProviderFilter.filter","title":"filter","text":"<pre><code>filter(\n    providers: list[ProviderSpec],\n    context: dict[Any, Any] | None,\n    module_type: ModuleType | DynamicModule,\n    builder: ActivationBuilder,\n) -&gt; list[Provider]\n</code></pre> Source code in <code>src/waku/di/_activation.py</code> <pre><code>def filter(\n    self,\n    providers: list[ProviderSpec],\n    context: dict[Any, Any] | None,\n    module_type: ModuleType | DynamicModule,\n    builder: ActivationBuilder,\n) -&gt; list[Provider]: ...\n</code></pre>"},{"location":"reference/#waku.di.ProviderFilter","title":"ProviderFilter  <code>dataclass</code>","text":"<pre><code>ProviderFilter(on_skip: OnSkipCallback | None = None)\n</code></pre> <p>Default provider filter implementation.</p>"},{"location":"reference/#waku.di.ProviderFilter.on_skip","title":"on_skip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>on_skip: OnSkipCallback | None = field(default=None)\n</code></pre>"},{"location":"reference/#waku.di.ProviderFilter.filter","title":"filter","text":"<pre><code>filter(\n    providers: list[ProviderSpec],\n    context: dict[Any, Any] | None,\n    module_type: ModuleType | DynamicModule,\n    builder: ActivationBuilder,\n) -&gt; list[Provider]\n</code></pre> Source code in <code>src/waku/di/_activation.py</code> <pre><code>def filter(\n    self,\n    providers: list[ProviderSpec],\n    context: dict[Any, Any] | None,\n    module_type: ModuleType | DynamicModule,\n    builder: ActivationBuilder,\n) -&gt; list[Provider]:\n    result: list[Provider] = []\n\n    for spec in providers:\n        if isinstance(spec, ConditionalProvider):\n            ctx = ActivationContext(\n                container_context=context,\n                module_type=module_type,\n                provided_type=spec.provided_type,\n                builder=builder,\n            )\n            if spec.when(ctx):\n                result.append(spec.provider)\n            elif self.on_skip:\n                self.on_skip(spec, ctx)\n        else:\n            result.append(spec)\n\n    return result\n</code></pre>"},{"location":"reference/#waku.di.contextual","title":"contextual","text":"<pre><code>contextual(\n    provided_type: Any, *, scope: Scope = REQUEST\n) -&gt; Provider\n</code></pre><pre><code>contextual(\n    provided_type: Any,\n    *,\n    scope: Scope = REQUEST,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre> <pre><code>contextual(\n    provided_type: Any,\n    *,\n    scope: Scope = REQUEST,\n    when: Activator | None = None,\n) -&gt; ProviderSpec\n</code></pre> <p>Provide a dependency from the current context (e.g., app/request).</p> PARAMETER DESCRIPTION <code>provided_type</code> <p>The type to resolve from context.</p> <p> TYPE: <code>Any</code> </p> <code>scope</code> <p>Scope of the context variable (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> <code>when</code> <p>Optional predicate to conditionally activate the provider.</p> <p> TYPE: <code>Activator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProviderSpec</code> <p>Provider or ConditionalProvider if <code>when</code> is specified.</p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def contextual(\n    provided_type: Any,\n    *,\n    scope: Scope = Scope.REQUEST,\n    when: Activator | None = None,\n) -&gt; ProviderSpec:\n    \"\"\"Provide a dependency from the current context (e.g., app/request).\n\n    Args:\n        provided_type: The type to resolve from context.\n        scope: Scope of the context variable (default: Scope.REQUEST).\n        when: Optional predicate to conditionally activate the provider.\n\n    Returns:\n        Provider or ConditionalProvider if `when` is specified.\n    \"\"\"\n    provider_ = Provider()\n    provider_.from_context(provided_type, scope=scope)\n\n    if when is None:\n        return provider_\n    return ConditionalProvider(provider=provider_, when=when, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.di.many","title":"many","text":"<pre><code>many(\n    interface: Any,\n    *implementations: Any,\n    scope: Scope = REQUEST,\n    cache: bool = True,\n) -&gt; Provider\n</code></pre><pre><code>many(\n    interface: Any,\n    *implementations: Any,\n    scope: Scope = REQUEST,\n    cache: bool = True,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre> <pre><code>many(\n    interface: Any,\n    *implementations: Any,\n    scope: Scope = REQUEST,\n    cache: bool = True,\n    when: Activator | None = None,\n) -&gt; ProviderSpec\n</code></pre> <p>Register multiple implementations as a collection.</p> PARAMETER DESCRIPTION <code>interface</code> <p>Interface type for the collection.</p> <p> TYPE: <code>Any</code> </p> <code>*implementations</code> <p>Implementation types or factory functions to include in collection.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>scope</code> <p>Scope of the collection (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> <code>cache</code> <p>Whether to cache the resolve results within scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>when</code> <p>Optional predicate to conditionally activate the provider.</p> <p> TYPE: <code>Activator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProviderSpec</code> <p>Provider or ConditionalProvider if <code>when</code> is specified.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no implementations are provided.</p> <code>TypeError</code> <p>If a factory function lacks a return type annotation.</p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def many(\n    interface: Any,\n    *implementations: Any,\n    scope: Scope = Scope.REQUEST,\n    cache: bool = True,\n    when: Activator | None = None,\n) -&gt; ProviderSpec:\n    \"\"\"Register multiple implementations as a collection.\n\n    Args:\n        interface: Interface type for the collection.\n        *implementations: Implementation types or factory functions to include in collection.\n        scope: Scope of the collection (default: Scope.REQUEST).\n        cache: Whether to cache the resolve results within scope.\n        when: Optional predicate to conditionally activate the provider.\n\n    Returns:\n        Provider or ConditionalProvider if `when` is specified.\n\n    Raises:\n        ValueError: If no implementations are provided.\n        TypeError: If a factory function lacks a return type annotation.\n    \"\"\"\n    if not implementations:\n        msg = 'At least one implementation must be provided'\n        raise ValueError(msg)\n\n    provided_types = [_get_provided_type(impl) for impl in implementations]\n\n    provider_ = Provider(scope=scope)\n    provider_.provide_all(*implementations, cache=cache)\n\n    provider_.provide(\n        lambda: [],  # noqa: PIE807\n        provides=list[interface],\n        cache=cache,\n    )\n    provider_.alias(list[interface], provides=Sequence[interface], cache=cache)\n\n    for provided_type in provided_types:\n\n        @provider_.decorate\n        def _(many_: list[interface], one: provided_type) -&gt; list[interface]:  # type: ignore[valid-type]\n            return [*many_, one]\n\n    if when is None:\n        return provider_\n    return ConditionalProvider(provider=provider_, when=when, provided_type=Sequence[interface])\n</code></pre>"},{"location":"reference/#waku.di.object_","title":"object_","text":"<pre><code>object_(\n    obj: Any, *, provided_type: Any | None = None\n) -&gt; Provider\n</code></pre><pre><code>object_(\n    obj: Any,\n    *,\n    provided_type: Any | None = None,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre> <pre><code>object_(\n    obj: Any,\n    *,\n    provided_type: Any | None = None,\n    when: Activator | None = None,\n) -&gt; ProviderSpec\n</code></pre> <p>Provide the exact object passed at creation time as a singleton dependency.</p> <p>The provider always returns the same object instance, without instantiation or copying.</p> PARAMETER DESCRIPTION <code>obj</code> <p>The instance to provide as-is.</p> <p> TYPE: <code>Any</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any | None</code> DEFAULT: <code>None</code> </p> <code>when</code> <p>Optional predicate to conditionally activate the provider.</p> <p> TYPE: <code>Activator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProviderSpec</code> <p>Provider or ConditionalProvider if <code>when</code> is specified.</p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def object_(\n    obj: Any,\n    *,\n    provided_type: Any | None = None,\n    when: Activator | None = None,\n) -&gt; ProviderSpec:\n    \"\"\"Provide the exact object passed at creation time as a singleton dependency.\n\n    The provider always returns the same object instance, without instantiation or copying.\n\n    Args:\n        obj: The instance to provide as-is.\n        provided_type: Explicit type to provide (default: inferred).\n        when: Optional predicate to conditionally activate the provider.\n\n    Returns:\n        Provider or ConditionalProvider if `when` is specified.\n    \"\"\"\n    actual_type = provided_type if provided_type is not None else type(obj)\n    base = provider(lambda: obj, scope=Scope.APP, provided_type=actual_type, cache=True)\n\n    if when is None:\n        return base\n    return ConditionalProvider(provider=base, when=when, provided_type=actual_type)\n</code></pre>"},{"location":"reference/#waku.di.provider","title":"provider","text":"<pre><code>provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = REQUEST,\n    provided_type: Any | None = None,\n    cache: bool = True,\n) -&gt; Provider\n</code></pre> <p>Create a Dishka provider for a callable or type.</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>scope</code> <p>Scope of the dependency (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any | None</code> DEFAULT: <code>None</code> </p> <code>cache</code> <p>Whether to cache the instance in the scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Configured provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = Scope.REQUEST,\n    provided_type: Any | None = None,\n    cache: bool = True,\n) -&gt; Provider:\n    \"\"\"Create a Dishka provider for a callable or type.\n\n    Args:\n        source: Callable or type to provide as a dependency.\n        scope: Scope of the dependency (default: Scope.REQUEST).\n        provided_type: Explicit type to provide (default: inferred).\n        cache: Whether to cache the instance in the scope.\n\n    Returns:\n        Provider: Configured provider instance.\n    \"\"\"\n    provider_ = Provider(scope=scope)\n    provider_.provide(source, provides=provided_type, cache=cache)\n    return provider_\n</code></pre>"},{"location":"reference/#waku.di.scoped","title":"scoped","text":"<pre><code>scoped(source: type[_T] | Callable[..., _T]) -&gt; Provider\n</code></pre><pre><code>scoped(\n    source: type[_T] | Callable[..., _T],\n    /,\n    *,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre><pre><code>scoped(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n) -&gt; Provider\n</code></pre><pre><code>scoped(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n    /,\n    *,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre> <pre><code>scoped(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any]\n    | Callable[..., Any]\n    | None = None,\n    /,\n    *,\n    when: Activator | None = None,\n) -&gt; ProviderSpec\n</code></pre> <p>Create a scoped provider (lifetime: request).</p> PARAMETER DESCRIPTION <code>interface_or_source</code> <p>Interface type or source if no separate implementation.</p> <p> TYPE: <code>type[Any] | Callable[..., Any]</code> </p> <code>implementation</code> <p>Implementation type if interface is provided.</p> <p> TYPE: <code>type[Any] | Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> <code>when</code> <p>Optional predicate to conditionally activate the provider.</p> <p> TYPE: <code>Activator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProviderSpec</code> <p>Provider or ConditionalProvider if <code>when</code> is specified.</p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def scoped(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any] | Callable[..., Any] | None = None,\n    /,\n    *,\n    when: Activator | None = None,\n) -&gt; ProviderSpec:\n    \"\"\"Create a scoped provider (lifetime: request).\n\n    Args:\n        interface_or_source: Interface type or source if no separate implementation.\n        implementation: Implementation type if interface is provided.\n        when: Optional predicate to conditionally activate the provider.\n\n    Returns:\n        Provider or ConditionalProvider if `when` is specified.\n    \"\"\"\n    if implementation is not None:\n        provided_type = interface_or_source\n        base = provider(implementation, scope=Scope.REQUEST, provided_type=provided_type)\n    else:\n        provided_type = _get_provided_type(interface_or_source)\n        base = provider(interface_or_source, scope=Scope.REQUEST)\n\n    if when is None:\n        return base\n    return ConditionalProvider(provider=base, when=when, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.di.singleton","title":"singleton","text":"<pre><code>singleton(source: type[_T] | Callable[..., _T]) -&gt; Provider\n</code></pre><pre><code>singleton(\n    source: type[_T] | Callable[..., _T],\n    /,\n    *,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre><pre><code>singleton(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n) -&gt; Provider\n</code></pre><pre><code>singleton(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n    /,\n    *,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre> <pre><code>singleton(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any]\n    | Callable[..., Any]\n    | None = None,\n    /,\n    *,\n    when: Activator | None = None,\n) -&gt; ProviderSpec\n</code></pre> <p>Create a singleton provider (lifetime: app).</p> PARAMETER DESCRIPTION <code>interface_or_source</code> <p>Interface type or source if no separate implementation.</p> <p> TYPE: <code>type[Any] | Callable[..., Any]</code> </p> <code>implementation</code> <p>Implementation type if interface is provided.</p> <p> TYPE: <code>type[Any] | Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> <code>when</code> <p>Optional predicate to conditionally activate the provider.</p> <p> TYPE: <code>Activator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProviderSpec</code> <p>Provider or ConditionalProvider if <code>when</code> is specified.</p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def singleton(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any] | Callable[..., Any] | None = None,\n    /,\n    *,\n    when: Activator | None = None,\n) -&gt; ProviderSpec:\n    \"\"\"Create a singleton provider (lifetime: app).\n\n    Args:\n        interface_or_source: Interface type or source if no separate implementation.\n        implementation: Implementation type if interface is provided.\n        when: Optional predicate to conditionally activate the provider.\n\n    Returns:\n        Provider or ConditionalProvider if `when` is specified.\n    \"\"\"\n    if implementation is not None:\n        provided_type = interface_or_source\n        base = provider(implementation, scope=Scope.APP, provided_type=provided_type)\n    else:\n        provided_type = _get_provided_type(interface_or_source)\n        base = provider(interface_or_source, scope=Scope.APP)\n\n    if when is None:\n        return base\n    return ConditionalProvider(provider=base, when=when, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.di.transient","title":"transient","text":"<pre><code>transient(source: type[_T] | Callable[..., _T]) -&gt; Provider\n</code></pre><pre><code>transient(\n    source: type[_T] | Callable[..., _T],\n    /,\n    *,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre><pre><code>transient(\n    interface: Any,\n    implementation: type[_T\" backlink-type=\"used-by\" backlink-anchor=\"waku.di.transient\" optional hover&gt;_T] | Callable[..., _T],\n) -&gt; Provider\n</code></pre><pre><code>transient(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n    /,\n    *,\n    when: Activator,\n) -&gt; ConditionalProvider\n</code></pre> <pre><code>transient(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any]\n    | Callable[..., Any]\n    | None = None,\n    /,\n    *,\n    when: Activator | None = None,\n) -&gt; ProviderSpec\n</code></pre> <p>Create a transient provider (new instance per injection).</p> PARAMETER DESCRIPTION <code>interface_or_source</code> <p>Interface type or source if no separate implementation.</p> <p> TYPE: <code>type[Any] | Callable[..., Any]</code> </p> <code>implementation</code> <p>Implementation type if interface is provided.</p> <p> TYPE: <code>type[Any] | Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> <code>when</code> <p>Optional predicate to conditionally activate the provider.</p> <p> TYPE: <code>Activator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProviderSpec</code> <p>Provider or ConditionalProvider if <code>when</code> is specified.</p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def transient(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any] | Callable[..., Any] | None = None,\n    /,\n    *,\n    when: Activator | None = None,\n) -&gt; ProviderSpec:\n    \"\"\"Create a transient provider (new instance per injection).\n\n    Args:\n        interface_or_source: Interface type or source if no separate implementation.\n        implementation: Implementation type if interface is provided.\n        when: Optional predicate to conditionally activate the provider.\n\n    Returns:\n        Provider or ConditionalProvider if `when` is specified.\n    \"\"\"\n    if implementation is not None:\n        provided_type = interface_or_source\n        base = provider(implementation, scope=Scope.REQUEST, provided_type=provided_type, cache=False)\n    else:\n        provided_type = _get_provided_type(interface_or_source)\n        base = provider(interface_or_source, scope=Scope.REQUEST, cache=False)\n\n    if when is None:\n        return base\n    return ConditionalProvider(provider=base, when=when, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.exceptions.WakuError","title":"WakuError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/#waku.extensions","title":"extensions","text":""},{"location":"reference/#waku.extensions.ApplicationExtension","title":"ApplicationExtension  <code>module-attribute</code>","text":"<pre><code>ApplicationExtension: TypeAlias = (\n    OnApplicationInit\n    | AfterApplicationInit\n    | OnApplicationShutdown\n    | OnModuleRegistration\n)\n</code></pre>"},{"location":"reference/#waku.extensions.ModuleExtension","title":"ModuleExtension  <code>module-attribute</code>","text":"<pre><code>ModuleExtension: TypeAlias = (\n    OnModuleConfigure\n    | OnModuleInit\n    | OnModuleDestroy\n    | OnModuleRegistration\n)\n</code></pre>"},{"location":"reference/#waku.extensions.DEFAULT_EXTENSIONS","title":"DEFAULT_EXTENSIONS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EXTENSIONS: Sequence[ApplicationExtension] = (\n    ValidationExtension(\n        [DependenciesAccessibleRule()], strict=True\n    ),\n)\n</code></pre>"},{"location":"reference/#waku.extensions.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_init(self, app: WakuApplication) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnApplicationShutdown","title":"OnApplicationShutdown","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application shutdown actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationShutdown.on_app_shutdown","title":"on_app_shutdown  <code>async</code>","text":"<pre><code>on_app_shutdown(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_shutdown(self, app: WakuApplication) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleConfigure","title":"OnModuleConfigure","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module configuration.</p>"},{"location":"reference/#waku.extensions.OnModuleConfigure.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> <p>Perform actions before module metadata transformed to module.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    \"\"\"Perform actions before module metadata transformed to module.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleDestroy","title":"OnModuleDestroy","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module destroying.</p>"},{"location":"reference/#waku.extensions.OnModuleDestroy.on_module_destroy","title":"on_module_destroy  <code>async</code>","text":"<pre><code>on_module_destroy(module: Module) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_destroy(self, module: Module) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module: Module) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleRegistration","title":"OnModuleRegistration","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for contributing providers to module metadata during registration.</p> <p>This hook runs after all module metadata is collected but before Module objects are created. Use this for cross-module aggregation that produces providers which should belong to the owning module.</p> <p>Can be declared at both application level (passed to WakuFactory) and module level (in module's extensions list).</p> Execution order <ol> <li>Application-level extensions (assigned to root module)</li> <li>Module-level extensions (in topological order)</li> </ol> Key differences from OnModuleConfigure <ul> <li>Runs after ALL modules are collected (cross-module visibility)</li> <li>Receives registry with access to all modules' metadata</li> <li>Can add providers to owning module</li> </ul>"},{"location":"reference/#waku.extensions.OnModuleRegistration.on_module_registration","title":"on_module_registration","text":"<pre><code>on_module_registration(\n    registry: ModuleMetadataRegistry,\n    owning_module: ModuleType,\n    context: Mapping[Any, Any] | None,\n) -&gt; None\n</code></pre> <p>Contribute providers to module metadata before Module objects are created.</p> PARAMETER DESCRIPTION <code>registry</code> <p>Registry of all collected module metadata. Use find_extensions()       to discover extensions across modules, add_provider() to contribute.</p> <p> TYPE: <code>ModuleMetadataRegistry</code> </p> <code>owning_module</code> <p>The module type that owns this extension. Providers           added via registry.add_provider() should target this module.</p> <p> TYPE: <code>ModuleType</code> </p> <code>context</code> <p>Application context passed to WakuFactory (read-only).</p> <p> TYPE: <code>Mapping[Any, Any] | None</code> </p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>def on_module_registration(\n    self,\n    registry: ModuleMetadataRegistry,\n    owning_module: ModuleType,\n    context: Mapping[Any, Any] | None,\n) -&gt; None:\n    \"\"\"Contribute providers to module metadata before Module objects are created.\n\n    Args:\n        registry: Registry of all collected module metadata. Use find_extensions()\n                  to discover extensions across modules, add_provider() to contribute.\n        owning_module: The module type that owns this extension. Providers\n                      added via registry.add_provider() should target this module.\n        context: Application context passed to WakuFactory (read-only).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry","title":"ExtensionRegistry","text":"<pre><code>ExtensionRegistry()\n</code></pre> <p>Registry for extensions.</p> <p>This registry maintains references to all extensions in the application, allowing for centralized management and discovery.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._app_extensions: dict[type[ApplicationExtension], list[ApplicationExtension]] = defaultdict(list)\n    self._module_extensions: dict[ModuleType, list[ModuleExtension]] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.register_application_extension","title":"register_application_extension","text":"<pre><code>register_application_extension(\n    extension: ApplicationExtension,\n) -&gt; Self\n</code></pre> <p>Register an application extension with optional priority and tags.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_application_extension(self, extension: ApplicationExtension) -&gt; Self:\n    \"\"\"Register an application extension with optional priority and tags.\"\"\"\n    ext_type = type(extension)\n    extension_bases = [\n        base\n        for base in inspect.getmro(ext_type)\n        if (isinstance(base, ApplicationExtension) and base != ext_type)  # type: ignore[unreachable]\n    ]\n    for base in extension_bases:\n        self._app_extensions[cast('type[ApplicationExtension]', base)].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.register_module_extension","title":"register_module_extension","text":"<pre><code>register_module_extension(\n    module_type: ModuleType, extension: ModuleExtension\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_module_extension(self, module_type: ModuleType, extension: ModuleExtension) -&gt; Self:\n    self._module_extensions[module_type].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.get_application_extensions","title":"get_application_extensions","text":"<pre><code>get_application_extensions(\n    extension_type: type[_AppExtT],\n) -&gt; list[_AppExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_application_extensions(self, extension_type: type[_AppExtT]) -&gt; list[_AppExtT]:\n    return cast('list[_AppExtT]', self._app_extensions.get(cast('type[ApplicationExtension]', extension_type), []))\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.get_module_extensions","title":"get_module_extensions","text":"<pre><code>get_module_extensions(\n    module_type: ModuleType, extension_type: type[_ModExtT]\n) -&gt; list[_ModExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_module_extensions(self, module_type: ModuleType, extension_type: type[_ModExtT]) -&gt; list[_ModExtT]:\n    extensions = cast('list[_ModExtT]', self._module_extensions.get(module_type, []))\n    return [ext for ext in extensions if isinstance(ext, extension_type)]\n</code></pre>"},{"location":"reference/#waku.extensions.protocols","title":"protocols","text":"<p>Extension protocols for application and module lifecycle hooks.</p>"},{"location":"reference/#waku.extensions.protocols.ApplicationExtension","title":"ApplicationExtension  <code>module-attribute</code>","text":"<pre><code>ApplicationExtension: TypeAlias = (\n    OnApplicationInit\n    | AfterApplicationInit\n    | OnApplicationShutdown\n    | OnModuleRegistration\n)\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.ModuleExtension","title":"ModuleExtension  <code>module-attribute</code>","text":"<pre><code>ModuleExtension: TypeAlias = (\n    OnModuleConfigure\n    | OnModuleInit\n    | OnModuleDestroy\n    | OnModuleRegistration\n)\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.protocols.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_init(self, app: WakuApplication) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.protocols.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnApplicationShutdown","title":"OnApplicationShutdown","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application shutdown actions.</p>"},{"location":"reference/#waku.extensions.protocols.OnApplicationShutdown.on_app_shutdown","title":"on_app_shutdown  <code>async</code>","text":"<pre><code>on_app_shutdown(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_shutdown(self, app: WakuApplication) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnModuleRegistration","title":"OnModuleRegistration","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for contributing providers to module metadata during registration.</p> <p>This hook runs after all module metadata is collected but before Module objects are created. Use this for cross-module aggregation that produces providers which should belong to the owning module.</p> <p>Can be declared at both application level (passed to WakuFactory) and module level (in module's extensions list).</p> Execution order <ol> <li>Application-level extensions (assigned to root module)</li> <li>Module-level extensions (in topological order)</li> </ol> Key differences from OnModuleConfigure <ul> <li>Runs after ALL modules are collected (cross-module visibility)</li> <li>Receives registry with access to all modules' metadata</li> <li>Can add providers to owning module</li> </ul>"},{"location":"reference/#waku.extensions.protocols.OnModuleRegistration.on_module_registration","title":"on_module_registration","text":"<pre><code>on_module_registration(\n    registry: ModuleMetadataRegistry,\n    owning_module: ModuleType,\n    context: Mapping[Any, Any] | None,\n) -&gt; None\n</code></pre> <p>Contribute providers to module metadata before Module objects are created.</p> PARAMETER DESCRIPTION <code>registry</code> <p>Registry of all collected module metadata. Use find_extensions()       to discover extensions across modules, add_provider() to contribute.</p> <p> TYPE: <code>ModuleMetadataRegistry</code> </p> <code>owning_module</code> <p>The module type that owns this extension. Providers           added via registry.add_provider() should target this module.</p> <p> TYPE: <code>ModuleType</code> </p> <code>context</code> <p>Application context passed to WakuFactory (read-only).</p> <p> TYPE: <code>Mapping[Any, Any] | None</code> </p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>def on_module_registration(\n    self,\n    registry: ModuleMetadataRegistry,\n    owning_module: ModuleType,\n    context: Mapping[Any, Any] | None,\n) -&gt; None:\n    \"\"\"Contribute providers to module metadata before Module objects are created.\n\n    Args:\n        registry: Registry of all collected module metadata. Use find_extensions()\n                  to discover extensions across modules, add_provider() to contribute.\n        owning_module: The module type that owns this extension. Providers\n                      added via registry.add_provider() should target this module.\n        context: Application context passed to WakuFactory (read-only).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnModuleConfigure","title":"OnModuleConfigure","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module configuration.</p>"},{"location":"reference/#waku.extensions.protocols.OnModuleConfigure.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> <p>Perform actions before module metadata transformed to module.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    \"\"\"Perform actions before module metadata transformed to module.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.protocols.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module: Module) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnModuleDestroy","title":"OnModuleDestroy","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module destroying.</p>"},{"location":"reference/#waku.extensions.protocols.OnModuleDestroy.on_module_destroy","title":"on_module_destroy  <code>async</code>","text":"<pre><code>on_module_destroy(module: Module) -&gt; None\n</code></pre> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_destroy(self, module: Module) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.extensions.registry","title":"registry","text":"<p>Extension registry for centralized management of extensions.</p>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry","title":"ExtensionRegistry","text":"<pre><code>ExtensionRegistry()\n</code></pre> <p>Registry for extensions.</p> <p>This registry maintains references to all extensions in the application, allowing for centralized management and discovery.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._app_extensions: dict[type[ApplicationExtension], list[ApplicationExtension]] = defaultdict(list)\n    self._module_extensions: dict[ModuleType, list[ModuleExtension]] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.register_application_extension","title":"register_application_extension","text":"<pre><code>register_application_extension(\n    extension: ApplicationExtension,\n) -&gt; Self\n</code></pre> <p>Register an application extension with optional priority and tags.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_application_extension(self, extension: ApplicationExtension) -&gt; Self:\n    \"\"\"Register an application extension with optional priority and tags.\"\"\"\n    ext_type = type(extension)\n    extension_bases = [\n        base\n        for base in inspect.getmro(ext_type)\n        if (isinstance(base, ApplicationExtension) and base != ext_type)  # type: ignore[unreachable]\n    ]\n    for base in extension_bases:\n        self._app_extensions[cast('type[ApplicationExtension]', base)].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.register_module_extension","title":"register_module_extension","text":"<pre><code>register_module_extension(\n    module_type: ModuleType, extension: ModuleExtension\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_module_extension(self, module_type: ModuleType, extension: ModuleExtension) -&gt; Self:\n    self._module_extensions[module_type].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.get_application_extensions","title":"get_application_extensions","text":"<pre><code>get_application_extensions(\n    extension_type: type[_AppExtT],\n) -&gt; list[_AppExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_application_extensions(self, extension_type: type[_AppExtT]) -&gt; list[_AppExtT]:\n    return cast('list[_AppExtT]', self._app_extensions.get(cast('type[ApplicationExtension]', extension_type), []))\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.get_module_extensions","title":"get_module_extensions","text":"<pre><code>get_module_extensions(\n    module_type: ModuleType, extension_type: type[_ModExtT]\n) -&gt; list[_ModExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_module_extensions(self, module_type: ModuleType, extension_type: type[_ModExtT]) -&gt; list[_ModExtT]:\n    extensions = cast('list[_ModExtT]', self._module_extensions.get(module_type, []))\n    return [ext for ext in extensions if isinstance(ext, extension_type)]\n</code></pre>"},{"location":"reference/#waku.factory","title":"factory","text":""},{"location":"reference/#waku.factory.ContainerConfig","title":"ContainerConfig  <code>dataclass</code>","text":"<pre><code>ContainerConfig(\n    *,\n    lock_factory: _LockFactory = Lock,\n    start_scope: Scope | None = None,\n    skip_validation: bool = False,\n)\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.lock_factory","title":"lock_factory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lock_factory: _LockFactory = Lock\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.start_scope","title":"start_scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_scope: Scope | None = None\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.skip_validation","title":"skip_validation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>skip_validation: bool = False\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n    provider_filter: IProviderFilter | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n    provider_filter: IProviderFilter | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n    self._provider_filter = provider_filter\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(self) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(\n        self._root_module_type,\n        context=self._context,\n        provider_filter=self._provider_filter,\n        app_extensions=self._extensions,\n    ).build()\n\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extension_registry=self._build_extension_registry(registry.modules),\n    )\n</code></pre>"},{"location":"reference/#waku.lifespan","title":"lifespan","text":""},{"location":"reference/#waku.lifespan.LifespanFunc","title":"LifespanFunc  <code>module-attribute</code>","text":"<pre><code>LifespanFunc: TypeAlias = (\n    Callable[\n        ['WakuApplication'],\n        AbstractAsyncContextManager[None],\n    ]\n    | AbstractAsyncContextManager[None]\n)\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper","title":"LifespanWrapper","text":"<pre><code>LifespanWrapper(lifespan_func: LifespanFunc)\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>def __init__(self, lifespan_func: LifespanFunc) -&gt; None:\n    self._lifespan_func = lifespan_func\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app: WakuApplication) -&gt; AsyncIterator[None]\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: WakuApplication) -&gt; AsyncIterator[None]:\n    ctx_manager = (\n        self._lifespan_func\n        if isinstance(self._lifespan_func, AbstractAsyncContextManager)\n        else self._lifespan_func(app)\n    )\n    async with ctx_manager:\n        yield\n</code></pre>"},{"location":"reference/#waku.modules","title":"modules","text":""},{"location":"reference/#waku.modules.ModuleType","title":"ModuleType  <code>module-attribute</code>","text":"<pre><code>ModuleType: TypeAlias = type[object | HasModuleMetadata]\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[ProviderSpec] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.modules.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[ProviderSpec] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.modules.HasModuleMetadata","title":"HasModuleMetadata","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.modules.ModuleCompiler","title":"ModuleCompiler","text":""},{"location":"reference/#waku.modules.ModuleCompiler.extract_metadata","title":"extract_metadata","text":"<pre><code>extract_metadata(\n    module_type: ModuleType | DynamicModule,\n) -&gt; tuple[ModuleType, ModuleMetadata]\n</code></pre> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def extract_metadata(self, module_type: ModuleType | DynamicModule) -&gt; tuple[ModuleType, ModuleMetadata]:\n    try:\n        return self._extract_metadata(cast('Hashable', module_type))\n    except AttributeError:\n        msg = f'{type(module_type).__name__} is not module'\n        raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata","title":"ModuleMetadata  <code>dataclass</code>","text":"<pre><code>ModuleMetadata(\n    *,\n    providers: list[ProviderSpec] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[ProviderSpec] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadataRegistry","title":"ModuleMetadataRegistry","text":"<pre><code>ModuleMetadataRegistry(\n    metadata_by_type: dict[ModuleType, ModuleMetadata],\n    topological_order: tuple[ModuleType, ...],\n)\n</code></pre> <p>Registry providing access to collected module metadata.</p> <p>Provides read access to all modules' metadata for aggregation purposes, with controlled write access through explicit methods.</p> <p>This class is used during the module registration phase to enable cross-module aggregation of providers.</p> Source code in <code>src/waku/modules/_metadata_registry.py</code> <pre><code>def __init__(\n    self,\n    metadata_by_type: dict[ModuleType, ModuleMetadata],\n    topological_order: tuple[ModuleType, ...],\n) -&gt; None:\n    self._metadata_by_type = metadata_by_type\n    self._topological_order = topological_order\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadataRegistry.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: tuple[ModuleType, ...]\n</code></pre> <p>All module types in topological order (dependencies first).</p>"},{"location":"reference/#waku.modules.ModuleMetadataRegistry.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(module_type: ModuleType) -&gt; ModuleMetadata\n</code></pre> <p>Get metadata for a specific module.</p> Source code in <code>src/waku/modules/_metadata_registry.py</code> <pre><code>def get_metadata(self, module_type: ModuleType) -&gt; ModuleMetadata:\n    \"\"\"Get metadata for a specific module.\"\"\"\n    return self._metadata_by_type[module_type]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadataRegistry.find_extensions","title":"find_extensions","text":"<pre><code>find_extensions(\n    protocol: type[_ExtT],\n) -&gt; Iterator[tuple[ModuleType, _ExtT]]\n</code></pre> <p>Find all extensions of a given type across all modules.</p> <p>Yields (module_type, extension) pairs in topological order. This is useful for aggregating data from extensions across modules.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>The extension protocol/type to search for.</p> <p> TYPE: <code>type[_ExtT]</code> </p> YIELDS DESCRIPTION <code>tuple[ModuleType, _ExtT]</code> <p>Tuples of (module_type, extension) for each matching extension.</p> Source code in <code>src/waku/modules/_metadata_registry.py</code> <pre><code>def find_extensions(self, protocol: type[_ExtT]) -&gt; Iterator[tuple[ModuleType, _ExtT]]:\n    \"\"\"Find all extensions of a given type across all modules.\n\n    Yields (module_type, extension) pairs in topological order.\n    This is useful for aggregating data from extensions across modules.\n\n    Args:\n        protocol: The extension protocol/type to search for.\n\n    Yields:\n        Tuples of (module_type, extension) for each matching extension.\n    \"\"\"\n    for module_type in self._topological_order:\n        metadata = self._metadata_by_type[module_type]\n        for ext in metadata.extensions:\n            if isinstance(ext, protocol):\n                yield module_type, ext\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadataRegistry.add_provider","title":"add_provider","text":"<pre><code>add_provider(\n    module_type: ModuleType, provider: ProviderSpec\n) -&gt; None\n</code></pre> <p>Add a provider to a module's metadata.</p> <p>This is the preferred way to add providers during registration hooks. The provider will become part of the owning module.</p> PARAMETER DESCRIPTION <code>module_type</code> <p>The module to add the provider to.</p> <p> TYPE: <code>ModuleType</code> </p> <code>provider</code> <p>The provider specification to add.</p> <p> TYPE: <code>ProviderSpec</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If module_type is not in the registry.</p> Source code in <code>src/waku/modules/_metadata_registry.py</code> <pre><code>def add_provider(self, module_type: ModuleType, provider: ProviderSpec) -&gt; None:\n    \"\"\"Add a provider to a module's metadata.\n\n    This is the preferred way to add providers during registration hooks.\n    The provider will become part of the owning module.\n\n    Args:\n        module_type: The module to add the provider to.\n        provider: The provider specification to add.\n\n    Raises:\n        KeyError: If module_type is not in the registry.\n    \"\"\"\n    self._metadata_by_type[module_type].providers.append(provider)\n</code></pre>"},{"location":"reference/#waku.modules.Module","title":"Module","text":"<pre><code>Module(module_type: ModuleType, metadata: ModuleMetadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n\n    self.providers: Final[Sequence[ProviderSpec]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[type[object] | ModuleType | DynamicModule]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n\n    self._provider: BaseProvider | None = None\n</code></pre>"},{"location":"reference/#waku.modules.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Final[UUID] = id\n</code></pre>"},{"location":"reference/#waku.modules.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: Final[ModuleType] = module_type\n</code></pre>"},{"location":"reference/#waku.modules.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers: Final[Sequence[ProviderSpec]] = providers\n</code></pre>"},{"location":"reference/#waku.modules.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports: Final[Sequence[ModuleType | DynamicModule]] = (\n    imports\n)\n</code></pre>"},{"location":"reference/#waku.modules.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports: Final[\n    Sequence[type[object] | ModuleType | DynamicModule]\n] = exports\n</code></pre>"},{"location":"reference/#waku.modules.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Final[Sequence[ModuleExtension]] = extensions\n</code></pre>"},{"location":"reference/#waku.modules.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: Final[bool] = is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/#waku.modules.Module.provider","title":"provider  <code>property</code>","text":"<pre><code>provider: BaseProvider\n</code></pre> <p>Get the aggregated provider for this module.</p> <p>This property returns the provider created by create_provider(). Must be called after create_provider() has been invoked.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If create_provider() has not been called yet.</p>"},{"location":"reference/#waku.modules.Module.create_provider","title":"create_provider","text":"<pre><code>create_provider(\n    context: dict[Any, Any] | None,\n    builder: ActivationBuilder,\n    provider_filter: IProviderFilter,\n) -&gt; BaseProvider\n</code></pre> <p>Create aggregated provider with activation filtering applied.</p> PARAMETER DESCRIPTION <code>context</code> <p>Context dict for activation decisions.</p> <p> TYPE: <code>dict[Any, Any] | None</code> </p> <code>builder</code> <p>Activation builder for checking if types are registered.</p> <p> TYPE: <code>ActivationBuilder</code> </p> <code>provider_filter</code> <p>Filter strategy for conditional provider activation.</p> <p> TYPE: <code>IProviderFilter</code> </p> RETURNS DESCRIPTION <code>BaseProvider</code> <p>BaseProvider with only active providers aggregated.</p> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def create_provider(\n    self,\n    context: dict[Any, Any] | None,\n    builder: ActivationBuilder,\n    provider_filter: IProviderFilter,\n) -&gt; BaseProvider:\n    \"\"\"Create aggregated provider with activation filtering applied.\n\n    Args:\n        context: Context dict for activation decisions.\n        builder: Activation builder for checking if types are registered.\n        provider_filter: Filter strategy for conditional provider activation.\n\n    Returns:\n        BaseProvider with only active providers aggregated.\n    \"\"\"\n    active_providers = provider_filter.filter(\n        list(self.providers),\n        context=context,\n        module_type=self.target,\n        builder=builder,\n    )\n\n    cls = cast('type[_ModuleProvider]', type(f'{self.name}Provider', (_ModuleProvider,), {}))\n    self._provider = cls(active_providers)\n    return self._provider\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry","title":"ModuleRegistry","text":"<pre><code>ModuleRegistry(\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    adjacency: AdjacencyMatrix,\n)\n</code></pre> <p>Immutable registry and graph for module queries, traversal, and lookups.</p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def __init__(\n    self,\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    adjacency: AdjacencyMatrix,\n) -&gt; None:\n    self._compiler = compiler\n    self._root_module = root_module\n    self._modules = modules\n    self._providers = tuple(providers)\n    self._adjacency = adjacency\n    self._parent_to_module = self._build_parent_mapping(modules)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.root_module","title":"root_module  <code>property</code>","text":"<pre><code>root_module: Module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: tuple[Module, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.providers","title":"providers  <code>property</code>","text":"<pre><code>providers: tuple[BaseProvider, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.compiler","title":"compiler  <code>property</code>","text":"<pre><code>compiler: ModuleCompiler\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get","title":"get","text":"<pre><code>get(module_type: ModuleType | DynamicModule) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get(self, module_type: ModuleType | DynamicModule) -&gt; Module:\n    # For plain module classes, check if they're registered via parent mapping first.\n    # This handles the case where ConfigModule.register() was imported,\n    # but ConfigModule (the class) is being exported.\n    if isinstance(module_type, type) and module_type in self._parent_to_module:\n        return self._parent_to_module[module_type]\n\n    module_id = self.compiler.extract_metadata(module_type)[1].id\n    return self.get_by_id(module_id)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(module_id: UUID) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get_by_id(self, module_id: UUID) -&gt; Module:\n    module = self._modules.get(module_id)\n    if module is None:\n        msg = f'Module with ID {module_id} is not registered in the graph.'\n        raise KeyError(msg)\n    return module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.traverse","title":"traverse","text":"<pre><code>traverse(from_: Module | None = None) -&gt; Iterator[Module]\n</code></pre> <p>Traverse the module graph in depth-first post-order (children before parent) recursively.</p> PARAMETER DESCRIPTION <code>from_</code> <p>Start module (default: root)</p> <p> TYPE: <code>Module | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>Module</code> <p>Each traversed module (post-order)</p> <p> TYPE:: <code>Module</code> </p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def traverse(self, from_: Module | None = None) -&gt; Iterator[Module]:\n    \"\"\"Traverse the module graph in depth-first post-order (children before parent) recursively.\n\n    Args:\n        from_: Start module (default: root)\n\n    Yields:\n        Module: Each traversed module (post-order)\n    \"\"\"\n    start_module = from_ or self._root_module\n    visited: set[UUID] = set()\n\n    def _dfs(module: Module) -&gt; Iterator[Module]:\n        if module.id in visited:\n            return\n\n        visited.add(module.id)\n\n        # Process children first (maintain original order)\n        neighbor_ids = self._adjacency[module.id]\n        for neighbor_id in neighbor_ids:\n            if neighbor_id == module.id:\n                continue\n            neighbor = self.get_by_id(neighbor_id)\n            yield from _dfs(neighbor)\n\n        # Process current module after children (post-order)\n        yield module\n\n    yield from _dfs(start_module)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder","title":"ModuleRegistryBuilder","text":"<pre><code>ModuleRegistryBuilder(\n    root_module_type: ModuleType,\n    compiler: ModuleCompiler | None = None,\n    context: dict[Any, Any] | None = None,\n    provider_filter: IProviderFilter | None = None,\n    app_extensions: Sequence[ApplicationExtension] = (),\n)\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    compiler: ModuleCompiler | None = None,\n    context: dict[Any, Any] | None = None,\n    provider_filter: IProviderFilter | None = None,\n    app_extensions: Sequence[ApplicationExtension] = (),\n) -&gt; None:\n    self._compiler: Final = compiler or ModuleCompiler()\n    self._root_module_type: Final = root_module_type\n    self._context: Final = context\n    self._provider_filter: Final[IProviderFilter] = provider_filter or ProviderFilter()\n    self._app_extensions: Final = app_extensions\n    self._modules: dict[UUID, Module] = {}\n    self._providers: list[BaseProvider] = []\n\n    self._metadata_cache: dict[ModuleType | DynamicModule, tuple[ModuleType, ModuleMetadata]] = {}\n    self._builder: Final = _ActivationBuilder()\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder.build","title":"build","text":"<pre><code>build() -&gt; ModuleRegistry\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def build(self) -&gt; ModuleRegistry:\n    modules, adjacency = self._collect_modules()\n    self._execute_registration_hooks(modules)\n    self._build_type_registry(modules)\n    root_module = self._register_modules(modules)\n    return self._build_registry(root_module, adjacency)\n</code></pre>"},{"location":"reference/#waku.modules.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[ProviderSpec] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        type[object] | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[ProviderSpec]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[type[object] | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[ProviderSpec] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[type[object] | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.testing","title":"testing","text":""},{"location":"reference/#waku.testing.override","title":"override","text":"<pre><code>override(\n    container: AsyncContainer,\n    *providers: BaseProvider,\n    context: dict[Any, Any] | None = None,\n) -&gt; Iterator[None]\n</code></pre> <p>Temporarily override providers and/or context in an AsyncContainer for testing.</p> PARAMETER DESCRIPTION <code>container</code> <p>The container whose providers/context will be overridden.</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>*providers</code> <p>Providers to override in the container.</p> <p> TYPE: <code>BaseProvider</code> DEFAULT: <code>()</code> </p> <code>context</code> <p>Context values to override.</p> <p> TYPE: <code>dict[Any, Any] | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>None</code> <p>Context in which the container uses the overridden providers/context.</p> <p> TYPE:: <code>None</code> </p> Example <pre><code>from waku import WakuFactory, module\nfrom waku.di import Scope, singleton\nfrom waku.testing import override\n\n\nclass Service: ...\n\n\nclass ServiceOverride(Service): ...\n\n\n# Override providers\nwith override(application.container, singleton(ServiceOverride, provided_type=Service)):\n    service = await application.container.get(Service)\n    assert isinstance(service, ServiceOverride)\n\n# Override context\nwith override(application.container, context={int: 123}):\n    ...\n</code></pre> RAISES DESCRIPTION <code>ValueError</code> <p>If container is not at root (APP) scope.</p> Source code in <code>src/waku/testing.py</code> <pre><code>@contextmanager\ndef override(\n    container: AsyncContainer,\n    *providers: BaseProvider,\n    context: dict[Any, Any] | None = None,\n) -&gt; Iterator[None]:\n    \"\"\"Temporarily override providers and/or context in an AsyncContainer for testing.\n\n    Args:\n        container: The container whose providers/context will be overridden.\n        *providers: Providers to override in the container.\n        context: Context values to override.\n\n    Yields:\n        None: Context in which the container uses the overridden providers/context.\n\n    Example:\n        ```python\n        from waku import WakuFactory, module\n        from waku.di import Scope, singleton\n        from waku.testing import override\n\n\n        class Service: ...\n\n\n        class ServiceOverride(Service): ...\n\n\n        # Override providers\n        with override(application.container, singleton(ServiceOverride, provided_type=Service)):\n            service = await application.container.get(Service)\n            assert isinstance(service, ServiceOverride)\n\n        # Override context\n        with override(application.container, context={int: 123}):\n            ...\n        ```\n\n    Raises:\n        ValueError: If container is not at root (APP) scope.\n    \"\"\"\n    if container.scope != Scope.APP:\n        msg = (\n            f'override() only supports root (APP scope) containers, '\n            f'got {container.scope.name} scope. '\n            f'Use application.container instead of a scoped container.'\n        )\n        raise ValueError(msg)\n\n    _mark_as_overrides(providers)\n\n    original_context = cast('dict[Any, Any]', container._context)  # noqa: SLF001\n    merged_context = {**original_context, **(context or {})}\n    context_override_types = frozenset(context.keys()) if context else frozenset()\n\n    new_container = make_async_container(\n        _container_provider(container, context_override_types),\n        *providers,\n        context=merged_context,\n        start_scope=container.scope,\n        validation_settings=STRICT_VALIDATION,\n    )\n\n    # Only copy cache when no providers are overridden (context-only override)\n    # Provider overrides may have transitive effects, so rebuild everything\n    if not providers:\n        _copy_cache(container, new_container, context_override_types)\n\n    _swap(container, new_container)\n    yield\n    _swap(new_container, container)\n</code></pre>"},{"location":"reference/#waku.testing.create_test_app","title":"create_test_app  <code>async</code>","text":"<pre><code>create_test_app(\n    *,\n    base: ModuleType | DynamicModule | None = None,\n    providers: Sequence[ProviderSpec] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    app_extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    context: dict[Any, Any] | None = None,\n) -&gt; AsyncIterator[WakuApplication]\n</code></pre> <p>Create a minimal test application with given configuration.</p> <p>Useful for testing extensions and module configurations in isolation without needing to set up a full application structure.</p> PARAMETER DESCRIPTION <code>base</code> <p>Base module to build upon. When provided, the test module imports this module and providers act as overrides.</p> <p> TYPE: <code>ModuleType | DynamicModule | None</code> DEFAULT: <code>None</code> </p> <code>providers</code> <p>Providers to register in the test module. When <code>base</code> is provided, these override existing providers.</p> <p> TYPE: <code>Sequence[ProviderSpec]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Additional modules to import into the test module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Module extensions to register.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>app_extensions</code> <p>Application extensions to register (default: DEFAULT_EXTENSIONS).</p> <p> TYPE: <code>Sequence[ApplicationExtension]</code> DEFAULT: <code>DEFAULT_EXTENSIONS</code> </p> <code>context</code> <p>Context values to pass to the container.</p> <p> TYPE: <code>dict[Any, Any] | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[WakuApplication]</code> <p>Initialized WakuApplication.</p> Example <pre><code>from waku.testing import create_test_app\nfrom waku.di import singleton\n\n\nclass IRepository(Protocol):\n    async def get(self, id: str) -&gt; Entity: ...\n\n\nclass FakeRepository(IRepository):\n    async def get(self, id: str) -&gt; Entity:\n        return Entity(id=id)\n\n\n# Create test app from scratch\nasync def test_my_extension():\n    extension = MyExtension().bind(SomeEvent, SomeHandler)\n\n    async with create_test_app(\n        extensions=[extension],\n        providers=[singleton(IRepository, FakeRepository)],\n    ) as app:\n        service = await app.container.get(MyService)\n        result = await service.do_something()\n        assert result == expected\n\n\n# Create test app based on existing module with overrides\nasync def test_with_base_module():\n    async with create_test_app(\n        base=AppModule,\n        providers=[singleton(IRepository, FakeRepository)],\n    ) as app:\n        # FakeRepository replaces the real one from AppModule\n        repo = await app.container.get(IRepository)\n        assert isinstance(repo, FakeRepository)\n</code></pre> Source code in <code>src/waku/testing.py</code> <pre><code>@asynccontextmanager\nasync def create_test_app(\n    *,\n    base: ModuleType | DynamicModule | None = None,\n    providers: Sequence[ProviderSpec] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    app_extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    context: dict[Any, Any] | None = None,\n) -&gt; AsyncIterator[WakuApplication]:\n    \"\"\"Create a minimal test application with given configuration.\n\n    Useful for testing extensions and module configurations in isolation\n    without needing to set up a full application structure.\n\n    Args:\n        base: Base module to build upon. When provided, the test module\n            imports this module and providers act as overrides.\n        providers: Providers to register in the test module.\n            When `base` is provided, these override existing providers.\n        imports: Additional modules to import into the test module.\n        extensions: Module extensions to register.\n        app_extensions: Application extensions to register (default: DEFAULT_EXTENSIONS).\n        context: Context values to pass to the container.\n\n    Yields:\n        Initialized WakuApplication.\n\n    Example:\n        ```python\n        from waku.testing import create_test_app\n        from waku.di import singleton\n\n\n        class IRepository(Protocol):\n            async def get(self, id: str) -&gt; Entity: ...\n\n\n        class FakeRepository(IRepository):\n            async def get(self, id: str) -&gt; Entity:\n                return Entity(id=id)\n\n\n        # Create test app from scratch\n        async def test_my_extension():\n            extension = MyExtension().bind(SomeEvent, SomeHandler)\n\n            async with create_test_app(\n                extensions=[extension],\n                providers=[singleton(IRepository, FakeRepository)],\n            ) as app:\n                service = await app.container.get(MyService)\n                result = await service.do_something()\n                assert result == expected\n\n\n        # Create test app based on existing module with overrides\n        async def test_with_base_module():\n            async with create_test_app(\n                base=AppModule,\n                providers=[singleton(IRepository, FakeRepository)],\n            ) as app:\n                # FakeRepository replaces the real one from AppModule\n                repo = await app.container.get(IRepository)\n                assert isinstance(repo, FakeRepository)\n        ```\n    \"\"\"\n    all_imports = list(imports)\n    if base is not None:\n        all_imports.insert(0, base)\n\n    override_providers = list(providers)\n    if base is not None:\n        _mark_as_overrides(override_providers)\n\n    @module(\n        providers=override_providers,\n        imports=all_imports,\n        extensions=list(extensions),\n    )\n    class _TestModule:\n        pass\n\n    app = WakuFactory(_TestModule, context=context, extensions=app_extensions).create()\n    async with app:\n        yield app\n</code></pre>"},{"location":"reference/#waku.validation","title":"validation","text":""},{"location":"reference/#waku.validation.ValidationRule","title":"ValidationRule","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.validation.ValidationRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/validation/_abc.py</code> <pre><code>def validate(self, context: ValidationContext) -&gt; list[ValidationError]: ...\n</code></pre>"},{"location":"reference/#waku.validation.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>WakuError</code></p>"},{"location":"reference/#waku.validation.ValidationExtension","title":"ValidationExtension","text":"<pre><code>ValidationExtension(\n    rules: Sequence[ValidationRule], *, strict: bool = True\n)\n</code></pre> <p>               Bases: <code>AfterApplicationInit</code></p> Source code in <code>src/waku/validation/_extension.py</code> <pre><code>def __init__(self, rules: Sequence[ValidationRule], *, strict: bool = True) -&gt; None:\n    self.rules = rules\n    self.strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.validation.ValidationExtension.rules","title":"rules  <code>instance-attribute</code>","text":"<pre><code>rules = rules\n</code></pre>"},{"location":"reference/#waku.validation.ValidationExtension.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.validation.ValidationExtension.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/validation/_extension.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    context = ValidationContext(app=app)\n\n    errors_chain = chain.from_iterable(rule.validate(context) for rule in self.rules)\n    if errors := list(errors_chain):\n        self._raise(errors)\n</code></pre>"},{"location":"reference/#waku.validation.rules","title":"rules","text":""},{"location":"reference/#waku.validation.rules.DependenciesAccessibleRule","title":"DependenciesAccessibleRule","text":"<pre><code>DependenciesAccessibleRule(cache_size: int = 1000)\n</code></pre> <p>               Bases: <code>ValidationRule</code></p> <p>Validates that all dependencies required by providers are accessible.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, cache_size: int = 1000) -&gt; None:\n    self._cache = LRUCache[set[type[object]]](cache_size)\n    self._types_extractor = ModuleTypesExtractor(self._cache)\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependenciesAccessibleRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    self._cache.clear()\n\n    registry = context.app.registry\n    modules = list(registry.modules)\n    container = context.app.container\n\n    strategies: list[AccessibilityStrategy] = [\n        GlobalProvidersStrategy(modules, container, self._types_extractor, registry),\n        LocalProvidersStrategy(self._types_extractor),\n        ContextVarsStrategy(self._types_extractor),\n        ImportedModulesStrategy(registry, self._types_extractor),\n    ]\n\n    checker = DependencyAccessChecker(strategies)\n    errors: list[ValidationError] = []\n\n    for module in modules:\n        for factory in module.provider.factories:\n            inaccessible_deps = checker.find_inaccessible_dependencies(\n                dependencies=factory.dependencies,\n                module=module,\n            )\n            errors.extend(\n                DependencyInaccessibleError(\n                    required_type=dep_type,\n                    required_by=factory.source,\n                    from_module=module,\n                )\n                for dep_type in inaccessible_deps\n            )\n\n    return errors\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError","title":"DependencyInaccessibleError","text":"<pre><code>DependencyInaccessibleError(\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n)\n</code></pre> <p>               Bases: <code>ValidationError</code></p> <p>Error indicating a dependency is not accessible to a provider/module.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n) -&gt; None:\n    self.required_type = required_type\n    self.required_by = required_by\n    self.from_module = from_module\n    super().__init__(str(self))\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError.required_type","title":"required_type  <code>instance-attribute</code>","text":"<pre><code>required_type = required_type\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError.required_by","title":"required_by  <code>instance-attribute</code>","text":"<pre><code>required_by = required_by\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError.from_module","title":"from_module  <code>instance-attribute</code>","text":"<pre><code>from_module = from_module\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible","title":"dependency_accessible","text":""},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError","title":"DependencyInaccessibleError","text":"<pre><code>DependencyInaccessibleError(\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n)\n</code></pre> <p>               Bases: <code>ValidationError</code></p> <p>Error indicating a dependency is not accessible to a provider/module.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n) -&gt; None:\n    self.required_type = required_type\n    self.required_by = required_by\n    self.from_module = from_module\n    super().__init__(str(self))\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError.required_type","title":"required_type  <code>instance-attribute</code>","text":"<pre><code>required_type = required_type\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError.required_by","title":"required_by  <code>instance-attribute</code>","text":"<pre><code>required_by = required_by\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError.from_module","title":"from_module  <code>instance-attribute</code>","text":"<pre><code>from_module = from_module\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.AccessibilityStrategy","title":"AccessibilityStrategy","text":"<p>               Bases: <code>ABC</code></p> <p>Strategy for checking if a type is accessible to a module.</p>"},{"location":"reference/#waku.validation.rules.dependency_accessible.AccessibilityStrategy.is_accessible","title":"is_accessible  <code>abstractmethod</code>","text":"<pre><code>is_accessible(\n    required_type: type[object], module: Module\n) -&gt; bool\n</code></pre> <p>Check if the required type is accessible to the given module.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@abstractmethod\ndef is_accessible(self, required_type: type[object], module: Module) -&gt; bool:\n    \"\"\"Check if the required type is accessible to the given module.\"\"\"\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.GlobalProvidersStrategy","title":"GlobalProvidersStrategy","text":"<pre><code>GlobalProvidersStrategy(\n    modules: Sequence[Module],\n    container: AsyncContainer,\n    types_extractor: ModuleTypesExtractor,\n    registry: ModuleRegistry,\n)\n</code></pre> <p>               Bases: <code>AccessibilityStrategy</code></p> <p>Check if type is provided by a global module or APP-scoped context.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    modules: Sequence[Module],\n    container: AsyncContainer,\n    types_extractor: ModuleTypesExtractor,\n    registry: ModuleRegistry,\n) -&gt; None:\n    self._global_types = self._build_global_types(modules, container, types_extractor, registry)\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.GlobalProvidersStrategy.is_accessible","title":"is_accessible","text":"<pre><code>is_accessible(\n    required_type: type[object], module: Module\n) -&gt; bool\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef is_accessible(self, required_type: type[object], module: Module) -&gt; bool:\n    return required_type in self._global_types\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.LocalProvidersStrategy","title":"LocalProvidersStrategy","text":"<pre><code>LocalProvidersStrategy(\n    types_extractor: ModuleTypesExtractor,\n)\n</code></pre> <p>               Bases: <code>AccessibilityStrategy</code></p> <p>Check if type is provided by the module itself.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, types_extractor: ModuleTypesExtractor) -&gt; None:\n    self._types_extractor = types_extractor\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.LocalProvidersStrategy.is_accessible","title":"is_accessible","text":"<pre><code>is_accessible(\n    required_type: type[object], module: Module\n) -&gt; bool\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef is_accessible(self, required_type: type[object], module: Module) -&gt; bool:\n    return required_type in self._types_extractor.get_provided_types(module)\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.ContextVarsStrategy","title":"ContextVarsStrategy","text":"<pre><code>ContextVarsStrategy(types_extractor: ModuleTypesExtractor)\n</code></pre> <p>               Bases: <code>AccessibilityStrategy</code></p> <p>Check if type is provided by application or request container context.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, types_extractor: ModuleTypesExtractor) -&gt; None:\n    self._types_extractor = types_extractor\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.ContextVarsStrategy.is_accessible","title":"is_accessible","text":"<pre><code>is_accessible(\n    required_type: type[object], module: Module\n) -&gt; bool\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef is_accessible(self, required_type: type[object], module: Module) -&gt; bool:\n    return required_type in self._types_extractor.get_context_vars(module)\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.ImportedModulesStrategy","title":"ImportedModulesStrategy","text":"<pre><code>ImportedModulesStrategy(\n    registry: ModuleRegistry,\n    types_extractor: ModuleTypesExtractor,\n)\n</code></pre> <p>               Bases: <code>AccessibilityStrategy</code></p> <p>Check if type is accessible via imported modules (direct export or re-export).</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, registry: ModuleRegistry, types_extractor: ModuleTypesExtractor) -&gt; None:\n    self._registry = registry\n    self._types_extractor = types_extractor\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.ImportedModulesStrategy.is_accessible","title":"is_accessible","text":"<pre><code>is_accessible(\n    required_type: type[object], module: Module\n) -&gt; bool\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef is_accessible(self, required_type: type[object], module: Module) -&gt; bool:\n    for imported in module.imports:\n        imported_module = self._registry.get(imported)\n        if self._is_directly_exported(required_type, imported_module):\n            return True\n        if self._is_reexported(required_type, imported_module):\n            return True\n    return False\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyAccessChecker","title":"DependencyAccessChecker","text":"<pre><code>DependencyAccessChecker(\n    strategies: Sequence[AccessibilityStrategy],\n)\n</code></pre> <p>Handles dependency accessibility checks between modules.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, strategies: Sequence[AccessibilityStrategy]) -&gt; None:\n    self._strategies = strategies\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyAccessChecker.find_inaccessible_dependencies","title":"find_inaccessible_dependencies","text":"<pre><code>find_inaccessible_dependencies(\n    dependencies: Sequence[DependencyKey], module: Module\n) -&gt; Iterable[type[object]]\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def find_inaccessible_dependencies(\n    self,\n    dependencies: Sequence[DependencyKey],\n    module: Module,\n) -&gt; Iterable[type[object]]:\n    for dependency in dependencies:\n        if not self._is_accessible(dependency.type_hint, module):\n            yield dependency.type_hint\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependenciesAccessibleRule","title":"DependenciesAccessibleRule","text":"<pre><code>DependenciesAccessibleRule(cache_size: int = 1000)\n</code></pre> <p>               Bases: <code>ValidationRule</code></p> <p>Validates that all dependencies required by providers are accessible.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, cache_size: int = 1000) -&gt; None:\n    self._cache = LRUCache[set[type[object]]](cache_size)\n    self._types_extractor = ModuleTypesExtractor(self._cache)\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependenciesAccessibleRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    self._cache.clear()\n\n    registry = context.app.registry\n    modules = list(registry.modules)\n    container = context.app.container\n\n    strategies: list[AccessibilityStrategy] = [\n        GlobalProvidersStrategy(modules, container, self._types_extractor, registry),\n        LocalProvidersStrategy(self._types_extractor),\n        ContextVarsStrategy(self._types_extractor),\n        ImportedModulesStrategy(registry, self._types_extractor),\n    ]\n\n    checker = DependencyAccessChecker(strategies)\n    errors: list[ValidationError] = []\n\n    for module in modules:\n        for factory in module.provider.factories:\n            inaccessible_deps = checker.find_inaccessible_dependencies(\n                dependencies=factory.dependencies,\n                module=module,\n            )\n            errors.extend(\n                DependencyInaccessibleError(\n                    required_type=dep_type,\n                    required_by=factory.source,\n                    from_module=module,\n                )\n                for dep_type in inaccessible_deps\n            )\n\n    return errors\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering a contribution to <code>waku</code>! \ud83c\udf89</p> <p>This guide will help you get started and ensure a smooth process.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher</li> <li>uv \u2013 a modern Python package manager</li> <li>Task \u2013 a task runner for automating development workflows (we recommend setting up auto-completion for Task)</li> <li>Git</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Install UV (if not already installed):</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# For other platforms, see:\n# https://docs.astral.sh/uv/getting-started/installation/\n\n# If uv is already installed, ensure it's up to date:\nuv self update\n</code></pre> </li> <li> <p>Install Task (if not already installed):</p> <pre><code># Using the install script\nsh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin\n\n# For other installation options, see:\n# https://taskfile.dev/installation/\n</code></pre> </li> <li> <p>Set up the development environment:</p> <pre><code># Install dependencies and configure pre-commit hooks\ntask deps:install\n</code></pre> <p>Tip: Run <code>task -l</code> after setup to verify everything is working and to see available commands.</p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Fork the repository to your own GitHub account.</li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Create a new branch for your changes:</p> <pre><code>git checkout -b feat/your-feature-name\n</code></pre> </li> <li> <p>Make your changes, following our code style guidelines.</p> </li> <li>Write or update tests for your changes.</li> <li> <p>Run all checks and ensure tests pass:</p> <pre><code>task\n</code></pre> </li> <li> <p>Commit your changes with clear, descriptive messages.</p> </li> <li> <p>Push to your fork:</p> <pre><code>git push origin feat/your-feature-name\n</code></pre> </li> <li> <p>Open a pull request on GitHub. Link related issues in your PR description (e.g., \"Fixes #123\").</p> </li> <li>Participate in the review process and make any requested changes.</li> </ol>"},{"location":"contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li> Tests added or updated</li> <li> Documentation updated (if needed)</li> <li> Code is formatted and linted</li> <li> All checks pass</li> <li> Type hints added or refined</li> <li> Commit messages include a detailed description for the changelog</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Ensure your changes are thoroughly tested by running the following commands:</p> <pre><code># Run all checks (recommended)\ntask\n\n# Run linters and type checkers\ntask check\n\n# Run specific checks\ntask test         # Run tests only\ntask test:cov     # Run tests with coverage\ntask lint         # Run linters only\ntask format       # Format code\ntask typecheck    # Run type checkers only\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Ruff for linting and formatting</li> <li>MyPy and basedpyright for type checking</li> <li>pre-commit for running checks before commits and pushes</li> </ul> <p>Key style guidelines:</p> <ul> <li>Maximum line length: 120 characters</li> <li>Use explicit type annotations throughout the codebase</li> <li>Follow PEP 8 conventions</li> <li>Write descriptive docstrings using the Google style</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you have questions or need help, you can:</p> <ul> <li>Open a discussion</li> <li>Open an issue for bugs or feature requests</li> </ul>"},{"location":"contributing/#first-time-contributors","title":"First-time Contributors","text":"<ul> <li>Look for issues labeled \"good first issue\" or \"help wanted\".</li> <li>Comment on the issue to let others know you're working on it.</li> <li>Don't hesitate to ask questions if anything is unclear.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Before creating an issue:</p> <ul> <li>Search existing issues to avoid duplicates.</li> <li>Use the appropriate issue template for bug reports or feature requests.</li> <li>Provide as much context as possible (e.g., steps to reproduce, environment details).</li> </ul> <p>Please follow the bug report and feature request templates when submitting issues.</p> <p>We welcome:</p> <ul> <li>Bug reports</li> <li>Feature requests</li> <li>Documentation improvements</li> <li>General questions or ideas</li> </ul>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<ul> <li><code>src/</code> \u2013 main source code</li> <li><code>tests/</code> \u2013 test suite</li> <li><code>docs/</code> \u2013 documentation</li> <li><code>Taskfile.yml</code> \u2013 development automation</li> <li><code>README.md</code> \u2013 project overview</li> </ul>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<ul> <li>Use clear, descriptive commit messages.</li> <li>Example: <code>fix(core): handle edge case in dependency resolution</code></li> </ul> <p>Thank you for contributing to <code>waku</code>! \ud83d\ude4f</p>"},{"location":"contributing/docs/","title":"Documentation","text":""},{"location":"contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub or by opening an issue.</p>"},{"location":"contributing/docs/#how-to-get-started","title":"How to get started","text":"<ol> <li>Follow the steps for development setup in the contributing guide</li> <li> <p>Start the local documentation server for live preview of changes</p> <pre><code>mkdocs serve\n</code></pre> </li> <li> <p>Go to the <code>docs/</code> directory and make your changes</p> </li> </ol> <p>After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"examples/cqrs/","title":"Mediator (CQRS)","text":"<p>Based on the CQRS pattern, the mediator is used to decouple the command and query logic from the domain model.</p> <p>Implementation heavily inspired by C# MediatR library.</p> <p>For full documentation, visit the Mediator (CQRS) section.</p>"},{"location":"examples/cqrs/#code","title":"Code","text":""},{"location":"examples/modularity/","title":"Modularity","text":"<p>Example of how to use modules, dynamic modules and linking them together to build an application.</p> <p>For full documentation on modules, visit the Modules section.</p>"},{"location":"examples/modularity/#code","title":"Code","text":""},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/asgi/","title":"ASGI Integration","text":"<p><code>waku</code> can be seamlessly integrated into any ASGI application. To achieve this, set up <code>waku</code> as you normally would, then add the <code>ApplicationMiddleware</code> to your ASGI application\u2019s middleware stack.</p>"},{"location":"integrations/asgi/#example-with-fastapi","title":"Example with FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.middleware import Middleware\nfrom waku import WakuApplication\nfrom waku.contrib.asgi import WakuMiddleware\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the FastAPI app with the waku middleware\napp = FastAPI(\n    middleware=[\n        Middleware(WakuMiddleware, application=application),\n    ],\n)\n</code></pre> <p>In this example, the <code>ApplicationMiddleware</code> bridges <code>waku</code> with FastAPI, allowing dependency injection and module management within your ASGI routes.</p>"},{"location":"integrations/litestar/","title":"Litestar Integration","text":"<p><code>waku</code> can be seamlessly integrated with Litestar using the <code>ApplicationPlugin</code>. To do this, set up <code>waku</code> as usual and then include the plugin in your Litestar application configuration.</p>"},{"location":"integrations/litestar/#example","title":"Example","text":"<p>Here\u2019s how to integrate <code>waku</code> with a Litestar application:</p> <pre><code>from litestar import Litestar\nfrom waku import WakuApplication\nfrom waku.contrib.litestar import WakuPlugin\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the Litestar app with the waku plugin\napp = Litestar(plugins=[WakuPlugin(application)])\n</code></pre> <p>In this example, the <code>ApplicationPlugin</code> enables <code>waku</code> dependency injection and module system within your Litestar application.</p>"},{"location":"usage/lifespan/","title":"Lifespan","text":""},{"location":"usage/modules/","title":"Modules","text":"<p><code>waku</code> modularity system is heavily inspired by the NestJS and Tramvai frameworks.</p> <p>The concept of modularity is well-explained with examples in the NestJS documentation.</p>"},{"location":"usage/modules/#module","title":"Module","text":"<p>A module is a class annotated with the <code>@module()</code> decorator. This decorator attaches metadata to the class, which <code>waku</code> uses to construct the application graph.</p> <p>Every <code>waku</code> application has at least one module: the root module, also known as the composition root. This module serves as the starting point for <code>waku</code> to build the entire application graph.</p> Parameter Description <code>providers</code> List of providers for dependency injection <code>imports</code> List of modules imported by this module <code>exports</code> List of types or modules exported by this module <code>extensions</code> List of module extensions for lifecycle hooks <code>is_global</code> Whether this module is global or not <p>The module encapsulates providers by default, meaning you can only inject providers that are either part of the current module or explicitly exported from other imported modules. The exported providers from a module essentially serve as the module's public interface or API.</p> <pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.config.module import ConfigModule\n\n\nclass UsersService:\n    pass\n\n\n@module(\n    providers=[Scoped(UsersService)],  # Register the service with a scoped lifetime\n    imports=[ConfigModule],  # Import another module\n    exports=[UsersService],  # Expose the service to other modules\n)\nclass UsersModule:\n    pass\n\n\n@module(imports=[UsersModule])  # Root module importing UsersModule\nclass AppModule:\n    pass\n</code></pre> <p>Note</p> <p>Encapsulation is enforced by validators, which you can disable at runtime if needed. However, disabling them entirely is not recommended, as they help maintain modularity.</p>"},{"location":"usage/modules/#module-re-exporting","title":"Module Re-exporting","text":"<p>You can re-export a module by including it in the <code>exports</code> list of another module. This is useful for exposing a module\u2019s providers to other modules that import the re-exporting module.</p> <pre><code>@module(\n    imports=[UsersModule],\n    exports=[UsersModule],\n)\nclass IAMModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#global-modules","title":"Global modules","text":"<p>If you need to import the same set of modules across your application, you can mark a module as global. Once a module is global, its providers can be injected anywhere in the application without requiring explicit imports in every module.</p> <p>To make a module global, set the <code>is_global</code> param to <code>True</code> in the <code>@module()</code> decorator.</p> <p>Note</p> <p>Root module are always global.</p> <p>Warning</p> <p>Global modules are not recommended for large applications, as they can lead to tight coupling and make the application harder to maintain.</p> <pre><code>from waku import module\n\n\n@module(is_global=True)\nclass UsersModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#dynamic-module","title":"Dynamic Module","text":"<p>Dynamic modules allow you to create modules dynamically based on conditions, such as the runtime environment of your application.</p> <pre><code>from waku import DynamicModule, module\nfrom waku.di import Scoped\n\n\nclass ConfigService:\n    pass\n\n\nclass DevConfigService(ConfigService):\n    pass\n\n\nclass DefaultConfigService(ConfigService):\n    pass\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # Choose the config provider based on the environment\n        config_provider = DevConfigService if env == 'dev' else DefaultConfigService\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Scoped(config_provider, type_=ConfigService)],  # Register with interface type\n        )\n</code></pre> <p>And then you can use it in any of your modules or in the root module:</p> <pre><code>from waku import module\n\nfrom app.modules.config.module import ConfigModule\n\n\n@module(\n    imports=[\n        ConfigModule.register(env='dev'),\n    ],\n)\nclass AppModule:\n    pass\n</code></pre> <p>You can also make a dynamic module global by setting <code>is_global=True</code> in the <code>DynamicModule</code> constructor.</p> <p>Note</p> <p>While you can use any method name instead of <code>register</code>, we recommend sticking with <code>register</code> for consistency.</p>"},{"location":"usage/providers/","title":"Providers","text":""},{"location":"usage/providers/#introduction","title":"Introduction","text":"<p>Providers are the core of <code>waku</code> dependency injection system. The idea behind a provider is that it can be injected as a dependency into other provider constructors, allowing objects to form various relationships with each other.</p> <p><code>waku</code> responsibility is to \"wire up\" all the providers using the DI framework and manage their lifecycle. This way you can focus on writing your application logic.</p>"},{"location":"usage/providers/#dependency-injection","title":"Dependency Injection","text":"<p><code>waku</code> is designed to be modular and extensible. To support this principle, it provides a flexible dependency injection (DI) system that integrates seamlessly with various DI frameworks. <code>waku</code> itself acts as an IoC container, allowing you to register and resolve dependencies using the modules system.</p> <p>Note</p> <p><code>waku</code> uses the Dishka IoC container under the hood. All provider lifecycles and dependency resolution are handled by Dishka.</p>"},{"location":"usage/providers/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that addresses the issue of tightly coupled code by decoupling the creation and management of dependencies from the classes that rely on them. In traditional approaches, classes directly instantiate their dependencies, resulting in rigid, hard-to-maintain code. DI solves this problem by enabling dependencies to be supplied externally, typically through mechanisms like constructor or setter injection.</p> <p>By shifting the responsibility of dependency management outside the class, DI promotes loose coupling, allowing classes to focus on their core functionality rather than how dependencies are created. This separation enhances maintainability, testability, and flexibility, as dependencies can be easily swapped or modified without altering the class's code. Ultimately, DI improves system design by reducing interdependencies and making code more modular and scalable.</p> Manual DI Example <pre><code>from abc import ABC, abstractmethod\n\n\n# Use an interface to define contract for clients\n# This allows us injecting different implementations\nclass IClient(ABC):\n    @abstractmethod\n    def request(self, url: str) -&gt; str:\n        pass\n\n\n# Regular implementation\nclass RealClient(IClient):\n    def request(self, url: str) -&gt; str:\n        # Some HTTP requesting logic\n        return f'\"{url}\" call result'\n\n\n# Implementation for tests\nclass MockClient(IClient):\n    def __init__(self, return_data: str) -&gt; None:\n        self._return_data = return_data\n\n    def request(self, url: str) -&gt; str:\n        # Mocked behavior for testing\n        return f'{self._return_data} from \"{url}\"'\n\n\nclass Service:\n    # Accepts any IClient implementation\n    def __init__(self, client: IClient) -&gt; None:\n        self._client = client\n\n    def do_something(self) -&gt; str:\n        return self._client.request('https://example.com')\n\n\n# Usage in regular code\nreal_client = RealClient()\nservice = Service(real_client)\nprint(service.do_something())  # Output: \"https://example.com\" call result\n\n# Usage in tests\nmocked_client = MockClient('mocked data')\nservice = Service(mocked_client)\nprint(service.do_something())  # Output: mocked data from \"https://example.com\"\n</code></pre> <p>Here, a <code>MockClient</code> is injected into <code>Service</code>, making it easy to test <code>Service</code> in isolation without relying on a real client implementation.</p>"},{"location":"usage/providers/#what-is-ioc-container","title":"What is IoC-container?","text":"<p>An IoC container is a framework that automates object creation and dependency management based on the Inversion of Control (IoC) principle. It centralizes the configuration and instantiation of components, reducing tight coupling and simplifying code maintenance. By handling dependency resolution, an IoC container promotes modular, testable, and scalable application design.</p> <p>With the power of an IoC container, you can leverage all the benefits of DI without manually managing dependencies.</p>"},{"location":"usage/providers/#providers_1","title":"Providers","text":"<p><code>Provider</code> is an object that holds dependency metadata, such as its type, lifetime scope and factory.</p> <p>In <code>waku</code>, there are five types of providers, one for each scope:</p> <ul> <li><code>Transient</code></li> <li><code>Scoped</code></li> <li><code>Singleton</code></li> <li><code>Object</code></li> <li><code>Contextual</code></li> </ul> <p>Each provider (except <code>Contextual</code>) takes two arguments:</p> <ul> <li><code>source</code>: type or callable that returns or yields an instance of the dependency.</li> <li><code>provided_type</code>: type of the dependency. If not provided, it will be inferred from the factory function's return type.</li> </ul>"},{"location":"usage/providers/#scopes","title":"Scopes","text":"<p><code>waku</code> supports four different lifetime scopes for providers, inspired by the service lifetimes from .NET Core's DI system.</p>"},{"location":"usage/providers/#transient","title":"Transient","text":"<p>Dependencies defined with the <code>Transient</code> provider are created each time they're requested.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import transient\n\n\n@module(providers=[transient(list)])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application:\n        async with application.container() as request_container:\n            obj_1 = await request_container.get(list)\n            obj_2 = await request_container.get(list)\n            assert obj_1 is not obj_2\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#scoped","title":"Scoped","text":"<p>Dependencies defined with the <code>Scoped</code> provider are created once per dependency provider context entry and disposed when the context exits.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import scoped\n\n\n@module(providers=[scoped(list)])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application:\n        async with application.container() as request_container:\n            obj_1 = await request_container.get(list)\n            obj_2 = await request_container.get(list)\n            assert obj_1 is obj_2\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#singleton","title":"Singleton","text":"<p>Dependencies defined with the <code>Singleton</code> provider are created the first time they're requested and disposed when the application lifecycle ends.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import singleton\n\n\n@module(providers=[singleton(list)])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application:\n        async with application.container() as request_container:\n            obj_1 = await request_container.get(list)\n\n        async with application.container():\n            obj_2 = await request_container.get(list)\n\n        assert obj_1 is obj_2\n\n    # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#object","title":"Object","text":"<p>Dependencies defined with the <code>Object</code> provider behave like <code>Singleton</code>, but you must provide the implementation instance directly to the provider and manage its lifecycle manually, outside the IoC container.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import object_\n\nsome_object = (1, 2, 3)\n\n\n@module(\n    providers=[\n        object_(some_object, provided_type=tuple),\n    ],\n)\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application, application.container() as request_container:\n        obj = await request_container.get(tuple)\n        assert obj is some_object\n\n    # Providers are not disposed at this point automatically\n    # because they are not part of the application container lifecycle\n</code></pre>"},{"location":"usage/providers/#contextual","title":"Contextual","text":"<p>The <code>Contextual</code> provider enables you to inject external objects that originate outside the DI container directly into your dependency graph. This is particularly valuable for framework-specific objects like HTTP requests, database transactions, or event data that have their own lifecycle managed externally.</p> <p>When to use Contextual providers:</p> <ul> <li>Framework integration: Inject HTTP request objects, user sessions, or authentication contexts</li> <li>Event-driven scenarios: Process queue messages, webhooks, or callback data</li> <li>External resources: Integrate database transactions, file handles, or network connections managed by external systems</li> <li>Per-request data: Handle any data that varies per request/operation and originates from outside your application</li> </ul> <p>How it works:</p> <ol> <li>Declare the contextual dependency using the <code>contextual</code> provider in your module</li> <li>Use the dependency in other providers just like any regular dependency</li> <li>Provide the actual value when entering the container scope using the <code>context=</code> parameter</li> </ol> <p>The <code>contextual</code> provider accepts two arguments:</p> <ul> <li><code>provided_type</code>: The type of the dependency to be injected</li> <li><code>scope</code>: The scope where the context is available (defaults to <code>Scope.REQUEST</code>)</li> </ul> <pre><code>from waku import WakuFactory, module\nfrom waku.di import contextual, Scope\n\nsome_object = (1, 2, 3)\n\n\n@module(\n    providers=[\n        contextual(provided_type=tuple, scope=Scope.REQUEST),\n    ],\n)\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with (\n        application,\n        application.container(\n            context={tuple: some_object},\n        ) as request_container,\n    ):\n        obj = await request_container.get(tuple)\n        assert obj is some_object\n\n    # Providers are not disposed at this point automatically\n    # because they are not part of the application container lifecycle\n</code></pre> <p>Slightly more realistic example:</p> <p>Consider building a web application with FastAPI where you need to inject the current request into your service layer. Here's how you can accomplish this:</p> <pre><code>from fastapi import FastAPI, Request\nfrom waku import WakuFactory, module\nfrom waku.di import contextual, scoped, Scope\n\n\nclass UserService:\n    \"\"\"Service that uses the current HTTP request for user-specific operations.\"\"\"\n\n    def __init__(self, request: Request) -&gt; None:\n        self.request = request\n\n    def get_user_info(self) -&gt; dict[str, str]:\n        \"\"\"Extract user information from the request headers.\"\"\"\n        return {\n            'user_id': self.request.headers.get('user-id', 'anonymous'),\n            'session_id': self.request.headers.get('session-id', 'none'),\n            'user_agent': self.request.headers.get('user-agent', 'unknown'),\n        }\n\n\n@module(\n    providers=[\n        contextual(provided_type=Request, scope=Scope.REQUEST),\n        scoped(UserService),\n    ],\n)\nclass WebModule:\n    pass\n\n\n# FastAPI application setup\napp = FastAPI()\napplication = WakuFactory(WebModule).create()\n\n\n@app.get('/user-info')\nasync def get_user_info(request: Request) -&gt; dict[str, str]:\n    \"\"\"Endpoint that uses contextual dependency injection.\"\"\"\n    async with (\n        application,\n        application.container(\n            context={Request: request},\n        ) as request_container,\n    ):\n        # UserService automatically receives the current HTTP request\n        user_service = await request_container.get(UserService)\n        return user_service.get_user_info()\n\n\n# Example usage:\n# curl -H \"user-id: john123\" -H \"session-id: abc456\" http://localhost:8000/user-info\n</code></pre> <p>Important</p> <p>In this example, the <code>contextual</code> provider and <code>waku</code> itself are used to manually inject the current request into the <code>UserService</code>. However, in real-world applications, you should use the Dishka FastAPI integration to inject the request automatically.</p> <p>This pattern is essential for integrating with web frameworks, message brokers, and other external systems where objects have lifecycles managed outside your application.</p>"},{"location":"usage/providers/#where-and-how-to-inject-dependencies","title":"Where and how to inject dependencies?","text":"<p>To inject dependencies with <code>waku</code>, you need to:</p> <ol> <li>Register them as <code>providers</code> with the desired scope in modules.</li> <li>Identify your application entrypoints and decorate them with the <code>@inject</code> decorator for your framework. Consult the    Dishka integrations section for your framework to    find out how to do this.</li> <li>Add dependencies as arguments to your entrypoint signature using the <code>Injected</code> type hint.</li> </ol>"},{"location":"usage/providers/#next-steps","title":"Next steps","text":"<p>For advanced features and customization options, refer to the Dishka documentation.</p>"}]}
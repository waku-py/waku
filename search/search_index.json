{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"waku","text":"<p> <sup>waku [\u67a0 or \u308f\u304f] means framework in Japanese.</sup> </p> <p> </p> <p> </p> <p>waku is a modular, type-safe Python framework for scalable, maintainable applications. Inspired by NestJS, powered by Dishka IoC.</p>"},{"location":"#why-waku","title":"Why <code>waku</code>?","text":"<ul> <li>\ud83e\udde9 Modular by design: Enforces clear boundaries and single responsibility.</li> <li>\ud83d\udc89 First-class Dependency Injection: Powered by Dishka.</li> <li>\u26a1 Event-driven and extensible: Built-in hooks, CQRS, and plugin system.</li> <li>\ud83d\udd0c Framework-agnostic: Integrates with FastAPI, Litestar, FastStream, Aiogram, and more.</li> <li>\ud83d\udee1\ufe0f Production-ready: Type-safe, testable, and maintainable.</li> </ul>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<ul> <li>Teams building enterprise or microservice Python apps</li> <li>Developers seeking a clean, maintainable architecture</li> <li>Projects that require testability, loose coupling, and clear module boundaries</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udde9 Modular architecture: Build applications as a set of loosely coupled modules with clear boundaries, automatic dependency validation, and controlled visibility.</li> <li>\ud83d\udc89 Dependency Injection: Use Dishka's IoC container for type-safe, testable, and maintainable dependency management.</li> <li>\ud83d\udce8 CQRS/Mediator: Handle commands, queries, and events with a mediator abstraction inspired by C# MediatR.</li> <li>\ud83e\uddf0 Extensions &amp; plugins: Extend <code>waku</code> with custom plugins that can hook into the application lifecycle, add providers, or integrate with external systems.</li> <li>\ud83d\udd04 Lifespan management: Automatically manage application and IoC container lifecycles with built-in hooks and an event system.</li> <li>\ud83e\udd1d Integrations: Out-of-the-box support for FastAPI, Litestar, FastStream, Aiogram, and more, leveraging Dishka's integrations.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>uv add waku\n# or\npip install waku\n</code></pre>"},{"location":"#minimal-example","title":"Minimal Example","text":"<pre><code>import asyncio\n\nfrom waku import WakuFactory, module\nfrom waku.di import scoped\n\n\nclass GreetingService:\n    async def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n\n\n@module(providers=[scoped(GreetingService)])\nclass GreetingModule:\n    pass\n\n\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    app = WakuFactory(AppModule).create()\n\n    async with app, app.container() as c:\n        svc = await c.get(GreetingService)\n        print(await svc.greet('waku'))\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>For more realistic examples, see the Getting Started guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>Module System</li> <li>Providers</li> <li>Extensions</li> <li>Mediator (CQRS)</li> <li>API Reference</li> <li>Dishka Documentation</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ul> <li>Contributing Guide</li> <li>Development Setup</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Improve inner architecture</li> <li> Improve documentation</li> <li> Add new and improve existing validation rules</li> <li> Provide example projects for common architectures</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Issues</li> <li>Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v0113-2025-04-28","title":"v0.11.3 (2025-04-28)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>core: Move <code>OnModuleConfigure</code> to module definition to prevent duplications on subsequent   calls   (<code>0e6ed00</code>)</li> </ul>"},{"location":"changelog/#v0112-2025-04-28","title":"v0.11.2 (2025-04-28)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>validation: Fix check for provided types in the current module without explicit export   (<code>a771cbb</code>)</li> </ul>"},{"location":"changelog/#v0111-2025-04-28","title":"v0.11.1 (2025-04-28)","text":""},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>Remove duplications in module registry builder logic   (<code>8527c7d</code>)</li> </ul>"},{"location":"changelog/#v0110-2025-04-28","title":"v0.11.0 (2025-04-28)","text":""},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li> <p>Enhance contributing guide and README   (<code>6e4ddda</code>)</p> </li> <li> <p>Fix issue with mediatr link in readme   (<code>8435d2f</code>)</p> </li> <li> <p>Improve api reference docs generation; document override helper   (<code>48061d0</code>)</p> </li> <li> <p>Improve feature descriptions in README   (<code>2d18bee</code>)</p> </li> <li> <p>Update README for clarity   (<code>efaf3d5</code>)</p> </li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li> <p>core: Replace ModuleGraph with ModuleRegistry for module management   (<code>f807f0a</code>)</p> </li> <li> <p>Refactored core architecture to use <code>ModuleRegistry</code> and <code>ModuleRegistryBuilder</code> instead of   <code>ModuleGraph</code> for module registration, traversal, and lookups. - Updated <code>WakuApplication</code> to   depend on <code>ModuleRegistry</code> and expose it via the <code>registry</code> property. - Refactored validation,   factory, and extension logic to use the new registry API. - Removed legacy <code>ModuleGraph</code>   implementation. - Ensured all module-related queries, traversals, and global checks use the new   registry. - Updated imports and type hints for consistency with new architecture. - Introduced   <code>WakuError</code> as a base exception for framework errors. - Minor code style and typing improvements   for clarity and maintainability.</p> </li> </ul> <p>BREAKING CHANGE: All module graph operations now use <code>ModuleRegistry</code>; direct usage of <code>ModuleGraph</code>   is no longer supported. Update custom extensions and validation logic accordingly.</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>core: All module graph operations now use <code>ModuleRegistry</code>; direct usage of <code>ModuleGraph</code> is   no longer supported. Update custom extensions and validation logic accordingly.</li> </ul>"},{"location":"changelog/#v0100-2025-04-26","title":"v0.10.0 (2025-04-26)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Re-export di related object from dishka   (<code>820ddc4</code>)</li> </ul> <p>Also improve test suite and add docstrings to di helpers</p>"},{"location":"changelog/#v091-2025-04-26","title":"v0.9.1 (2025-04-26)","text":""},{"location":"changelog/#performance-improvements_1","title":"Performance Improvements","text":"<ul> <li>Optimize DependenciesAccessible rule   (<code>8eb1ae2</code>)</li> </ul>"},{"location":"changelog/#v090-2025-04-25","title":"v0.9.0 (2025-04-25)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li> <p>Skip context providers when validation that deps accessible   (<code>12d658e</code>)</p> </li> <li> <p>Trigger release   (<code>2d31df1</code>)</p> </li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li> <p>Actualize readme file   (<code>1001875</code>)</p> </li> <li> <p>Fix readme formatting   (<code>116e424</code>)</p> </li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li> <p>Add container override helper to application   (<code>1e2f216</code>)</p> </li> <li> <p>Add di helpers, add testing override helper   (<code>66d7bb5</code>)</p> </li> </ul>"},{"location":"changelog/#v080-2025-04-24","title":"v0.8.0 (2025-04-24)","text":""},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>Improve readme, add motivation section   (<code>059e5c9</code>)</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Migrate to dishka as ioc provider   (<code>7296122</code>)</li> </ul>"},{"location":"changelog/#v070-2025-04-13","title":"v0.7.0 (2025-04-13)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Rename application to waku   (<code>12c9cd8</code>)</li> </ul>"},{"location":"changelog/#v060-2025-03-25","title":"v0.6.0 (2025-03-25)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Change links to di docs in readme   (<code>0bf7086</code>)</li> </ul>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li> <p>Rename development section to contributing (#19,   <code>08ec5f5</code>)</p> </li> <li> <p>Rename di section to providers, improve its contents   (#111,   <code>f63c936</code>)</p> </li> <li> <p>Slightly reorganize documentation (#19,   <code>fe8220a</code>)</p> </li> <li> <p>di: Expand di documentation (#111,   <code>887e76f</code>)</p> </li> </ul>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Add more info to provider validation error messages   (#113,   <code>9dced06</code>)</li> </ul>"},{"location":"changelog/#v050-2025-03-23","title":"v0.5.0 (2025-03-23)","text":""},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li> <p>Add basic modules and providers docs   (<code>9ddbc3b</code>)</p> </li> <li> <p>Further improve documentation #19 #94   (<code>3d061b6</code>)</p> </li> <li> <p>add getting started section * add more usage docs * change api reference appearance * improve   mkdocs config</p> </li> </ul>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li> <p>mediator: Simplify cqrs handlers registration (#105)   (#107,   <code>65fa07d</code>)</p> </li> <li> <p>Remove <code>MediatorProvidersCreator</code> * Add new module extension type <code>OnModuleConfigure</code> for allowing   change module metadata before module creating * Move handlers binding logic to <code>MediatorExtension</code></p> </li> </ul> <p>Resolves: #105</p>"},{"location":"changelog/#v040-2025-03-16","title":"v0.4.0 (2025-03-16)","text":""},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>Setup mkdocs and improve documentation   (<code>d5166d7</code>)</li> </ul>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>Add ability to pass custom context to dependency provider   (<code>a0e055f</code>)</li> </ul>"},{"location":"changelog/#v031-2025-02-13","title":"v0.3.1 (2025-02-13)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Do not unwrap generic annotations in <code>collect_dependencies</code>   (<code>c5f1b7c</code>)</li> </ul>"},{"location":"changelog/#v030-2025-02-10","title":"v0.3.0 (2025-02-10)","text":""},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Refactor module system   (<code>43a102a</code>)</li> </ul>"},{"location":"changelog/#v020-2025-01-12","title":"v0.2.0 (2025-01-12)","text":""},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li> <p>Add docstrings to mediator related stuff   (<code>10728c0</code>)</p> </li> <li> <p>Deploy mkdocs to github pages #17   (<code>23872d7</code>)</p> </li> <li> <p>Improve readme and contributing guide   (<code>93529d1</code>)</p> </li> <li> <p>Trigger docs deploy #17   (<code>096876f</code>)</p> </li> <li> <p>Use org bot for pages deploy #17   (<code>dfd1786</code>)</p> </li> </ul>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li> <p>Eliminate maps usage in mediator   (<code>16679d7</code>)</p> </li> <li> <p>Refactor mediator extension, add events handling support   (<code>3441375</code>)</p> </li> </ul> <p>Resolves #12 Fixes #16</p>"},{"location":"changelog/#v016-2024-12-20","title":"v0.1.6 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Skip ci in release commit   (<code>9adbc58</code>)</li> </ul>"},{"location":"changelog/#v015-2024-12-20","title":"v0.1.5 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Remove unused version var from init, run gitlint only for prs   (<code>7a270d4</code>)</li> </ul>"},{"location":"changelog/#v014-2024-12-20","title":"v0.1.4 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Attempt to fix contextvar from different context error   (<code>d98c2f8</code>)</li> </ul>"},{"location":"changelog/#v013-2024-12-20","title":"v0.1.3 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>ext: Make mediator middlewares work   (<code>4e4a593</code>)</li> </ul>"},{"location":"changelog/#build-system","title":"Build System","text":"<ul> <li>Make patch release only for <code>fix</code> &amp; <code>perf</code> tags   (<code>b9cf6bf</code>)</li> </ul>"},{"location":"changelog/#documentation_7","title":"Documentation","text":"<ul> <li>Add readme and contributing guide   (<code>32043d7</code>)</li> </ul>"},{"location":"changelog/#v012-2024-12-19","title":"v0.1.2 (2024-12-19)","text":""},{"location":"changelog/#continuous-integration","title":"Continuous Integration","text":"<ul> <li> <p>Fix semantic release step   (<code>c516322</code>)</p> </li> <li> <p>Fix semantic release step 2   (<code>176a466</code>)</p> </li> <li> <p>Setup github actions pipelines   (<code>3f0ec58</code>)</p> </li> </ul>"},{"location":"changelog/#v011-2024-12-19","title":"v0.1.1 (2024-12-19)","text":""},{"location":"changelog/#chores","title":"Chores","text":"<ul> <li>deps: Use litestar-msgspec with litestar extra on all python version   (<code>ef60b04</code>)</li> </ul>"},{"location":"changelog/#v010-2024-12-18","title":"v0.1.0 (2024-12-18)","text":""},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>Module validation   (<code>45c58b1</code>)</li> </ul>"},{"location":"changelog/#chores_1","title":"Chores","text":"<ul> <li> <p>Adjust dev workflow, add semantic release config   (<code>ab3313a</code>)</p> </li> <li> <p>ci: Try fix ci   (<code>2bf8383</code>)</p> </li> </ul>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li> <p>Add providers registration, fix validation   (<code>35ef7f3</code>)</p> </li> <li> <p>Add semantic release, rename package   (<code>a8addaf</code>)</p> </li> <li> <p>Implement di &amp; mediator extension   (<code>f7ebdb9</code>)</p> </li> <li> <p>Improve app &amp; di lifespan, add check for app providers   (<code>d5b3a31</code>)</p> </li> <li> <p>Improve providers validation &amp; add imports to init files   (<code>7bd5999</code>)</p> </li> <li> <p>Make application module itself, improve aioinject provider   (<code>9ae70a2</code>)</p> </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Note</p> <p>For our examples we stick with aioinject as DI provider. Install it directly using your preferred package manager or as extra dependency of <code>waku</code>:</p> uvpip <pre><code>uv add \"waku[aioinject]\"\n# or\nuv add aioinject\n</code></pre> <pre><code>pip install \"waku[aioinject]\"\n# or\npip install aioinject\n</code></pre>"},{"location":"getting-started/#creating-your-first-waku-application","title":"Creating Your First <code>waku</code> Application","text":"<p>Let's create a simple application that demonstrates <code>waku</code> core concepts.</p>"},{"location":"getting-started/#step-1-create-the-basic-structure","title":"Step 1: Create the Basic Structure","text":"<p>Create a new directory for your project and set up your files:</p> <pre><code>project/\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 services.py\n</code></pre>"},{"location":"getting-started/#step-2-define-your-services","title":"Step 2: Define Your Services","text":"<p>In <code>services.py</code>, let's define a simple service:</p> services.py<pre><code>class GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n</code></pre>"},{"location":"getting-started/#step-3-create-modules","title":"Step 3: Create Modules","text":"<p>In <code>app.py</code>, let's define our modules and application setup:</p> app.py<pre><code>import asyncio\n\nfrom waku import WakuApplication, WakuFactory, module\nfrom waku.di import Scoped, Injected, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nfrom project.services import GreetingService\n\n\n# Define a feature module\n@module(\n    providers=[Scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n\n\n# Define the root application module\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\n# Define a function that will use our service\n@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n\n\n# Bootstrap the application\ndef bootstrap() -&gt; WakuApplication:\n    return WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n\n\n# Run the application\nasync def main() -&gt; None:\n    application = bootstrap()\n\n    # Create a context for our application\n    async with application, application.container.context():\n        # Use our service\n        message = await greet_user()  # type: ignore[call-arg]\n        print(message)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-4-run-your-application","title":"Step 4: Run Your Application","text":"<p>Run the application with:</p> <pre><code>python app.py\n</code></pre> <p>You should see the output:</p> <pre><code>Hello, waku!\n</code></pre>"},{"location":"getting-started/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what's happening in our simple application:</p>"},{"location":"getting-started/#modules","title":"Modules","text":"<p>Modules are the building blocks of a <code>waku</code> application. Each module encapsulates a specific feature or functionality.</p> <pre><code>@module(\n    providers=[Scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre> <p>In this example:</p> <ul> <li><code>providers</code> defines which providers this module creates and manages</li> <li><code>exports</code> makes these providers (or imported modules) available to other modules that import this one</li> <li><code>Scoped</code> indicates this provider should be created once for every container context entrance.</li> </ul> <p>Info</p> <p>For more information on providers and scopes, see Providers.</p>"},{"location":"getting-started/#application-bootstrap","title":"Application Bootstrap","text":"<p>The application is created using an <code>ApplicationFactory</code>:</p> <pre><code>def bootstrap() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n</code></pre> <p>This creates an application instance with:</p> <ul> <li><code>AppModule</code> as the root module</li> <li><code>AioinjectDependencyProvider</code> as the dependency injection provider</li> </ul>"},{"location":"getting-started/#dependency-injection","title":"Dependency Injection","text":"<p>Providers are injected into functions using the @inject decorator:</p> <pre><code>@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n</code></pre> <p>The <code>Injected[GreetingService]</code> type annotation tells <code>waku</code> which provider to inject.</p>"},{"location":"getting-started/#context-management","title":"Context Management","text":"<p><code>waku</code> uses context managers to manage the lifecycle of your application and its providers:</p> <pre><code>async with application, application.container.context():\n    message = await greet_user()\n</code></pre> <p>In real applications, you would typically use this context managers in <code>lifespan</code> of your framework.</p>"},{"location":"getting-started/#creating-a-more-realistic-application","title":"Creating a More Realistic Application","text":"<p>Let's extend our example to demonstrate a more realistic scenario with multiple modules and configuration.</p>"},{"location":"getting-started/#step-1-enhanced-structure","title":"Step 1: Enhanced Structure","text":"<p>Create a more complete project structure:</p> <pre><code>app/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __main__.py\n\u251c\u2500\u2500 application.py\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 greetings/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 services.py\n\u2502   \u2502   \u2514\u2500\u2500 module.py\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 services.py\n\u2502       \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 settings.py\n</code></pre>"},{"location":"getting-started/#step-2-add-configuration-module","title":"Step 2: Add Configuration Module","text":"<p>Define an application settings class and configuration module for providing settings object to your application:</p> app/settings.py<pre><code>from dataclasses import dataclass\nfrom typing import Literal\n\nfrom waku import DynamicModule, module\nfrom waku.di import Object\n\nEnvironment = Literal['dev', 'prod']\n\n\n# You may consider using `pydantic-settings` or similar libs for settings management\n@dataclass(kw_only=True)\nclass AppSettings:\n    environment: Environment\n    debug: bool\n\n\n@module(is_global=True)\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: Environment) -&gt; DynamicModule:\n        settings = AppSettings(\n            environment=env,\n            debug=env == 'dev',\n        )\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Object(settings)],\n        )\n</code></pre>"},{"location":"getting-started/#step-3-create-modules_1","title":"Step 3: Create Modules","text":""},{"location":"getting-started/#greeting-module","title":"Greeting Module","text":"app/modules/greetings/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Greeting:\n    language: str\n    template: str\n</code></pre> app/modules/greetings/services.py<pre><code>from app.config import AppConfig\nfrom app.modules.greetings.models import Greeting\n\n\nclass GreetingService:\n    def __init__(self, config: AppConfig) -&gt; None:\n        self.config = config\n        self.greetings: dict[str, Greeting] = {\n            'en': Greeting(language='en', template='Hello, {}!'),\n            'es': Greeting(language='es', template='\u00a1Hola, {}!'),\n            'fr': Greeting(language='fr', template='Bonjour, {}!'),\n        }\n\n    def get_greeting(self, language: str = 'en') -&gt; Greeting:\n        # If in debug mode and language not found, return default\n        if self.config.debug and language not in self.greetings:\n            return self.greetings['en']\n        return self.greetings.get(language, self.greetings['en'])\n\n    def greet(self, name: str, language: str = 'en') -&gt; str:\n        greeting = self.get_greeting(language)\n        return greeting.template.format(name)\n\n    def available_languages(self) -&gt; list[str]:\n        return list(self.greetings.keys())\n</code></pre> app/modules/greetings/module.py<pre><code>from waku import module\nfrom waku.di import Singleton\n\nfrom app.modules.greetings.services import GreetingService\n\n\n@module(\n    providers=[Singleton(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre>"},{"location":"getting-started/#user-module","title":"User Module","text":"app/modules/users/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: str\n    name: str\n    preferred_language: str = 'en'\n</code></pre> app/modules/users/services.py<pre><code>from app.modules.users.models import User\n\n\nclass UserService:\n    def __init__(self) -&gt; None:\n        # Mock database\n        self.users: dict[str, User] = {\n            '1': User(id='1', name='Alice', preferred_language='en'),\n            '2': User(id='2', name='Bob', preferred_language='fr'),\n            '3': User(id='3', name='Carlos', preferred_language='es'),\n        }\n\n    def get_user(self, user_id: str) -&gt; User | None:\n        return self.users.get(user_id)\n</code></pre> app/modules/users/module.py<pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.users.services import UserService\n\n\n@module(\n    providers=[Scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n</code></pre>"},{"location":"getting-started/#step-4-create-the-application-module","title":"Step 4: Create the Application Module","text":"<p>Define the application module and bootstrap function for initializing your application:</p> app/application.py<pre><code>from waku import WakuApplication, WakuFactory, module\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nfrom app.settings import ConfigModule\nfrom app.greetings.module import GreetingModule\nfrom app.users.module import UserModule\n\n\n@module(\n    # Import all top-level modules\n    imports=[\n        ConfigModule.register(env='dev'),\n        GreetingModule,\n        UserModule,\n    ],\n)\nclass AppModule:\n    pass\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    return WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n</code></pre>"},{"location":"getting-started/#step-5-create-the-main-entrypoint","title":"Step 5: Create the Main Entrypoint","text":"<p>In real world scenarios, you would use a framework like FastAPI, Flask, etc. for defining your entry points, also known as handlers. For the sake of simplicity, we don't use any framework in this example.</p> app/__main__.py<pre><code>import asyncio\n\nfrom waku.di import Injected, inject\n\nfrom app.application import bootstrap_application\nfrom app.modules.users.services import UserService\nfrom app.modules.greetings.services import GreetingService\n\n\n@inject\nasync def greet_user_by_id(\n    user_id: str,\n    user_service: Injected[UserService],\n    greeting_service: Injected[GreetingService],\n) -&gt; str:\n    user = user_service.get_user(user_id)\n    if not user:\n        return f'User {user_id} not found'\n\n    return greeting_service.greet(name=user.name, language=user.preferred_language)\n\n\nasync def main() -&gt; None:\n    application = bootstrap_application()\n\n    async with application, application.container.context():\n        # Greet different users\n        for user_id in ['1', '2', '3', '4']:  # '4' doesn't exist\n            greeting = await greet_user_by_id(user_id)  # type: ignore[call-arg]\n            print(greeting)\n\n        # Get service directly for demonstration\n        greeting_service = application.container.get(GreetingService)\n        print(f'Available languages: {greeting_service.available_languages()}')\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-6-run-your-application","title":"Step 6: Run Your Application","text":"<pre><code>python -m app\n</code></pre> <p>Expected output:</p> <pre><code>Hello, Alice!\nBonjour, Bob!\n\u00a1Hola, Carlos!\nUser 4 not found\nAvailable languages: ['en', 'es', 'fr']\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of <code>waku</code>, you can:</p> <ol> <li>Explore more advanced features like Mediator (CQRS)</li> <li>Learn about Extensions for adding functionality to your application</li> <li>Integrate with web frameworks like FastAPI</li> <li>Understand Module System in depth</li> <li>Explore Dependency Injection techniques</li> </ol> <p><code>waku</code> modular architecture allows your application to grow while maintaining clear separation of concerns and a clean, maintainable codebase.</p> <p>Note</p> <p>This guide is a starting point. It's highly recommended to read The Software Architecture Chronicles by Herberto Gra\u00e7a. He distills all popular software architectural styles into a single one to rule them all. It's a great read and will help you understand the principles behind <code>waku</code>.</p> <p>Happy coding with <code>waku</code>!</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#waku","title":"waku","text":""},{"location":"reference/#waku.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extensions = list(extensions)\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n</code></pre>"},{"location":"reference/#waku.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(\n    self,\n) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(self._root_module_type).build()\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extensions=self._extensions,\n    )\n</code></pre>"},{"location":"reference/#waku.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        object | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[object | ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        object | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[BaseProvider]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[object | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[object | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.application","title":"application","text":""},{"location":"reference/#waku.application.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extensions = list(extensions)\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.di","title":"di","text":""},{"location":"reference/#waku.di.provider","title":"provider","text":"<pre><code>provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = REQUEST,\n    provided_type: Any = None,\n    cache: bool = True,\n) -&gt; Provider\n</code></pre> <p>Create a Dishka provider for a callable or type.</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>scope</code> <p>Scope of the dependency (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>cache</code> <p>Whether to cache the instance in the scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Configured provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = Scope.REQUEST,\n    provided_type: Any = None,\n    cache: bool = True,\n) -&gt; Provider:\n    \"\"\"Create a Dishka provider for a callable or type.\n\n    Args:\n        source: Callable or type to provide as a dependency.\n        scope: Scope of the dependency (default: Scope.REQUEST).\n        provided_type: Explicit type to provide (default: inferred).\n        cache: Whether to cache the instance in the scope.\n\n    Returns:\n        Provider: Configured provider instance.\n    \"\"\"\n    provider_ = Provider(scope=scope)\n    provider_.provide(source, provides=provided_type, cache=cache)\n    return provider_\n</code></pre>"},{"location":"reference/#waku.di.singleton","title":"singleton","text":"<pre><code>singleton(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider\n</code></pre> <p>Create a singleton provider (lifetime: app).</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a singleton.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Singleton provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def singleton(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Create a singleton provider (lifetime: app).\n\n    Args:\n        source: Callable or type to provide as a singleton.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Singleton provider instance.\n    \"\"\"\n    return provider(source, scope=Scope.APP, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.di.scoped","title":"scoped","text":"<pre><code>scoped(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider\n</code></pre> <p>Create a scoped provider (lifetime: request).</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a scoped dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Scoped provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def scoped(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Create a scoped provider (lifetime: request).\n\n    Args:\n        source: Callable or type to provide as a scoped dependency.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Scoped provider instance.\n    \"\"\"\n    return provider(source, scope=Scope.REQUEST, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.di.transient","title":"transient","text":"<pre><code>transient(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider\n</code></pre> <p>Create a transient provider (new instance per injection).</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a transient dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Transient provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def transient(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Create a transient provider (new instance per injection).\n\n    Args:\n        source: Callable or type to provide as a transient dependency.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Transient provider instance.\n    \"\"\"\n    return provider(source, scope=Scope.REQUEST, provided_type=provided_type, cache=False)\n</code></pre>"},{"location":"reference/#waku.di.object_","title":"object_","text":"<pre><code>object_(\n    source: Any, *, provided_type: Any = None\n) -&gt; Provider\n</code></pre> <p>Provide the exact object passed at creation time as a singleton dependency.</p> <p>The provider always returns the same object instance, without instantiation or copying.</p> PARAMETER DESCRIPTION <code>source</code> <p>The object to provide as-is.</p> <p> TYPE: <code>Any</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Provider that always returns the given object.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def object_(\n    source: Any,\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Provide the exact object passed at creation time as a singleton dependency.\n\n    The provider always returns the same object instance, without instantiation or copying.\n\n    Args:\n        source: The object to provide as-is.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Provider that always returns the given object.\n    \"\"\"\n    return provider(lambda: source, scope=Scope.APP, provided_type=provided_type, cache=True)\n</code></pre>"},{"location":"reference/#waku.di.contextual","title":"contextual","text":"<pre><code>contextual(\n    provided_type: Any, *, scope: Scope = REQUEST\n) -&gt; Provider\n</code></pre> <p>Provide a dependency from the current context (e.g., app/request).</p> PARAMETER DESCRIPTION <code>provided_type</code> <p>The type to resolve from context.</p> <p> TYPE: <code>Any</code> </p> <code>scope</code> <p>Scope of the context variable (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Contextual provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def contextual(\n    provided_type: Any,\n    *,\n    scope: Scope = Scope.REQUEST,\n) -&gt; Provider:\n    \"\"\"Provide a dependency from the current context (e.g., app/request).\n\n    Args:\n        provided_type: The type to resolve from context.\n        scope: Scope of the context variable (default: Scope.REQUEST).\n\n    Returns:\n        Provider: Contextual provider instance.\n    \"\"\"\n    provider_ = Provider()\n    provider_.from_context(provided_type, scope=scope)\n    return provider_\n</code></pre>"},{"location":"reference/#waku.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.exceptions.WakuError","title":"WakuError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/#waku.ext","title":"ext","text":""},{"location":"reference/#waku.ext.DEFAULT_EXTENSIONS","title":"DEFAULT_EXTENSIONS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EXTENSIONS: Sequence[ApplicationExtension] = (\n    ValidationExtension(\n        [DependenciesAccessible()], strict=True\n    ),\n)\n</code></pre>"},{"location":"reference/#waku.ext.validation","title":"validation","text":""},{"location":"reference/#waku.ext.validation.ValidationRule","title":"ValidationRule","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.ext.validation.ValidationRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/ext/validation/_abc.py</code> <pre><code>def validate(self, context: ValidationContext) -&gt; list[ValidationError]: ...\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>WakuError</code></p>"},{"location":"reference/#waku.ext.validation.ValidationExtension","title":"ValidationExtension","text":"<pre><code>ValidationExtension(\n    rules: Sequence[ValidationRule], *, strict: bool = True\n)\n</code></pre> <p>               Bases: <code>AfterApplicationInit</code></p> Source code in <code>src/waku/ext/validation/_extension.py</code> <pre><code>def __init__(self, rules: Sequence[ValidationRule], *, strict: bool = True) -&gt; None:\n    self.rules = rules\n    self.strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.rules","title":"rules  <code>instance-attribute</code>","text":"<pre><code>rules = rules\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/ext/validation/_extension.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    context = ValidationContext(app=app)\n\n    errors_chain = chain.from_iterable(rule.validate(context) for rule in self.rules)\n    if errors := list(errors_chain):\n        self._raise(errors)\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules","title":"rules","text":""},{"location":"reference/#waku.ext.validation.rules.DependenciesAccessible","title":"DependenciesAccessible","text":"<p>               Bases: <code>ValidationRule</code></p> <p>Check if all dependencies of providers are accessible.</p> <p>This validation rule ensures that all dependencies required by providers are either: 1. Available globally 2. Provided by the current module 3. Provided by any of the imported modules</p>"},{"location":"reference/#waku.ext.validation.rules.DependenciesAccessible.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/ext/validation/rules.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    registry: ModuleRegistry = context.app.registry\n    modules: list[Module] = list(registry.traverse())  # Validate all registered modules\n\n    # Cache global providers\n    global_providers: set[type[object]] = {AsyncContainer}\n    global_providers |= {\n        provided_type\n        for module in modules\n        for provided_type in _module_provided_types(module)\n        if registry.is_global_module(module)\n    }\n    global_context_providers = {\n        dep.type_hint\n        for dep, factory in context.app.container.registry.factories.items()\n        if (factory.scope is Scope.APP and factory.type is FactoryType.CONTEXT)\n    }\n    global_providers |= global_context_providers\n\n    errors: list[ValidationError] = []\n    for module in modules:\n        imported_modules = [m for m in registry.traverse(module) if m != module]\n        for provider in module.providers:\n            for factory in provider.factories:\n                inaccessible_deps: set[type[object]] = set()\n                for dependency in factory.dependencies:\n                    dep_type = dependency.type_hint\n                    if not _can_access_dependency(dep_type, module, global_providers, imported_modules):\n                        inaccessible_deps.add(dep_type)\n\n                for dep_type in inaccessible_deps:\n                    err_msg = (\n                        f'\"{factory.source!r}\" from \"{module!r}\" depends on \"{dep_type!r}\" but it\\'s not accessible to it\\n'\n                        f'To resolve this issue:\\n'\n                        f'   1. Export \"{dep_type!r}\" from some module\\n'\n                        f'   2. Add module which exports \"{dep_type!r}\" to \"{module!r}\" imports'\n                    )\n                    errors.append(ValidationError(err_msg))\n\n    return errors\n</code></pre>"},{"location":"reference/#waku.extensions","title":"extensions","text":"<p>Extension protocols for the waku framework.</p> <p>This module defines protocols for extending module behavior. These protocols allow for hooking into various lifecycle events.</p>"},{"location":"reference/#waku.extensions.ApplicationExtension","title":"ApplicationExtension  <code>module-attribute</code>","text":"<pre><code>ApplicationExtension: TypeAlias = (\n    OnApplicationInit | AfterApplicationInit\n)\n</code></pre>"},{"location":"reference/#waku.extensions.ModuleExtension","title":"ModuleExtension  <code>module-attribute</code>","text":"<pre><code>ModuleExtension: TypeAlias = (\n    OnModuleConfigure | OnModuleInit\n)\n</code></pre>"},{"location":"reference/#waku.extensions.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions after application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions after application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleConfigure","title":"OnModuleConfigure","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module configuration.</p>"},{"location":"reference/#waku.extensions.OnModuleConfigure.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> <p>Perform actions before module metadata transformed to module.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    \"\"\"Perform actions before module metadata transformed to module.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.factory","title":"factory","text":""},{"location":"reference/#waku.factory.ContainerConfig","title":"ContainerConfig  <code>dataclass</code>","text":"<pre><code>ContainerConfig(\n    *,\n    lock_factory: _LockFactory = Lock,\n    start_scope: Scope | None = None,\n    skip_validation: bool = False,\n    validation_settings: ValidationSettings = lambda: STRICT_VALIDATION(),\n)\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.lock_factory","title":"lock_factory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lock_factory: _LockFactory = Lock\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.start_scope","title":"start_scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_scope: Scope | None = None\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.skip_validation","title":"skip_validation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>skip_validation: bool = False\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.validation_settings","title":"validation_settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>validation_settings: ValidationSettings = field(\n    default_factory=lambda: STRICT_VALIDATION\n)\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(\n    self,\n) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(self._root_module_type).build()\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extensions=self._extensions,\n    )\n</code></pre>"},{"location":"reference/#waku.lifespan","title":"lifespan","text":""},{"location":"reference/#waku.lifespan.LifespanFunc","title":"LifespanFunc  <code>module-attribute</code>","text":"<pre><code>LifespanFunc: TypeAlias = (\n    Callable[\n        ['WakuApplication'],\n        AbstractAsyncContextManager[None],\n    ]\n    | AbstractAsyncContextManager[None]\n)\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper","title":"LifespanWrapper","text":"<pre><code>LifespanWrapper(lifespan_func: LifespanFunc)\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>def __init__(self, lifespan_func: LifespanFunc) -&gt; None:\n    self._lifespan_func = lifespan_func\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app: WakuApplication) -&gt; AsyncIterator[None]\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: WakuApplication) -&gt; AsyncIterator[None]:\n    ctx_manager = (\n        self._lifespan_func\n        if isinstance(self._lifespan_func, AbstractAsyncContextManager)\n        else self._lifespan_func(app)\n    )\n    async with ctx_manager:\n        yield\n</code></pre>"},{"location":"reference/#waku.mediator","title":"mediator","text":""},{"location":"reference/#waku.mediator.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.mediator.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.mediator.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.mediator.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    middleware_chain: MiddlewareChain,\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default mediator implementation.</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>def __init__(\n    self,\n    container: AsyncContainer,\n    middleware_chain: MiddlewareChain,\n    event_publisher: EventPublisher,\n) -&gt; None:\n    self._container = container\n    self._middleware_chain = middleware_chain\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.mediator.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the mediator middleware chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the mediator middleware chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.mediator.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.mediator.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a mediator to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.mediator.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the mediator to be handled by multiple handlers.</p>"},{"location":"reference/#waku.mediator.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the mediator middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.mediator.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.MiddlewareChain","title":"MiddlewareChain","text":"<pre><code>MiddlewareChain(middlewares: Sequence[Middleware])\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def __init__(self, middlewares: Sequence[Middleware]) -&gt; None:\n    self._middlewares = middlewares\n</code></pre>"},{"location":"reference/#waku.mediator.MiddlewareChain.wrap","title":"wrap","text":"<pre><code>wrap(\n    container: AsyncContainer, *, handle: HandleType\n) -&gt; HandleType\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def wrap(self, container: AsyncContainer, *, handle: HandleType) -&gt; HandleType:\n    original_handle = handle\n    for cls, args, kwargs in reversed(self._middlewares):\n        middleware = cls(\n            MiddlewareContext(container=container),\n            *args,\n            **kwargs,\n        )\n        handle = functools.update_wrapper(\n            wrapper=functools.partial(middleware.__call__, handle=handle),\n            wrapped=original_handle,\n        )\n    return handle\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    middlewares: Sequence[Middleware] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the mediator pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the mediator interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>middlewares</code> <p>A sequence of middleware classes that will be applied to the mediator pipeline. Middlewares are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[Middleware]</code> </p> Example <pre><code>config = MediatorConfig(\n    mediator_implementation_type=CustomMediator,\n    middlewares=[LoggingMiddleware(), ValidationMiddleware()],\n)\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig.middlewares","title":"middlewares  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Middleware] = ()\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.mediator.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=list(\n            chain(\n                cls._create_mediator_providers(config_),\n                cls._create_middleware_chain_provider(config_),\n            ),\n        ),\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.mediator.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/mediator/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: RequestMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        msg = f'{request_type.__name__} already exists in registry'\n        raise RequestHandlerAlreadyRegistered(msg, request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap.merge","title":"merge","text":"<pre><code>merge(other: RequestMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.contracts","title":"contracts","text":""},{"location":"reference/#waku.mediator.contracts.event","title":"event","text":""},{"location":"reference/#waku.mediator.contracts.event.EventT","title":"EventT  <code>module-attribute</code>","text":"<pre><code>EventT = TypeVar(\n    'EventT', bound='Event', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.event.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for events.</p>"},{"location":"reference/#waku.mediator.contracts.request","title":"request","text":""},{"location":"reference/#waku.mediator.contracts.request.RequestT","title":"RequestT  <code>module-attribute</code>","text":"<pre><code>RequestT = TypeVar(\n    'RequestT', bound='Request[Any]', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.request.ResponseT","title":"ResponseT  <code>module-attribute</code>","text":"<pre><code>ResponseT = TypeVar(\n    'ResponseT',\n    bound='Response | None',\n    default=None,\n    covariant=True,\n)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.mediator.contracts.request.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.request.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.mediator.events","title":"events","text":""},{"location":"reference/#waku.mediator.events.handler","title":"handler","text":""},{"location":"reference/#waku.mediator.events.handler.EventHandlerType","title":"EventHandlerType  <code>module-attribute</code>","text":"<pre><code>EventHandlerType: TypeAlias = type[EventHandler[EventT]]\n</code></pre>"},{"location":"reference/#waku.mediator.events.handler.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventT]</code></p> <p>The event handler interface.</p> <p>Usage::</p> <p>class UserJoinedEventHandler(EventHandler[UserJoinedEvent])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, event: UserJoinedEvent) -&gt; None:\n      await self._meetings_api.notify_room(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"reference/#waku.mediator.events.handler.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: EventT) -&gt; None\n</code></pre> Source code in <code>src/waku/mediator/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: EventT) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.mediator.events.map","title":"map","text":""},{"location":"reference/#waku.mediator.events.map.EventMapRegistry","title":"EventMapRegistry  <code>module-attribute</code>","text":"<pre><code>EventMapRegistry: TypeAlias = MutableMapping[\n    type[EventT], list[EventHandlerType[EventT]]\n]\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap","title":"EventMap","text":"<pre><code>EventMap()\n</code></pre> Source code in <code>src/waku/mediator/events/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: EventMapRegistry[Any] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: EventMapRegistry[Any]\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap.bind","title":"bind","text":"<pre><code>bind(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/events/map.py</code> <pre><code>def bind(self, event_type: type[EventT], handler_types: list[EventHandlerType[EventT]]) -&gt; Self:\n    for handler_type in handler_types:\n        if handler_type in self._registry[event_type]:\n            msg = f'{handler_type.__name__} already registered for {event_type.__name__} event'\n            raise EventHandlerAlreadyRegistered(msg, event_type, handler_type)\n        self._registry[event_type].append(handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap.merge","title":"merge","text":"<pre><code>merge(other: EventMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/events/map.py</code> <pre><code>def merge(self, other: EventMap) -&gt; Self:\n    for event_type, handlers in other.registry.items():\n        self.bind(event_type, handlers)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.events.publish","title":"publish","text":""},{"location":"reference/#waku.mediator.events.publish.EventPublisher","title":"EventPublisher","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.mediator.events.publish.SequentialEventPublisher","title":"SequentialEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.mediator.events.publish.GroupEventPublisher","title":"GroupEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.mediator.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.mediator.exceptions.MediatorError","title":"MediatorError","text":"<p>               Bases: <code>WakuError</code></p> <p>Base exception for all mediator-related errors.</p>"},{"location":"reference/#waku.mediator.exceptions.ImproperlyConfiguredError","title":"ImproperlyConfiguredError","text":"<p>               Bases: <code>MediatorError</code></p> <p>Raised when mediator configuration is invalid.</p>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerAlreadyRegistered","title":"RequestHandlerAlreadyRegistered","text":"<pre><code>RequestHandlerAlreadyRegistered(\n    msg: str,\n    request_type: type[Request[Any]],\n    handler_type: RequestHandlerType[Any, Any],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a request handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> TYPE: <code>type[Request[Any]]</code> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> TYPE: <code>RequestHandlerType[Any, Any]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(\n    self,\n    msg: str,\n    request_type: type[Request[Any]],\n    handler_type: RequestHandlerType[Any, Any],\n) -&gt; None:\n    super().__init__(msg)\n    self.request_type = request_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type: type[Request[Any]] = request_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type: RequestHandlerType[Any, Any] = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerNotFound","title":"RequestHandlerNotFound","text":"<pre><code>RequestHandlerNotFound(\n    msg: str, request_type: type[Request[Any]]\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when a request handler is not found.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> TYPE: <code>type[Request[Any]]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(self, msg: str, request_type: type[Request[Any]]) -&gt; None:\n    super().__init__(msg)\n    self.request_type = request_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerNotFound.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type: type[Request[Any]] = request_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerAlreadyRegistered","title":"EventHandlerAlreadyRegistered","text":"<pre><code>EventHandlerAlreadyRegistered(\n    msg: str,\n    event_type: type[Event],\n    handler_type: EventHandlerType[Any],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when an event handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> TYPE: <code>type[Event]</code> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> TYPE: <code>EventHandlerType[Any]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(\n    self,\n    msg: str,\n    event_type: type[Event],\n    handler_type: EventHandlerType[Any],\n) -&gt; None:\n    super().__init__(msg)\n    self.event_type = event_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerAlreadyRegistered.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type: type[Event] = event_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type: EventHandlerType[Any] = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerNotFound","title":"EventHandlerNotFound","text":"<pre><code>EventHandlerNotFound(msg: str, event_type: type[Event])\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when an event handler is not found.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> TYPE: <code>type[Event]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(self, msg: str, event_type: type[Event]) -&gt; None:\n    super().__init__(msg)\n    self.event_type = event_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerNotFound.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type: type[Event] = event_type\n</code></pre>"},{"location":"reference/#waku.mediator.impl","title":"impl","text":""},{"location":"reference/#waku.mediator.impl.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    middleware_chain: MiddlewareChain,\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default mediator implementation.</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>def __init__(\n    self,\n    container: AsyncContainer,\n    middleware_chain: MiddlewareChain,\n    event_publisher: EventPublisher,\n) -&gt; None:\n    self._container = container\n    self._middleware_chain = middleware_chain\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.mediator.impl.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the mediator middleware chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the mediator middleware chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.mediator.impl.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces","title":"interfaces","text":""},{"location":"reference/#waku.mediator.interfaces.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the mediator middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.mediator.interfaces.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the mediator to be handled by multiple handlers.</p>"},{"location":"reference/#waku.mediator.interfaces.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a mediator to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.mediator.interfaces.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares","title":"middlewares","text":""},{"location":"reference/#waku.mediator.middlewares.HandleType","title":"HandleType  <code>module-attribute</code>","text":"<pre><code>HandleType: TypeAlias = Callable[\n    [Request[Any]], Awaitable[Response | None]\n]\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.MiddlewareContext","title":"MiddlewareContext  <code>dataclass</code>","text":"<pre><code>MiddlewareContext(*, container: AsyncContainer)\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.MiddlewareContext.container","title":"container  <code>instance-attribute</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.BaseMiddleware","title":"BaseMiddleware","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/#waku.mediator.middlewares.Middleware","title":"Middleware","text":"<pre><code>Middleware(\n    cls: _MiddlewareFactory[_P],\n    *args: args,\n    **kwargs: kwargs,\n)\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def __init__(\n    self,\n    cls: _MiddlewareFactory[_P],\n    *args: _P.args,\n    **kwargs: _P.kwargs,\n) -&gt; None:\n    self.cls = cls\n    self.args = args\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.Middleware.cls","title":"cls  <code>instance-attribute</code>","text":"<pre><code>cls = cls\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.Middleware.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args = args\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.Middleware.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs = kwargs\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.MiddlewareChain","title":"MiddlewareChain","text":"<pre><code>MiddlewareChain(middlewares: Sequence[Middleware])\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def __init__(self, middlewares: Sequence[Middleware]) -&gt; None:\n    self._middlewares = middlewares\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.MiddlewareChain.wrap","title":"wrap","text":"<pre><code>wrap(\n    container: AsyncContainer, *, handle: HandleType\n) -&gt; HandleType\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def wrap(self, container: AsyncContainer, *, handle: HandleType) -&gt; HandleType:\n    original_handle = handle\n    for cls, args, kwargs in reversed(self._middlewares):\n        middleware = cls(\n            MiddlewareContext(container=container),\n            *args,\n            **kwargs,\n        )\n        handle = functools.update_wrapper(\n            wrapper=functools.partial(middleware.__call__, handle=handle),\n            wrapped=original_handle,\n        )\n    return handle\n</code></pre>"},{"location":"reference/#waku.mediator.modules","title":"modules","text":""},{"location":"reference/#waku.mediator.modules.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    middlewares: Sequence[Middleware] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the mediator pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the mediator interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>middlewares</code> <p>A sequence of middleware classes that will be applied to the mediator pipeline. Middlewares are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[Middleware]</code> </p> Example <pre><code>config = MediatorConfig(\n    mediator_implementation_type=CustomMediator,\n    middlewares=[LoggingMiddleware(), ValidationMiddleware()],\n)\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorConfig.middlewares","title":"middlewares  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Middleware] = ()\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.mediator.modules.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=list(\n            chain(\n                cls._create_mediator_providers(config_),\n                cls._create_middleware_chain_provider(config_),\n            ),\n        ),\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.requests","title":"requests","text":""},{"location":"reference/#waku.mediator.requests.handler","title":"handler","text":""},{"location":"reference/#waku.mediator.requests.handler.RequestHandlerType","title":"RequestHandlerType  <code>module-attribute</code>","text":"<pre><code>RequestHandlerType: TypeAlias = type[\n    RequestHandler[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.mediator.requests.handler.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.mediator.requests.handler.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/mediator/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map","title":"map","text":""},{"location":"reference/#waku.mediator.requests.map.RequestMapRegistry","title":"RequestMapRegistry  <code>module-attribute</code>","text":"<pre><code>RequestMapRegistry: TypeAlias = MutableMapping[\n    type[RequestT], RequestHandlerType[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: RequestMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        msg = f'{request_type.__name__} already exists in registry'\n        raise RequestHandlerAlreadyRegistered(msg, request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap.merge","title":"merge","text":"<pre><code>merge(other: RequestMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.utils","title":"utils","text":""},{"location":"reference/#waku.mediator.utils.get_request_response_type","title":"get_request_response_type  <code>cached</code>","text":"<pre><code>get_request_response_type(\n    request_type: type[Request[ResponseT]],\n) -&gt; type[ResponseT]\n</code></pre> Source code in <code>src/waku/mediator/utils.py</code> <pre><code>@functools.cache\ndef get_request_response_type(request_type: type[Request[ResponseT]]) -&gt; type[ResponseT]:\n    return typing.cast(type[ResponseT], typing.get_args(request_type.__orig_bases__[0])[0])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/#waku.modules","title":"modules","text":""},{"location":"reference/#waku.modules.ModuleType","title":"ModuleType  <code>module-attribute</code>","text":"<pre><code>ModuleType: TypeAlias = 'type[object | HasModuleMetadata]'\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        object | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.modules.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[object | ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.modules.ModuleCompiler","title":"ModuleCompiler","text":""},{"location":"reference/#waku.modules.ModuleCompiler.extract_metadata","title":"extract_metadata","text":"<pre><code>extract_metadata(\n    module_type: ModuleType | DynamicModule,\n) -&gt; tuple[ModuleType, ModuleMetadata]\n</code></pre> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def extract_metadata(self, module_type: ModuleType | DynamicModule) -&gt; tuple[ModuleType, ModuleMetadata]:\n    try:\n        return self._extract_metadata(cast(Hashable, module_type))\n    except AttributeError:\n        msg = f'{type(module_type).__name__} is not module'\n        raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata","title":"ModuleMetadata  <code>dataclass</code>","text":"<pre><code>ModuleMetadata(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        object | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[object | ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.Module","title":"Module","text":"<pre><code>Module(module_type: ModuleType, metadata: ModuleMetadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n    self.distance: Final[int] = sys.maxsize if metadata.is_global else 0\n\n    self.providers: Final[Sequence[BaseProvider]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[object | ModuleType]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Final[UUID] = id\n</code></pre>"},{"location":"reference/#waku.modules.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: Final[ModuleType] = module_type\n</code></pre>"},{"location":"reference/#waku.modules.Module.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Final[int] = maxsize if is_global else 0\n</code></pre>"},{"location":"reference/#waku.modules.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers: Final[Sequence[BaseProvider]] = providers\n</code></pre>"},{"location":"reference/#waku.modules.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports: Final[Sequence[ModuleType | DynamicModule]] = (\n    imports\n)\n</code></pre>"},{"location":"reference/#waku.modules.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports: Final[Sequence[object | ModuleType]] = exports\n</code></pre>"},{"location":"reference/#waku.modules.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Final[Sequence[ModuleExtension]] = extensions\n</code></pre>"},{"location":"reference/#waku.modules.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: Final[bool] = is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry","title":"ModuleRegistry","text":"<pre><code>ModuleRegistry(\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    extensions: list[ModuleExtension],\n    adjacency: dict[UUID, OrderedDict[UUID, str]],\n)\n</code></pre> <p>Immutable registry and graph for module queries, traversal, and lookups.</p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def __init__(\n    self,\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    extensions: list[ModuleExtension],\n    adjacency: dict[UUID, OrderedDict[UUID, str]],\n) -&gt; None:\n    self._compiler = compiler\n    self._root_module = root_module\n    self._modules = modules\n    self._providers = tuple(providers)\n    self._extensions = tuple(extensions)\n    self._adjacency = adjacency\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.root_module","title":"root_module  <code>property</code>","text":"<pre><code>root_module: Module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: tuple[Module, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.providers","title":"providers  <code>property</code>","text":"<pre><code>providers: tuple[BaseProvider, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.compiler","title":"compiler  <code>property</code>","text":"<pre><code>compiler: ModuleCompiler\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get","title":"get","text":"<pre><code>get(module_type: ModuleType | DynamicModule) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get(self, module_type: ModuleType | DynamicModule) -&gt; Module:\n    module_id = self._compiler.extract_metadata(module_type)[1].id\n    return self.get_by_id(module_id)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(module_id: UUID) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get_by_id(self, module_id: UUID) -&gt; Module:\n    module = self._modules.get(module_id)\n    if module is None:\n        msg = f'Module with ID {module_id} is not registered in the graph.'\n        raise KeyError(msg)\n    return module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get_by_type","title":"get_by_type","text":"<pre><code>get_by_type(\n    module_type: ModuleType | DynamicModule,\n) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get_by_type(self, module_type: ModuleType | DynamicModule) -&gt; Module:\n    _, metadata = self._compiler.extract_metadata(module_type)\n    return self._modules[metadata.id]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.traverse","title":"traverse","text":"<pre><code>traverse(from_: Module | None = None) -&gt; Iterator[Module]\n</code></pre> <p>Traverse the module graph in depth-first post-order (children before parent) using a stack.</p> PARAMETER DESCRIPTION <code>from_</code> <p>Start module (default: root)</p> <p> TYPE: <code>Module | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>Module</code> <p>Each traversed module (post-order)</p> <p> TYPE:: <code>Module</code> </p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def traverse(self, from_: Module | None = None) -&gt; Iterator[Module]:\n    \"\"\"Traverse the module graph in depth-first post-order (children before parent) using a stack.\n\n    Args:\n        from_: Start module (default: root)\n\n    Yields:\n        Module: Each traversed module (post-order)\n    \"\"\"\n    start_module = from_ or self._root_module\n    visited: set[UUID] = set()\n    stack: list[tuple[Module, bool]] = [(start_module, False)]\n\n    while stack:\n        module, processed = stack.pop()\n\n        if processed:\n            yield module\n            continue\n\n        if module.id in visited:\n            continue\n\n        visited.add(module.id)\n\n        # Push the current module to process after its children\n        stack.append((module, True))\n\n        # Push children to be processed first (in reverse order to maintain original order in DFS)\n        neighbor_ids = self._adjacency[module.id]\n        for neighbor_id in reversed(neighbor_ids.keys()):\n            if neighbor_id == module.id:\n                continue\n            neighbor = self.get_by_id(neighbor_id)\n            stack.append((neighbor, False))\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.is_global_module","title":"is_global_module","text":"<pre><code>is_global_module(module: Module) -&gt; bool\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def is_global_module(self, module: Module) -&gt; bool:\n    return module.is_global or module == self._root_module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder","title":"ModuleRegistryBuilder","text":"<pre><code>ModuleRegistryBuilder(\n    root_module_type: ModuleType,\n    compiler: ModuleCompiler | None = None,\n)\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def __init__(self, root_module_type: ModuleType, compiler: ModuleCompiler | None = None) -&gt; None:\n    self._compiler: Final = compiler or ModuleCompiler()\n    self._root_module_type: ModuleType = root_module_type\n    self._modules: dict[UUID, Module] = {}\n    self._providers: list[BaseProvider] = []\n    self._extensions: list[ModuleExtension] = []\n    self._adjacency: dict[UUID, OrderedDict[UUID, str]] = defaultdict(OrderedDict)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder.build","title":"build","text":"<pre><code>build() -&gt; ModuleRegistry\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def build(self) -&gt; ModuleRegistry:\n    modules = self._collect_modules()\n    root_module = self._register_modules(modules)\n    return self._build_registry(root_module)\n</code></pre>"},{"location":"reference/#waku.modules.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        object | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[BaseProvider]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[object | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[object | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.testing","title":"testing","text":""},{"location":"reference/#waku.testing.override","title":"override","text":"<pre><code>override(\n    container: AsyncContainer, *providers: BaseProvider\n) -&gt; Iterator[None]\n</code></pre> <p>Temporarily override providers in an AsyncContainer for testing.</p> PARAMETER DESCRIPTION <code>container</code> <p>The container whose providers will be overridden.</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>*providers</code> <p>Providers to override in the container.</p> <p> TYPE: <code>BaseProvider</code> DEFAULT: <code>()</code> </p> YIELDS DESCRIPTION <code>None</code> <p>Context in which the container uses the overridden providers.</p> <p> TYPE:: <code>None</code> </p> Example <pre><code>from waku import WakuFactory, module\nfrom waku.di import Scope, singleton\nfrom waku.testing import override\n\n\nclass Service: ...\n\n\nclass ServiceOverride(Service): ...\n\n\nwith override(application.container, singleton(ServiceOverride, provided_type=Service)):\n    service = await application.container.get(Service)\n    assert isinstance(service, ServiceOverride)\n</code></pre> Source code in <code>src/waku/testing.py</code> <pre><code>@contextmanager\ndef override(container: AsyncContainer, *providers: BaseProvider) -&gt; Iterator[None]:\n    \"\"\"Temporarily override providers in an AsyncContainer for testing.\n\n    Args:\n        container: The container whose providers will be overridden.\n        *providers: Providers to override in the container.\n\n    Yields:\n        None: Context in which the container uses the overridden providers.\n\n    Example:\n        ```python\n        from waku import WakuFactory, module\n        from waku.di import Scope, singleton\n        from waku.testing import override\n\n\n        class Service: ...\n\n\n        class ServiceOverride(Service): ...\n\n\n        with override(application.container, singleton(ServiceOverride, provided_type=Service)):\n            service = await application.container.get(Service)\n            assert isinstance(service, ServiceOverride)\n        ```\n    \"\"\"\n    new_container = make_async_container(\n        _container_provider(container),\n        *providers,\n        context=container._context,  # noqa: SLF001\n    )\n    _swap(container, new_container)\n    yield\n    _swap(new_container, container)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering a contribution to <code>waku</code>! \ud83c\udf89</p> <p>This guide will help you get started and ensure a smooth process.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher</li> <li>uv \u2013 a modern Python package manager</li> <li>Task \u2013 a task runner for automating development workflows (we recommend setting up auto-completion for Task)</li> <li>Git</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Install UV (if not already installed):</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# For other platforms, see:\n# https://docs.astral.sh/uv/getting-started/installation/\n\n# If uv is already installed, ensure it's up to date:\nuv self update\n</code></pre> </li> <li> <p>Install Task (if not already installed):</p> <pre><code># Using the install script\nsh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin\n\n# For other installation options, see:\n# https://taskfile.dev/installation/\n</code></pre> </li> <li> <p>Set up the development environment:</p> <pre><code># Install dependencies and configure pre-commit hooks\ntask install\n</code></pre> <p>Tip: Run <code>task -l</code> after setup to verify everything is working and to see available commands.</p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Fork the repository to your own GitHub account.</li> <li>Clone your fork locally:     <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre></li> <li>Create a new branch for your changes:     <pre><code>git checkout -b feat/your-feature-name\n</code></pre></li> <li>Make your changes, following our code style guidelines.</li> <li>Write or update tests for your changes.</li> <li>Run all checks and ensure tests pass:     <pre><code>task\n</code></pre></li> <li>Commit your changes with clear, descriptive messages.</li> <li>Push to your fork:     <pre><code>git push origin feat/your-feature-name\n</code></pre></li> <li>Open a pull request on GitHub. Link related issues in your PR description (e.g., \"Fixes #123\").</li> <li>Participate in the review process and make any requested changes.</li> </ol>"},{"location":"contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li> Tests added or updated</li> <li> Documentation updated (if needed)</li> <li> Code is formatted and linted</li> <li> All checks pass</li> <li> Type hints added or refined</li> <li> Commit messages include a detailed description for the changelog</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Ensure your changes are thoroughly tested by running the following commands:</p> <pre><code># Run all checks (recommended)\ntask\n\n# Run linters and type checkers\ntask check\n\n# Run specific checks\ntask test         # Run tests only\ntask test:cov     # Run tests with coverage\ntask lint         # Run linters only\ntask format       # Format code\ntask typecheck    # Run type checkers only\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Ruff for linting and formatting</li> <li>MyPy and basedpyright for type checking</li> <li>pre-commit for running checks before commits and pushes</li> </ul> <p>Key style guidelines:</p> <ul> <li>Maximum line length: 120 characters</li> <li>Use explicit type annotations throughout the codebase</li> <li>Follow PEP 8 conventions</li> <li>Write descriptive docstrings using the Google style</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you have questions or need help, you can: - Open a discussion - Open an issue for bugs or feature requests</p>"},{"location":"contributing/#first-time-contributors","title":"First-time Contributors","text":"<ul> <li>Look for issues labeled \"good first issue\" or \"help wanted\".</li> <li>Comment on the issue to let others know you're working on it.</li> <li>Don't hesitate to ask questions if anything is unclear.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Before creating an issue:</p> <ul> <li>Search existing issues to avoid duplicates.</li> <li>Use the appropriate issue template for bug reports or feature requests.</li> <li>Provide as much context as possible (e.g., steps to reproduce, environment details).</li> </ul> <p>Please follow the bug report and feature request templates when submitting issues.</p> <p>We welcome: - Bug reports - Feature requests - Documentation improvements - General questions or ideas</p>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<ul> <li><code>src/</code> \u2013 main source code</li> <li><code>tests/</code> \u2013 test suite</li> <li><code>docs/</code> \u2013 documentation</li> <li><code>Taskfile.yml</code> \u2013 development automation</li> <li><code>README.md</code> \u2013 project overview</li> </ul>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<ul> <li>Use clear, descriptive commit messages.</li> <li>Example: <code>fix(core): handle edge case in dependency resolution</code></li> </ul> <p>Thank you for contributing to <code>waku</code>! \ud83d\ude4f</p>"},{"location":"contributing/docs/","title":"Documentation","text":""},{"location":"contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub or by opening an issue.</p>"},{"location":"contributing/docs/#how-to-get-started","title":"How to get started","text":"<ol> <li>Follow the steps for development setup in the contributing guide</li> <li> <p>Start the local documentation server for live preview of changes     <pre><code>mkdocs serve\n</code></pre></p> </li> <li> <p>Go to the <code>docs/</code> directory and make your changes</p> </li> </ol> <p>After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"examples/mediator/","title":"Mediator (CQRS)","text":"<p>Based on the CQRS pattern, the mediator is used to decouple the command and query logic from the domain model.</p> <p>Implementation heavily inspired by C# MediatR library.</p> <p>For full documentation, visit the Mediator (CQRS) section.</p>"},{"location":"examples/mediator/#code","title":"Code","text":"<pre><code>import asyncio\nimport logging\nfrom collections.abc import AsyncIterator, Callable\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom typing import Any, ParamSpec, TypeVar\nfrom uuid import UUID, uuid4\n\nfrom dishka.integrations.base import wrap_injection\n\nfrom waku import WakuApplication, WakuFactory\nfrom waku.di import AsyncContainer, Injected\nfrom waku.mediator import (\n    IMediator,\n    MediatorConfig,\n    MediatorModule,\n    Request,\n    RequestHandler,\n    Response,\n)\nfrom waku.mediator.contracts.event import Event\nfrom waku.mediator.events.handler import EventHandler\nfrom waku.mediator.middlewares import BaseMiddleware, HandleType, Middleware, MiddlewareContext\nfrom waku.mediator.modules import MediatorExtension\nfrom waku.modules import module\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CreateMeetingResult(Response):\n    meeting_id: UUID\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CreateMeetingCommand(Request[CreateMeetingResult]):\n    user_id: UUID\n\n\n@dataclass(frozen=True, kw_only=True)\nclass MeetingCreatedEvent(Event):\n    user_id: UUID\n    meeting_id: UUID\n\n\nclass CreatingMeetingCommandHandler(RequestHandler[CreateMeetingCommand, CreateMeetingResult]):\n    def __init__(self, mediator: IMediator) -&gt; None:\n        self._mediator = mediator\n\n    async def handle(self, request: CreateMeetingCommand) -&gt; CreateMeetingResult:\n        meeting_id = uuid4()\n        logger.info('new meeting created user_id=%s', request.user_id)\n        await self._mediator.publish(MeetingCreatedEvent(user_id=request.user_id, meeting_id=meeting_id))\n        return CreateMeetingResult(meeting_id=meeting_id)\n\n\nclass MeetingCreatedEventHandler(EventHandler[MeetingCreatedEvent]):\n    async def handle(self, event: MeetingCreatedEvent) -&gt; None:\n        logger.info('meeting created event handled user_id=%s', event.user_id)\n\n\nclass LogMiddleware(BaseMiddleware):\n    def __init__(self, ctx: MiddlewareContext, *, log_level: int = logging.INFO) -&gt; None:\n        self._ctx = ctx\n        self._log_level = log_level\n\n    async def __call__(self, request: Request[Any], handle: HandleType) -&gt; Response | None:\n        logger.log(self._log_level, 'request=%s', request)\n        response = await handle(request)\n        logger.log(self._log_level, 'response=%s', response)\n        return response\n\n\n@asynccontextmanager\nasync def lifespan(_: WakuApplication) -&gt; AsyncIterator[None]:\n    logger.info('Lifespan startup')\n    yield\n    logger.info('Lifespan shutdown')\n\n\n@module(\n    extensions=[\n        (\n            MediatorExtension()\n            .bind_request(CreateMeetingCommand, CreatingMeetingCommandHandler)\n            .bind_event(MeetingCreatedEvent, [MeetingCreatedEventHandler])\n        ),\n    ],\n)\nclass SomeModule:\n    pass\n\n\n@module(\n    imports=[\n        SomeModule,\n        MediatorModule.register(MediatorConfig(middlewares=[Middleware(LogMiddleware)])),\n    ],\n)\nclass AppModule:\n    pass\n\n\n# Simple inject decorator for example purposes\n# In real world you should import `@inject` decorator for your framework from `dishka.integrations.&lt;framework&gt;`\ndef _inject(func: Callable[P, T]) -&gt; Callable[P, T]:\n    return wrap_injection(\n        func=func,\n        is_async=True,\n        container_getter=lambda args, _: args[0],\n    )\n\n\n# Define entrypoints\n# In real world this can be FastAPI routes, etc.\n@_inject\nasync def handler(\n    container: AsyncContainer,  # noqa: ARG001\n    mediator: Injected[IMediator],\n) -&gt; None:\n    command = CreateMeetingCommand(user_id=uuid4())\n    await mediator.send(command)\n\n\n# Run the application\n# In real world this would be run by a 3rd party framework like FastAPI\nasync def main() -&gt; None:\n    app = WakuFactory(AppModule, lifespan=[lifespan]).create()\n\n    async with app, app.container() as request_container:\n        await handler(request_container)  # type: ignore[call-arg]\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/modularity/","title":"Modularity","text":"<p>Example of how to use modules, dynamic modules and linking them together to build an application.</p> <p>For full documentation on modules, visit the Modules section.</p>"},{"location":"examples/modularity/#code","title":"Code","text":"<pre><code>import asyncio\nimport logging\nfrom collections.abc import AsyncIterator, Callable\nfrom contextlib import asynccontextmanager\nfrom typing import ParamSpec, TypeVar\n\nfrom dishka.integrations.base import wrap_injection\n\nfrom waku import WakuApplication\nfrom waku.di import AsyncContainer, Injected, scoped, singleton\nfrom waku.factory import WakuFactory\nfrom waku.modules import DynamicModule, module\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n# Define your providers and modules\nclass ConfigService:\n    def get(self, option: str) -&gt; str:\n        return option\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # You can select providers based on `env` for example\n        logger.info('Loading config for env=%s', env)\n        return DynamicModule(\n            parent_module=cls,\n            providers=[singleton(ConfigService)],\n            exports=[ConfigService],\n        )\n\n\nclass UserService:\n    async def great(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n\n\n@module(\n    providers=[scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n\n\n@module(imports=[UserModule])\nclass IAMModule:\n    pass\n\n\n@module(imports=[UserModule, IAMModule])\nclass AdminModule:\n    pass\n\n\n# Define the application composition root module\n@module(\n    imports=[\n        AdminModule,\n        ConfigModule.register(env='prod'),\n    ],\n    exports=[ConfigModule],\n)\nclass AppModule:\n    pass\n\n\n# Simple inject decorator for example purposes\n# In real world you should import `@inject` decorator for your framework from `dishka.integrations.&lt;framework&gt;`\ndef _inject(func: Callable[P, T]) -&gt; Callable[P, T]:\n    return wrap_injection(\n        func=func,\n        is_async=True,\n        container_getter=lambda args, _: args[0],\n    )\n\n\n# Define entrypoints\n# In real world this can be FastAPI routes, etc.\n@_inject\nasync def handler(\n    container: AsyncContainer,  # noqa: ARG001\n    user_service: Injected[UserService],\n    config_service: Injected[ConfigService],\n) -&gt; None:\n    print(await user_service.great('World'))\n    print(config_service.get('TEST=1'))\n\n\n@asynccontextmanager\nasync def lifespan(_: WakuApplication) -&gt; AsyncIterator[None]:\n    logger.info('Lifespan startup')\n    yield\n    logger.info('Lifespan shutdown')\n\n\n# Create application via factory\ndef bootstrap() -&gt; WakuApplication:\n    return WakuFactory(AppModule, lifespan=[lifespan]).create()\n\n\n# Run the application\n# In real world this would be run by a 3rd party framework like FastAPI\nasync def main() -&gt; None:\n    app = bootstrap()\n    async with app, app.container() as request_container:\n        await handler(request_container)  # type: ignore[call-arg]\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"integrations/asgi/","title":"ASGI Integration","text":"<p><code>waku</code> can be seamlessly integrated into any ASGI application. To achieve this, set up <code>waku</code> as you normally would, then add the <code>ApplicationMiddleware</code> to your ASGI application\u2019s middleware stack.</p>"},{"location":"integrations/asgi/#example-with-fastapi","title":"Example with FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.middleware import Middleware\nfrom waku import WakuApplication\nfrom waku.contrib.asgi import WakuMiddleware\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the FastAPI app with the waku middleware\napp = FastAPI(\n    middleware=[\n        Middleware(WakuMiddleware, application=application),\n    ],\n)\n</code></pre> <p>In this example, the <code>ApplicationMiddleware</code> bridges <code>waku</code> with FastAPI, allowing dependency injection and module management within your ASGI routes.</p>"},{"location":"integrations/litestar/","title":"Litestar Integration","text":"<p><code>waku</code> can be seamlessly integrated with Litestar using the <code>ApplicationPlugin</code>. To do this, set up <code>waku</code> as usual and then include the plugin in your Litestar application configuration.</p>"},{"location":"integrations/litestar/#example","title":"Example","text":"<p>Here\u2019s how to integrate <code>waku</code> with a Litestar application:</p> <pre><code>from litestar import Litestar\nfrom waku import WakuApplication\nfrom waku.contrib.litestar import WakuPlugin\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the Litestar app with the waku plugin\napp = Litestar(plugins=[WakuPlugin(application)])\n</code></pre> <p>In this example, the <code>ApplicationPlugin</code> enables <code>waku</code> dependency injection and module system within your Litestar application.</p>"},{"location":"usage/lifespan/","title":"Lifespan","text":""},{"location":"usage/modules/","title":"Modules","text":"<p><code>waku</code> modularity system is heavily inspired by the NestJS and Tramvai frameworks.</p> <p>The concept of modularity is well-explained with examples in the NestJS documentation.</p>"},{"location":"usage/modules/#module","title":"Module","text":"<p>A module is a class annotated with the <code>@module()</code> decorator. This decorator attaches metadata to the class, which <code>waku</code> uses to construct the application graph.</p> <p>Every <code>waku</code> application has at least one module: the root module, also known as the composition root. This module serves as the starting point for <code>waku</code> to build the entire application graph.</p> Parameter Description <code>providers</code> List of providers for dependency injection <code>imports</code> List of modules imported by this module <code>exports</code> List of types or modules exported by this module <code>extensions</code> List of module extensions for lifecycle hooks <code>is_global</code> Whether this module is global or not <p>The module encapsulates providers by default, meaning you can only inject providers that are either part of the current module or explicitly exported from other imported modules. The exported providers from a module essentially serve as the module's public interface or API.</p> <pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.config.module import ConfigModule\n\n\nclass UsersService:\n    pass\n\n\n@module(\n    providers=[Scoped(UsersService)],  # Register the service with a scoped lifetime\n    imports=[ConfigModule],  # Import another module\n    exports=[UsersService],  # Expose the service to other modules\n)\nclass UsersModule:\n    pass\n\n\n@module(imports=[UsersModule])  # Root module importing UsersModule\nclass AppModule:\n    pass\n</code></pre> <p>Note</p> <p>Encapsulation is enforced by validators, which you can disable at runtime if needed. However, disabling them entirely is not recommended, as they help maintain modularity.</p>"},{"location":"usage/modules/#module-re-exporting","title":"Module Re-exporting","text":"<p>You can re-export a module by including it in the <code>exports</code> list of another module. This is useful for exposing a module\u2019s providers to other modules that import the re-exporting module.</p> <pre><code>@module(\n    imports=[UsersModule],\n    exports=[UsersModule],\n)\nclass IAMModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#global-modules","title":"Global modules","text":"<p>If you need to import the same set of modules across your application, you can mark a module as global. Once a module is global, its providers can be injected anywhere in the application without requiring explicit imports in every module.</p> <p>To make a module global, set the <code>is_global</code> param to <code>True</code> in the <code>@module()</code> decorator.</p> <p>Note</p> <p>Root module are always global.</p> <p>Warning</p> <p>Global modules are not recommended for large applications, as they can lead to tight coupling and make the application harder to maintain.</p> <pre><code>from waku import module\n\n\n@module(is_global=True)\nclass UsersModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#dynamic-module","title":"Dynamic Module","text":"<p>Dynamic modules allow you to create modules dynamically based on conditions, such as the runtime environment of your application.</p> <pre><code>from waku import DynamicModule, module\nfrom waku.di import Scoped\n\n\nclass ConfigService:\n    pass\n\n\nclass DevConfigService(ConfigService):\n    pass\n\n\nclass DefaultConfigService(ConfigService):\n    pass\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # Choose the config provider based on the environment\n        config_provider = DevConfigService if env == 'dev' else DefaultConfigService\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Scoped(config_provider, type_=ConfigService)],  # Register with interface type\n        )\n</code></pre> <p>And then you can use it in any of your modules or in the root module:</p> <pre><code>from waku import module\n\nfrom app.modules.config.module import ConfigModule\n\n\n@module(\n    imports=[\n        ConfigModule.register(env='dev'),\n    ],\n)\nclass AppModule:\n    pass\n</code></pre> <p>You can also make a dynamic module global by setting <code>is_global=True</code> in the <code>DynamicModule</code> constructor.</p> <p>Note</p> <p>While you can use any method name instead of <code>register</code>, we recommend sticking with <code>register</code> for consistency.</p>"},{"location":"usage/providers/","title":"Providers","text":""},{"location":"usage/providers/#introduction","title":"Introduction","text":"<p>Providers are the core of <code>waku</code> dependency injection system. Idea behind a provider is that it can be injected as a dependency into other provider constructors, allowing objects to form various relationships with each other.</p> <p><code>waku</code> responsibility is to \"wire up\" all the providers using DI framework and manage the lifecycle its lifecycle. This way you can focus on writing your application logic.</p>"},{"location":"usage/providers/#dependency-injection","title":"Dependency Injection","text":"<p><code>waku</code> is designed to be modular and extensible. To support this principle, it provides a flexible dependency injection (DI) system that integrates seamlessly with various DI frameworks. <code>waku</code> itself acts like an IoC-container, allowing you to register and resolve dependencies using modules system.</p> <p>Note</p> <p>Instead of relying on a specific DI framework, <code>waku</code> uses an interface called <code>DependencyProvider</code>. This allows you to choose any DI framework you prefer (see Included Dependency Providers) or even create your own provider.</p>"},{"location":"usage/providers/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that addresses the issue of tightly coupled code by decoupling the creation and management of dependencies from the classes that rely on them. In traditional approaches, classes directly instantiate their dependencies, resulting in rigid, hard-to-maintain code. DI solves this problem by enabling dependencies to be supplied externally, typically through mechanisms like constructor or setter injection.</p> <p>By shifting the responsibility of dependency management outside the class, DI promotes loose coupling, allowing classes to focus on their core functionality rather than how dependencies are created. This separation enhances maintainability, testability, and flexibility, as dependencies can be easily swapped or modified without altering the class's code. Ultimately, DI improves system design by reducing interdependencies and making code more modular and scalable.</p> Manual DI Example <pre><code>from abc import ABC, abstractmethod\n\n\n# Use an interface to define contract for clients\n# This allows us injecting different implementations\nclass IClient(ABC):\n    @abstractmethod\n    def request(self, url: str) -&gt; str:\n        pass\n\n\n# Regular implementation\nclass RealClient(IClient):\n    def request(self, url: str) -&gt; str:\n        # Some HTTP requesting logic\n        return f'\"{url}\" call result'\n\n\n# Implementation for tests\nclass MockClient(IClient):\n    def __init__(self, return_data: str) -&gt; None:\n        self._return_data = return_data\n\n    def request(self, url: str) -&gt; str:\n        # Mocked behavior for testing\n        return f'{self._return_data} from \"{url}\"'\n\n\nclass Service:\n    # Accepts any IClient implementation\n    def __init__(self, client: IClient) -&gt; None:\n        self._client = client\n\n    def do_something(self) -&gt; str:\n        return self._client.request('https://example.com')\n\n\n# Usage in regular code\nreal_client = RealClient()\nservice = Service(real_client)\nprint(service.do_something())  # Output: \"https://example.com\" call result\n\n# Usage in tests\nmocked_client = MockClient('mocked data')\nservice = Service(mocked_client)\nprint(service.do_something())  # Output: mocked data from \"https://example.com\"\n</code></pre> <p>Here, a <code>MockClient</code> is injected into <code>Service</code>, making it easy to test <code>Service</code> in isolation without relying on a real client implementation.</p>"},{"location":"usage/providers/#what-is-ioc-container","title":"What is IoC-container?","text":"<p>An IoC container is a framework that automates object creation and dependency management based on the Inversion of Control (IoC) principle. It centralizes the configuration and instantiation of components, reducing tight coupling and simplifying code maintenance. By handling dependency resolution, an IoC container promotes modular, testable, and scalable application design.</p> <p>With power of IoC-container you can leverage all the benefits of DI without manually managing dependencies.</p>"},{"location":"usage/providers/#providers_1","title":"Providers","text":"<p><code>Provider</code> is an object that holds dependency metadata, such as its type, lifetime scope and factory.</p> <p>In <code>waku</code> there are four types of providers, for one for each scope:</p> <ul> <li><code>Transient</code></li> <li><code>Scoped</code></li> <li><code>Singleton</code></li> <li><code>Object</code></li> </ul> <p>Each provider take two arguments:</p> <ul> <li><code>factory</code>: type or callable that returns or yields an instance of the dependency.</li> <li><code>type_</code>: type of the dependency. If not provided, it will be inferred from the factory function's return type.</li> </ul> <p>Note</p> <p><code>Object</code> provider is a special case, it first argument named <code>object</code> instead of a <code>factory</code> because you should pass already instantiated object directly, not a factory function.</p>"},{"location":"usage/providers/#scopes","title":"Scopes","text":"<p><code>waku</code> supports four different lifetime scopes for providers, inspired by the service lifetimes in .NET Core\u2019s DI system.</p>"},{"location":"usage/providers/#transient","title":"Transient","text":"<p>Dependency defined with the <code>Transient</code> provider are created each time they\u2019re requested.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Transient\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Transient(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj_1: Injected[list], obj_2: Injected[list]) -&gt; None:\n    assert obj_1 is not obj_2\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#scoped","title":"Scoped","text":"<p>Dependency defined with the <code>Scoped</code> provider are created once per dependency provider context entrance and disposed when the context exits.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Scoped\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Scoped(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj_1: Injected[list], obj_2: Injected[list]) -&gt; None:\n    assert obj_1 is obj_2\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#singleton","title":"Singleton","text":"<p>Dependency defined with the <code>Singleton</code> provider are created the first time they\u2019re requested and disposed when the application lifecycle ends.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Singleton\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Singleton(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj: Injected[list]) -&gt; list:\n    return obj\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            obj_1 = await handler()\n\n        async with application.container.context():\n            obj_2 = await handler()\n\n        assert obj_1 is obj_2\n\n    # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#object","title":"Object","text":"<p>Dependency defined with the <code>Object</code> provider behave like <code>Singleton</code>, but you must provide the implementation instance directly to the provide and manage its lifecycle manually, outside the IoC-container.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Object\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nsome_object = (1, 2, 3)\n\n\n@module(providers=[Object(some_object, type_=tuple)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj: Injected[tuple]) -&gt; None:\n    assert obj is some_object\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n    # Providers are not disposed at this point automatically\n</code></pre>"},{"location":"usage/providers/#where-and-how-to-inject-dependencies","title":"Where and how to inject dependencies?","text":"<p>To inject dependencies with <code>waku</code> you need:</p> <ol> <li>Register them to <code>providers</code> with desired scope in modules.</li> <li>Identify your application entrypoints and decorate them with <code>@inject</code>.</li> <li>Add dependencies as arguments to your entrypoint signature using <code>Injected</code> type hint.</li> </ol> <pre><code>from waku import module\nfrom waku.di import Injected, inject, Scoped\n\n\nclass Service:\n    def great(self, name: str) -&gt; None:\n        print(f'Hello, {name}!')\n\n\n@module(\n    providers=[Scoped(Service)],\n)\nclass SomeModule:\n    pass\n\n\n@inject\nasync def some_handler(service: Injected[Service]) -&gt; None:\n    service.great('waku')\n</code></pre>"},{"location":"usage/providers/#included-dependency-providers","title":"Included Dependency Providers","text":"<p><code>waku</code> includes out-of-the-box support for several popular DI frameworks through its dependency provider system.</p>"},{"location":"usage/providers/#aioinject","title":"Aioinject","text":"<p><code>waku</code> dependency provider interface is heavily inspired by Aioinject, making it our recommended default choice. Aioinject integrates seamlessly with <code>waku</code> and offers all the necessary features:</p> <ul> <li>Support for all providers scopes (transient, singleton, scoped, object)</li> <li>Container lifecycle management</li> <li>Providers overriding</li> <li>Custom context passing</li> </ul> <p>Available by installing <code>waku</code> with <code>aioinject</code> extra or by directly installing <code>aioinject</code>:</p> uvpip <pre><code>uv add \"waku[aioinject]\"\n# or\nuv add aioinject\n</code></pre> <pre><code>pip install \"waku[aioinject]\"\n# or\npip install aioinject\n</code></pre>"},{"location":"usage/providers/#basic-usage","title":"Basic Usage","text":"<pre><code>from waku import WakuFactory, module\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module()\nclass AppModule:\n    pass\n\n\n# Create application with AioinjectDependencyProvider\napplication = WakuFactory.create(\n    AppModule,\n    dependency_provider=AioinjectDependencyProvider(),\n)\n</code></pre>"},{"location":"usage/providers/#custom-container-configuration","title":"Custom Container Configuration","text":"<p>You can provide your own pre-configured <code>aioinject</code> container:</p> <pre><code>import aioinject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n# Create and configure a custom aioinject container\ncustom_container = aioinject.Container(extensions=[...])\ncustom_container.register(aioinject.Scoped(MyService))  # Example registration\n# ... configure container\n\n# Use the custom container with waku\ndp = AioinjectDependencyProvider(container=custom_container)\n</code></pre>"},{"location":"usage/providers/#dishka","title":"Dishka","text":"<p>Currently not supported but planned.</p>"},{"location":"usage/providers/#writing-custom-dependency-provider","title":"Writing Custom Dependency Provider","text":"<p>To create custom dependency provider you need to implement <code>DependencyProvider</code> interface.</p>"}]}
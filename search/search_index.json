{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"waku","text":"<p> <sup>waku [\u67a0 or \u308f\u304f] means framework in Japanese.</sup> </p> <p> </p> <p> </p> <p> </p> <p></p> <p>waku is a modular, type-safe Python framework for scalable, maintainable applications. Inspired by NestJS, powered by Dishka IoC.</p> <p>[!WARNING] <code>waku</code> is going through a major rewrite, so docs aren't fully up-to-date yet. Stick to this README and our examples for now.</p> <p>For more details, check out our <code>waku</code> deepwiki page.</p>"},{"location":"#why-waku","title":"Why <code>waku</code>?","text":"<ul> <li>\ud83e\udde9 Modular architecture: Group related code with explicit imports/exports for clear boundaries and responsibilities.</li> <li>\ud83d\udc89 First-class Dependency Injection: Built on Dishka with flexible provider patterns (singleton, scoped, transient); swap implementations easily.</li> <li>\ud83d\udce8 Event-driven &amp; CQRS: Handle commands, queries, and events with a comprehensive CQRS implementation, pipeline chains, and centralized processing inspired by MediatR (C#).</li> <li>\ud83d\udd0c Framework-agnostic &amp; Integrations: Works with FastAPI, Litestar, FastStream, Aiogram, and more - no vendor lock-in.</li> <li>\ud83e\uddf0 Extensions &amp; Lifecycle Hooks: Hook into the app lifecycle for logging, validation, and custom logic; precise startup/shutdown management.</li> <li>\ud83d\udee1\ufe0f Production-ready: Type-safe APIs, robust validation, and scalable testing support.</li> </ul>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<ul> <li>\ud83d\udc65 Enterprise development teams building modular, maintainable backend services or microservices</li> <li>\ud83c\udfd7\ufe0f Architects and tech leads seeking a structured framework with clear dependency boundaries and testability</li> <li>\ud83d\udc0d Python developers frustrated with monolithic codebases and looking for better separation of concerns</li> <li>\ud83c\udf0f Engineers from other ecosystems (Java Spring, C# ASP.NET, TypeScript NestJS) wanting familiar patterns in Python</li> <li>\ud83d\udcc8 Projects requiring scalability both in codebase organization and team collaboration</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>uv add waku\n# or\npip install waku\n</code></pre>"},{"location":"#understanding-the-basics","title":"Understanding the Basics","text":"<p>Waku is built around a few core concepts:</p> <ul> <li>\ud83e\udde9 Modules: Classes decorated with <code>@module()</code> that define boundaries for application components and establish clear dependency relationships.</li> <li>\ud83e\uddd1\u200d\ud83d\udd27 Providers: Injectable services and logic registered within modules.</li> <li>\ud83d\udc89 Dependency Injection: Type-safe, flexible wiring powered by Dishka IoC container.</li> <li>\ud83c\udfed WakuFactory: The entry point that creates a <code>WakuApplication</code> instance from your root module.</li> <li>\ud83d\udd04 Application Lifecycle: Initialization and shutdown phases, enhanced with extension hooks.</li> </ul> <p>This structure keeps your code clean and your dependencies explicit.</p> <p><code>waku</code> is framework-agnostic - entrypoints (such as HTTP handlers) are provided by integrations, not the core.</p>"},{"location":"#basic-example","title":"Basic Example","text":"<p>Here's a minimal example showing the core concepts:</p> <pre><code>import asyncio\n\nfrom waku import WakuFactory, module\nfrom waku.di import scoped\n\n\n# 1. Define a provider (service)\nclass GreetingService:\n    async def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n\n\n# 2. Create a module and register the provider\n@module(providers=[scoped(GreetingService)])\nclass GreetingModule:\n    pass\n\n\n# 3. Create a root module that imports other modules\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    # 4. Bootstrap the application with WakuFactory\n    app = WakuFactory(AppModule).create()\n\n    # 5. Use the application with a properly scoped container\n    async with app, app.container() as c:\n        # 6. Resolve and use dependencies\n        svc = await c.get(GreetingService)\n        print(await svc.greet('waku'))\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#more-realistic-example","title":"More Realistic Example","text":"<p>Let's add protocols and module exports:</p> <pre><code>import asyncio\nfrom typing import Protocol\n\nfrom waku import WakuFactory, module\nfrom waku.di import scoped, singleton\n\n\n# Define a protocol for loose coupling\nclass Logger(Protocol):\n    async def log(self, message: str) -&gt; None: ...\n\n\n# Implementation of the logger\nclass ConsoleLogger:\n    async def log(self, message: str) -&gt; None:\n        print(f'[LOG] {message}')\n\n\n# Service that depends on the logger\nclass UserService:\n    def __init__(self, logger: Logger) -&gt; None:\n        self.logger = logger\n\n    async def create_user(self, username: str) -&gt; str:\n        user_id = f'user_{username}'\n        await self.logger.log(f'Created user: {username}')\n        return user_id\n\n\n# Infrastructure module provides core services\n@module(\n    providers=[singleton(ConsoleLogger, provided_type=Logger)],\n    exports=[Logger],  # Export to make available to other modules\n)\nclass InfrastructureModule:\n    pass\n\n\n# Feature module for user management\n@module(\n    imports=[InfrastructureModule],  # Import dependencies from other modules\n    providers=[scoped(UserService)],\n)\nclass UserModule:\n    pass\n\n\n# Application root module\n@module(imports=[UserModule])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    app = WakuFactory(AppModule).create()\n\n    async with app, app.container() as c:\n        user_service = await c.get(UserService)\n        user_id = await user_service.create_user('alice')\n        print(f'Created user with ID: {user_id}')\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Want to learn more? Here's where to go next:</p> <ul> <li>Get familiar with module exports and imports</li> <li>Try different provider scopes</li> <li>Add CQRS for clean command handling</li> <li>Use extension hooks to customize your app</li> <li>Connect with your favorite framework</li> </ul> <p>Check our Getting Started guide and browse the examples directory for inspiration.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>Module System</li> <li>Providers</li> <li>Extensions</li> <li>CQRS</li> <li>API Reference</li> <li>Dishka Documentation</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ul> <li>Contributing Guide</li> <li>Development Setup</li> </ul>"},{"location":"#top-contributors","title":"Top contributors","text":""},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Create logo</li> <li> Improve inner architecture</li> <li> Improve documentation</li> <li> Add new and improve existing validation rules</li> <li> Provide example projects for common architectures</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>RU Telegram group</li> <li>GitHub Issues</li> <li>Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT License.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Dishka \u2013 Dependency Injection framework powering <code>waku</code> IoC container.</li> <li>NestJS \u2013 Primary inspiration for modular architecture, design patterns and some implementation details.</li> <li>MediatR (C#) \u2013 Inspiration and implementation details for the CQRS subsystem.</li> </ul>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#v0210-2025-07-20","title":"v0.21.0 (2025-07-20)","text":""},{"location":"changelog/#-features","title":"\u2728 Features","text":"<ul> <li>Improve providers registration interfaces   (<code>c43f2b8</code>)</li> </ul>"},{"location":"changelog/#v0200-2025-06-11","title":"v0.20.0 (2025-06-11)","text":""},{"location":"changelog/#-features_1","title":"\u2728 Features","text":"<ul> <li>tests: Make overrode container use strict validation   (<code>4089e58</code>)</li> </ul>"},{"location":"changelog/#v0190-2025-06-07","title":"v0.19.0 (2025-06-07)","text":""},{"location":"changelog/#-documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Further improve README   (<code>f4272c6</code>)</p> </li> <li> <p>Improve readme   (<code>4e19320</code>)</p> </li> <li> <p>Update examples and documentation to reflect dishka migration   (<code>3ce62e0</code>)</p> </li> </ul>"},{"location":"changelog/#-features_2","title":"\u2728 Features","text":"<ul> <li>tests: Allow to override not only application container   (<code>0d1f61e</code>)</li> </ul>"},{"location":"changelog/#v0180-2025-05-12","title":"v0.18.0 (2025-05-12)","text":""},{"location":"changelog/#-build-system","title":"\u2699\ufe0f Build System","text":"<ul> <li>Introduce astral-sh <code>ty</code> as additional typechecker   (<code>4eb9758</code>)</li> </ul>"},{"location":"changelog/#-documentation_1","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Fix <code>markdownlint</code> issues in README and CONTRIBUTING files   (<code>cd3821e</code>)</li> </ul>"},{"location":"changelog/#-features_3","title":"\u2728 Features","text":"<ul> <li>ext: Implement extension registry   (<code>6e88840</code>)</li> </ul>"},{"location":"changelog/#v0170-2025-05-11","title":"v0.17.0 (2025-05-11)","text":""},{"location":"changelog/#-features_4","title":"\u2728 Features","text":"<ul> <li>cqrs: Improve cqrs subsystem with pipeline behaviors   (<code>8b84864</code>)</li> </ul>"},{"location":"changelog/#-breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>cqrs: <code>mediator</code> package renamed to <code>cqrs</code></li> </ul>"},{"location":"changelog/#v0160-2025-05-04","title":"v0.16.0 (2025-05-04)","text":""},{"location":"changelog/#-features_5","title":"\u2728 Features","text":"<ul> <li>core: Group all module providers within one dishka provider   (<code>4fa6850</code>)</li> </ul>"},{"location":"changelog/#v0150-2025-05-02","title":"v0.15.0 (2025-05-02)","text":""},{"location":"changelog/#-features_6","title":"\u2728 Features","text":"<ul> <li>validation: Implement proper module re-export validation   (<code>f5e608b</code>)</li> </ul>"},{"location":"changelog/#v0140-2025-04-30","title":"v0.14.0 (2025-04-30)","text":""},{"location":"changelog/#-features_7","title":"\u2728 Features","text":"<ul> <li>validation: Make dependency accessible rule stricter and follow nestjs behaviour   (<code>574c453</code>)</li> </ul>"},{"location":"changelog/#v0130-2025-04-30","title":"v0.13.0 (2025-04-30)","text":""},{"location":"changelog/#-features_8","title":"\u2728 Features","text":"<ul> <li>Implement proper module hooks sorting   (<code>2b2a9de</code>)</li> </ul>"},{"location":"changelog/#v0121-2025-04-29","title":"v0.12.1 (2025-04-29)","text":""},{"location":"changelog/#-performance-improvements","title":"\u26a1 Performance Improvements","text":"<ul> <li>core: Collect module adjacency in one pass   (<code>9ad711d</code>)</li> </ul>"},{"location":"changelog/#v0120-2025-04-28","title":"v0.12.0 (2025-04-28)","text":""},{"location":"changelog/#-features_9","title":"\u2728 Features","text":"<ul> <li>core: Make module traversal post-order dfs   (<code>eb9a760</code>)</li> </ul>"},{"location":"changelog/#v0113-2025-04-28","title":"v0.11.3 (2025-04-28)","text":""},{"location":"changelog/#-bug-fixes","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>core: Move <code>OnModuleConfigure</code> to module definition to prevent duplications on subsequent   calls   (<code>0e6ed00</code>)</li> </ul>"},{"location":"changelog/#v0112-2025-04-28","title":"v0.11.2 (2025-04-28)","text":""},{"location":"changelog/#-bug-fixes_1","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>validation: Fix check for provided types in the current module without explicit export   (<code>a771cbb</code>)</li> </ul>"},{"location":"changelog/#v0111-2025-04-28","title":"v0.11.1 (2025-04-28)","text":""},{"location":"changelog/#-performance-improvements_1","title":"\u26a1 Performance Improvements","text":"<ul> <li>Remove duplications in module registry builder logic   (<code>8527c7d</code>)</li> </ul>"},{"location":"changelog/#v0110-2025-04-28","title":"v0.11.0 (2025-04-28)","text":""},{"location":"changelog/#-documentation_2","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Enhance contributing guide and README   (<code>6e4ddda</code>)</p> </li> <li> <p>Fix issue with mediatr link in readme   (<code>8435d2f</code>)</p> </li> <li> <p>Improve api reference docs generation; document override helper   (<code>48061d0</code>)</p> </li> <li> <p>Improve feature descriptions in README   (<code>2d18bee</code>)</p> </li> <li> <p>Update README for clarity   (<code>efaf3d5</code>)</p> </li> </ul>"},{"location":"changelog/#-features_10","title":"\u2728 Features","text":"<ul> <li>core: Replace ModuleGraph with ModuleRegistry for module management   (<code>f807f0a</code>)</li> </ul>"},{"location":"changelog/#-breaking-changes_1","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>core: All module graph operations now use <code>ModuleRegistry</code>; direct usage of <code>ModuleGraph</code> is   no longer supported. Update custom extensions and validation logic accordingly.</li> </ul>"},{"location":"changelog/#v0100-2025-04-26","title":"v0.10.0 (2025-04-26)","text":""},{"location":"changelog/#-features_11","title":"\u2728 Features","text":"<ul> <li>Re-export di related object from dishka   (<code>820ddc4</code>)</li> </ul>"},{"location":"changelog/#v091-2025-04-26","title":"v0.9.1 (2025-04-26)","text":""},{"location":"changelog/#-performance-improvements_2","title":"\u26a1 Performance Improvements","text":"<ul> <li>Optimize DependenciesAccessible rule   (<code>8eb1ae2</code>)</li> </ul>"},{"location":"changelog/#v090-2025-04-25","title":"v0.9.0 (2025-04-25)","text":""},{"location":"changelog/#-bug-fixes_2","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li> <p>Skip context providers when validation that deps accessible   (<code>12d658e</code>)</p> </li> <li> <p>Trigger release   (<code>2d31df1</code>)</p> </li> </ul>"},{"location":"changelog/#-documentation_3","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Actualize readme file   (<code>1001875</code>)</p> </li> <li> <p>Fix readme formatting   (<code>116e424</code>)</p> </li> </ul>"},{"location":"changelog/#-features_12","title":"\u2728 Features","text":"<ul> <li> <p>Add container override helper to application   (<code>1e2f216</code>)</p> </li> <li> <p>Add di helpers, add testing override helper   (<code>66d7bb5</code>)</p> </li> </ul>"},{"location":"changelog/#v080-2025-04-24","title":"v0.8.0 (2025-04-24)","text":""},{"location":"changelog/#-documentation_4","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Improve readme, add motivation section   (<code>059e5c9</code>)</li> </ul>"},{"location":"changelog/#-features_13","title":"\u2728 Features","text":"<ul> <li>Migrate to dishka as ioc provider   (<code>7296122</code>)</li> </ul>"},{"location":"changelog/#v070-2025-04-13","title":"v0.7.0 (2025-04-13)","text":""},{"location":"changelog/#-features_14","title":"\u2728 Features","text":"<ul> <li>Rename application to waku   (<code>12c9cd8</code>)</li> </ul>"},{"location":"changelog/#v060-2025-03-25","title":"v0.6.0 (2025-03-25)","text":""},{"location":"changelog/#-bug-fixes_3","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Change links to di docs in readme   (<code>0bf7086</code>)</li> </ul>"},{"location":"changelog/#-documentation_5","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Rename development section to contributing (PR#19,   <code>08ec5f5</code>)</p> </li> <li> <p>Rename di section to providers, improve its contents   (PR#111,   <code>f63c936</code>)</p> </li> <li> <p>Slightly reorganize documentation (PR#19,   <code>fe8220a</code>)</p> </li> <li> <p>di: Expand di documentation (PR#111,   <code>887e76f</code>)</p> </li> </ul>"},{"location":"changelog/#-features_15","title":"\u2728 Features","text":"<ul> <li>Add more info to provider validation error messages   (PR#113,   <code>9dced06</code>)</li> </ul>"},{"location":"changelog/#v050-2025-03-23","title":"v0.5.0 (2025-03-23)","text":""},{"location":"changelog/#-documentation_6","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Add basic modules and providers docs   (<code>9ddbc3b</code>)</p> </li> <li> <p>Further improve documentation #19 #94   (<code>3d061b6</code>)</p> </li> </ul>"},{"location":"changelog/#-features_16","title":"\u2728 Features","text":"<ul> <li>mediator: Simplify cqrs handlers registration (#105)   (PR#107,   <code>65fa07d</code>)</li> </ul>"},{"location":"changelog/#v040-2025-03-16","title":"v0.4.0 (2025-03-16)","text":""},{"location":"changelog/#-documentation_7","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Setup mkdocs and improve documentation   (<code>d5166d7</code>)</li> </ul>"},{"location":"changelog/#-features_17","title":"\u2728 Features","text":"<ul> <li>Add ability to pass custom context to dependency provider   (<code>a0e055f</code>)</li> </ul>"},{"location":"changelog/#v031-2025-02-13","title":"v0.3.1 (2025-02-13)","text":""},{"location":"changelog/#-bug-fixes_4","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Do not unwrap generic annotations in <code>collect_dependencies</code>   (<code>c5f1b7c</code>)</li> </ul>"},{"location":"changelog/#v030-2025-02-10","title":"v0.3.0 (2025-02-10)","text":""},{"location":"changelog/#-features_18","title":"\u2728 Features","text":"<ul> <li>Refactor module system   (<code>43a102a</code>)</li> </ul>"},{"location":"changelog/#v020-2025-01-12","title":"v0.2.0 (2025-01-12)","text":""},{"location":"changelog/#-documentation_8","title":"\ud83d\udcd6 Documentation","text":"<ul> <li> <p>Add docstrings to mediator related stuff   (<code>10728c0</code>)</p> </li> <li> <p>Deploy mkdocs to github pages #17   (<code>23872d7</code>)</p> </li> <li> <p>Improve readme and contributing guide   (<code>93529d1</code>)</p> </li> <li> <p>Trigger docs deploy #17   (<code>096876f</code>)</p> </li> <li> <p>Use org bot for pages deploy #17   (<code>dfd1786</code>)</p> </li> </ul>"},{"location":"changelog/#-features_19","title":"\u2728 Features","text":"<ul> <li> <p>Eliminate maps usage in mediator   (<code>16679d7</code>)</p> </li> <li> <p>Refactor mediator extension, add events handling support   (<code>3441375</code>)</p> </li> </ul>"},{"location":"changelog/#v016-2024-12-20","title":"v0.1.6 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_5","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Skip ci in release commit   (<code>9adbc58</code>)</li> </ul>"},{"location":"changelog/#v015-2024-12-20","title":"v0.1.5 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_6","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Remove unused version var from init, run gitlint only for prs   (<code>7a270d4</code>)</li> </ul>"},{"location":"changelog/#v014-2024-12-20","title":"v0.1.4 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_7","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>Attempt to fix contextvar from different context error   (<code>d98c2f8</code>)</li> </ul>"},{"location":"changelog/#v013-2024-12-20","title":"v0.1.3 (2024-12-20)","text":""},{"location":"changelog/#-bug-fixes_8","title":"\ud83e\udeb2 Bug Fixes","text":"<ul> <li>ext: Make mediator middlewares work   (<code>4e4a593</code>)</li> </ul>"},{"location":"changelog/#-build-system_1","title":"\u2699\ufe0f Build System","text":"<ul> <li>Make patch release only for <code>fix</code> &amp;amp;amp;amp; <code>perf</code> tags   (<code>b9cf6bf</code>)</li> </ul>"},{"location":"changelog/#-documentation_9","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Add readme and contributing guide   (<code>32043d7</code>)</li> </ul>"},{"location":"changelog/#v012-2024-12-19","title":"v0.1.2 (2024-12-19)","text":""},{"location":"changelog/#v011-2024-12-19","title":"v0.1.1 (2024-12-19)","text":""},{"location":"changelog/#-features_20","title":"\u2728 Features","text":"<ul> <li>validation: Add ValidationRule protocol, implement DIScopeMismatch   (<code>4cfdd23</code>)</li> </ul>"},{"location":"changelog/#v010-2024-12-18","title":"v0.1.0 (2024-12-18)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#creating-your-first-waku-application","title":"Creating Your First <code>waku</code> Application","text":"<p>Let's create a simple application that demonstrates <code>waku</code> core concepts.</p>"},{"location":"getting-started/#step-1-create-the-basic-structure","title":"Step 1: Create the Basic Structure","text":"<p>Create a new directory for your project and set up your files:</p> <pre><code>project/\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 services.py\n</code></pre>"},{"location":"getting-started/#step-2-define-your-services","title":"Step 2: Define Your Services","text":"<p>In <code>services.py</code>, let's define a simple service:</p> services.py<pre><code>class GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n</code></pre>"},{"location":"getting-started/#step-3-create-modules","title":"Step 3: Create Modules","text":"<p>In <code>app.py</code>, let's define our modules and application setup:</p> app.py<pre><code>import asyncio\n\nfrom waku import WakuApplication, WakuFactory, module\nfrom waku.di import Injected, inject, scoped\n\nfrom project.services import GreetingService\n\n\n# Define a feature module\n@module(\n    providers=[scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n\n\n# Define the root application module\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\n# Define a function that will use our service\n@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n\n\n# Bootstrap the application\ndef bootstrap() -&gt; WakuApplication:\n    return WakuFactory(AppModule).create()\n\n\n# Run the application\nasync def main() -&gt; None:\n    application = bootstrap()\n\n    # Create a context for our application\n    async with application, application.container() as container:\n        # Use our service\n        message = await greet_user()  # type: ignore[call-arg]\n        print(message)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-4-run-your-application","title":"Step 4: Run Your Application","text":"<p>Run the application with:</p> <pre><code>python app.py\n</code></pre> <p>You should see the output:</p> <pre><code>Hello, waku!\n</code></pre>"},{"location":"getting-started/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what's happening in our simple application:</p>"},{"location":"getting-started/#modules","title":"Modules","text":"<p>Modules are the building blocks of a <code>waku</code> application. Each module encapsulates a specific feature or functionality.</p> <pre><code>@module(\n    providers=[scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre> <p>In this example:</p> <ul> <li><code>providers</code> defines which providers this module creates and manages</li> <li><code>exports</code> makes these providers (or imported modules) available to other modules that import this one</li> <li><code>scoped</code> indicates this provider should be created once for every container context entrance.</li> </ul> <p>Info</p> <p>For more information on providers and scopes, see Providers.</p>"},{"location":"getting-started/#application-bootstrap","title":"Application Bootstrap","text":"<p>The application is created using a <code>WakuFactory</code>:</p> <pre><code>def bootstrap() -&gt; WakuApplication:\n    return WakuFactory(AppModule).create()\n</code></pre> <p>This creates an application instance with <code>AppModule</code> as the root module.</p>"},{"location":"getting-started/#dependency-injection","title":"Dependency Injection","text":"<p>Providers are injected into functions using the @inject decorator:</p> <pre><code>@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n</code></pre> <p>The <code>Injected[GreetingService]</code> type annotation tells <code>waku</code> which provider to inject.</p>"},{"location":"getting-started/#context-management","title":"Context Management","text":"<p><code>waku</code> uses context managers to manage the lifecycle of your application and its providers:</p> <pre><code>async with application, application.container() as container:\n    message = await greet_user()\n</code></pre> <p>In real applications, you would typically use this context managers in <code>lifespan</code> of your framework.</p>"},{"location":"getting-started/#creating-a-more-realistic-application","title":"Creating a More Realistic Application","text":"<p>Let's extend our example to demonstrate a more realistic scenario with multiple modules and configuration.</p>"},{"location":"getting-started/#step-1-enhanced-structure","title":"Step 1: Enhanced Structure","text":"<p>Create a more complete project structure:</p> <pre><code>app/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __main__.py\n\u251c\u2500\u2500 application.py\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 greetings/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 services.py\n\u2502   \u2502   \u2514\u2500\u2500 module.py\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 services.py\n\u2502       \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 settings.py\n</code></pre>"},{"location":"getting-started/#step-2-add-configuration-module","title":"Step 2: Add Configuration Module","text":"<p>Define an application settings class and configuration module for providing settings object to your application:</p> app/settings.py<pre><code>from dataclasses import dataclass\nfrom typing import Literal\n\nfrom waku import DynamicModule, module\nfrom waku.di import Object\n\nEnvironment = Literal['dev', 'prod']\n\n\n# You may consider using `pydantic-settings` or similar libs for settings management\n@dataclass(kw_only=True)\nclass AppSettings:\n    environment: Environment\n    debug: bool\n\n\n@module(is_global=True)\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: Environment) -&gt; DynamicModule:\n        settings = AppSettings(\n            environment=env,\n            debug=env == 'dev',\n        )\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Object(settings)],\n        )\n</code></pre>"},{"location":"getting-started/#step-3-creating-modules","title":"Step 3: Creating Modules","text":""},{"location":"getting-started/#greeting-module","title":"Greeting Module","text":"app/modules/greetings/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Greeting:\n    language: str\n    template: str\n</code></pre> app/modules/greetings/services.py<pre><code>from app.config import AppConfig\nfrom app.modules.greetings.models import Greeting\n\n\nclass GreetingService:\n    def __init__(self, config: AppConfig) -&gt; None:\n        self.config = config\n        self.greetings: dict[str, Greeting] = {\n            'en': Greeting(language='en', template='Hello, {}!'),\n            'es': Greeting(language='es', template='\u00a1Hola, {}!'),\n            'fr': Greeting(language='fr', template='Bonjour, {}!'),\n        }\n\n    def get_greeting(self, language: str = 'en') -&gt; Greeting:\n        # If in debug mode and language not found, return default\n        if self.config.debug and language not in self.greetings:\n            return self.greetings['en']\n        return self.greetings.get(language, self.greetings['en'])\n\n    def greet(self, name: str, language: str = 'en') -&gt; str:\n        greeting = self.get_greeting(language)\n        return greeting.template.format(name)\n\n    def available_languages(self) -&gt; list[str]:\n        return list(self.greetings.keys())\n</code></pre> app/modules/greetings/module.py<pre><code>from waku import module\nfrom waku.di import Singleton\n\nfrom app.modules.greetings.services import GreetingService\n\n\n@module(\n    providers=[Singleton(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre>"},{"location":"getting-started/#user-module","title":"User Module","text":"app/modules/users/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: str\n    name: str\n    preferred_language: str = 'en'\n</code></pre> app/modules/users/services.py<pre><code>from app.modules.users.models import User\n\n\nclass UserService:\n    def __init__(self) -&gt; None:\n        # Mock database\n        self.users: dict[str, User] = {\n            '1': User(id='1', name='Alice', preferred_language='en'),\n            '2': User(id='2', name='Bob', preferred_language='fr'),\n            '3': User(id='3', name='Carlos', preferred_language='es'),\n        }\n\n    def get_user(self, user_id: str) -&gt; User | None:\n        return self.users.get(user_id)\n</code></pre> app/modules/users/module.py<pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.users.services import UserService\n\n\n@module(\n    providers=[Scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n</code></pre>"},{"location":"getting-started/#step-4-create-the-application-module","title":"Step 4: Create the Application Module","text":"<p>Define the application module and bootstrap function for initializing your application:</p> app/application.py<pre><code>from waku import WakuApplication, WakuFactory, module\n\nfrom app.settings import ConfigModule\nfrom app.greetings.module import GreetingModule\nfrom app.users.module import UserModule\n\n\n@module(\n    # Import all top-level modules\n    imports=[\n        ConfigModule.register(env='dev'),\n        GreetingModule,\n        UserModule,\n    ],\n)\nclass AppModule:\n    pass\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    return WakuFactory(AppModule).create()\n</code></pre>"},{"location":"getting-started/#step-5-create-the-main-entrypoint","title":"Step 5: Create the Main Entrypoint","text":"<p>In real world scenarios, you would use a framework like FastAPI, Flask, etc. for defining your entry points, also known as handlers. For the sake of simplicity, we don't use any framework in this example.</p> app/__main__.py<pre><code>import asyncio\n\nfrom waku.di import Injected, inject\n\nfrom app.application import bootstrap_application\nfrom app.modules.users.services import UserService\nfrom app.modules.greetings.services import GreetingService\n\n\n@inject\nasync def greet_user_by_id(\n    user_id: str,\n    user_service: Injected[UserService],\n    greeting_service: Injected[GreetingService],\n) -&gt; str:\n    user = user_service.get_user(user_id)\n    if not user:\n        return f'User {user_id} not found'\n\n    return greeting_service.greet(name=user.name, language=user.preferred_language)\n\n\nasync def main() -&gt; None:\n    application = bootstrap_application()\n\n    async with application, application.container() as container:\n        # Greet different users\n        for user_id in ['1', '2', '3', '4']:  # '4' doesn't exist\n            greeting = await greet_user_by_id(user_id)  # type: ignore[call-arg]\n            print(greeting)\n\n        # Get service directly for demonstration\n        greeting_service = await container.get(GreetingService)\n        print(f'Available languages: {greeting_service.available_languages()}')\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-6-run-your-application","title":"Step 6: Run Your Application","text":"<pre><code>python -m app\n</code></pre> <p>Expected output:</p> <pre><code>Hello, Alice!\nBonjour, Bob!\n\u00a1Hola, Carlos!\nUser 4 not found\nAvailable languages: ['en', 'es', 'fr']\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of <code>waku</code>, you can:</p> <ol> <li>Explore more advanced features like Mediator (CQRS)</li> <li>Learn about Extensions for adding functionality to your application</li> <li>Integrate with web frameworks like FastAPI</li> <li>Understand Module System in depth</li> <li>Explore Dependency Injection techniques</li> </ol> <p><code>waku</code> modular architecture allows your application to grow while maintaining clear separation of concerns and a clean, maintainable codebase.</p> <p>Note</p> <p>This guide is a starting point. It's highly recommended to read The Software Architecture Chronicles by Herberto Gra\u00e7a. He distills all popular software architectural styles into a single one to rule them all. It's a great read and will help you understand the principles behind <code>waku</code>.</p> <p>Happy coding with <code>waku</code>!</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#waku","title":"waku","text":""},{"location":"reference/#waku.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extension_registry = extension_registry\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.WakuApplication.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def close(self) -&gt; None:\n    if not self._initialized:\n        return\n    await self._call_on_shutdown_extensions()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n</code></pre>"},{"location":"reference/#waku.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(self) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(self._root_module_type).build()\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extension_registry=self._build_extension_registry(registry.modules),\n    )\n</code></pre>"},{"location":"reference/#waku.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.Module","title":"Module","text":"<pre><code>Module(module_type: ModuleType, metadata: ModuleMetadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n\n    self.providers: Final[Sequence[BaseProvider]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[type[object] | ModuleType | DynamicModule]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n</code></pre>"},{"location":"reference/#waku.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Final[UUID] = id\n</code></pre>"},{"location":"reference/#waku.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: Final[ModuleType] = module_type\n</code></pre>"},{"location":"reference/#waku.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers: Final[Sequence[BaseProvider]] = providers\n</code></pre>"},{"location":"reference/#waku.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports: Final[Sequence[ModuleType | DynamicModule]] = (\n    imports\n)\n</code></pre>"},{"location":"reference/#waku.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports: Final[\n    Sequence[type[object] | ModuleType | DynamicModule]\n] = exports\n</code></pre>"},{"location":"reference/#waku.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Final[Sequence[ModuleExtension]] = extensions\n</code></pre>"},{"location":"reference/#waku.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: Final[bool] = is_global\n</code></pre>"},{"location":"reference/#waku.Module.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/#waku.Module.provider","title":"provider  <code>cached</code> <code>property</code>","text":"<pre><code>provider: BaseProvider\n</code></pre>"},{"location":"reference/#waku.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        type[object] | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[BaseProvider]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[type[object] | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[type[object] | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.application","title":"application","text":""},{"location":"reference/#waku.application.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extension_registry: ExtensionRegistry,\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extension_registry = extension_registry\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def close(self) -&gt; None:\n    if not self._initialized:\n        return\n    await self._call_on_shutdown_extensions()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.cqrs","title":"cqrs","text":""},{"location":"reference/#waku.cqrs.NextHandlerType","title":"NextHandlerType  <code>module-attribute</code>","text":"<pre><code>NextHandlerType: TypeAlias = Callable[\n    [RequestT], Awaitable[ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for events.</p>"},{"location":"reference/#waku.cqrs.IPipelineBehavior","title":"IPipelineBehavior","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Interface for pipeline behaviors that wrap request handling.</p>"},{"location":"reference/#waku.cqrs.IPipelineBehavior.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(\n    request: RequestT,\n    next_handler: NextHandlerType[RequestT, ResponseT],\n) -&gt; ResponseT\n</code></pre> <p>Handle the request and call the next handler in the pipeline.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to handle</p> <p> TYPE: <code>RequestT</code> </p> <code>next_handler</code> <p>Function to call the next handler in the pipeline</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The response from the pipeline</p> Source code in <code>src/waku/cqrs/contracts/pipeline.py</code> <pre><code>@abstractmethod\nasync def handle(self, request: RequestT, next_handler: NextHandlerType[RequestT, ResponseT]) -&gt; ResponseT:\n    \"\"\"Handle the request and call the next handler in the pipeline.\n\n    Args:\n        request: The request to handle\n        next_handler: Function to call the next handler in the pipeline\n\n    Returns:\n        The response from the pipeline\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.cqrs.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.cqrs.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventT]</code></p> <p>The event handler interface.</p> <p>Usage::</p> <p>class UserJoinedEventHandler(EventHandler[UserJoinedEvent])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, event: UserJoinedEvent) -&gt; None:\n      await self._meetings_api.notify_room(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"reference/#waku.cqrs.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: EventT) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: EventT) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default CQRS implementation.</p> <p>Initialize the mediator.</p> PARAMETER DESCRIPTION <code>container</code> <p>Container used to resolve handlers and behaviors</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>event_publisher</code> <p>Function to publish events to handlers</p> <p> TYPE: <code>EventPublisher</code> </p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>def __init__(self, container: AsyncContainer, event_publisher: EventPublisher) -&gt; None:\n    \"\"\"Initialize the mediator.\n\n    Args:\n        container: Container used to resolve handlers and behaviors\n        event_publisher: Function to publish events to handlers\n    \"\"\"\n    self._container = container\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the CQRS pipeline chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the CQRS pipeline chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.cqrs.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a cqrs to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.cqrs.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the cqrs to be handled by multiple handlers.</p>"},{"location":"reference/#waku.cqrs.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the cqrs middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.cqrs.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    pipeline_behaviors: Sequence[\n        type[IPipelineBehavior[Any, Any]]\n    ] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the cqrs pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the cqrs interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>pipeline_behaviors</code> <p>A sequence of pipeline behavior configurations that will be applied to the cqrs pipeline. Behaviors are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[IPipelineBehavior[Any, Any]]]</code> </p> Example <pre><code>config = MediatorConfig(\n    pipeline_behaviors=[\n        LoggingBehavior,\n        ValidationBehavior,\n    ]\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.pipeline_behaviors","title":"pipeline_behaviors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pipeline_behaviors: Sequence[\n    type[IPipelineBehavior[Any, Any]]\n] = ()\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n    self._behavior_map = PipelineBehaviourMap()\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[\n        type[IPipelineBehavior[RequestT, ResponseT]]\n    ]\n    | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, ResponseT]]] | None = None,\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    if behaviors:\n        self._behavior_map.bind(request_type, behaviors)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n            self._create_pipeline_behavior_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.cqrs.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=[\n            *cls._create_mediator_providers(config_),\n            *cls._create_pipeline_behavior_providers(config_),\n        ],\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: RequestMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        raise RequestHandlerAlreadyRegistered(request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap.merge","title":"merge","text":"<pre><code>merge(other: RequestMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts","title":"contracts","text":""},{"location":"reference/#waku.cqrs.contracts.event","title":"event","text":""},{"location":"reference/#waku.cqrs.contracts.event.EventT","title":"EventT  <code>module-attribute</code>","text":"<pre><code>EventT = TypeVar(\n    'EventT', bound='Event', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.event.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for events.</p>"},{"location":"reference/#waku.cqrs.contracts.pipeline","title":"pipeline","text":""},{"location":"reference/#waku.cqrs.contracts.pipeline.NextHandlerType","title":"NextHandlerType  <code>module-attribute</code>","text":"<pre><code>NextHandlerType: TypeAlias = Callable[\n    [RequestT], Awaitable[ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.pipeline.IPipelineBehavior","title":"IPipelineBehavior","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Interface for pipeline behaviors that wrap request handling.</p>"},{"location":"reference/#waku.cqrs.contracts.pipeline.IPipelineBehavior.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(\n    request: RequestT,\n    next_handler: NextHandlerType[RequestT, ResponseT],\n) -&gt; ResponseT\n</code></pre> <p>Handle the request and call the next handler in the pipeline.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to handle</p> <p> TYPE: <code>RequestT</code> </p> <code>next_handler</code> <p>Function to call the next handler in the pipeline</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The response from the pipeline</p> Source code in <code>src/waku/cqrs/contracts/pipeline.py</code> <pre><code>@abstractmethod\nasync def handle(self, request: RequestT, next_handler: NextHandlerType[RequestT, ResponseT]) -&gt; ResponseT:\n    \"\"\"Handle the request and call the next handler in the pipeline.\n\n    Args:\n        request: The request to handle\n        next_handler: Function to call the next handler in the pipeline\n\n    Returns:\n        The response from the pipeline\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request","title":"request","text":""},{"location":"reference/#waku.cqrs.contracts.request.RequestT","title":"RequestT  <code>module-attribute</code>","text":"<pre><code>RequestT = TypeVar(\n    'RequestT', bound='Request[Any]', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.ResponseT","title":"ResponseT  <code>module-attribute</code>","text":"<pre><code>ResponseT = TypeVar(\n    'ResponseT',\n    bound='Response | None',\n    default=None,\n    covariant=True,\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.cqrs.contracts.request.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.cqrs.events","title":"events","text":""},{"location":"reference/#waku.cqrs.events.handler","title":"handler","text":""},{"location":"reference/#waku.cqrs.events.handler.EventHandlerType","title":"EventHandlerType  <code>module-attribute</code>","text":"<pre><code>EventHandlerType: TypeAlias = type[EventHandler[EventT]]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.handler.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventT]</code></p> <p>The event handler interface.</p> <p>Usage::</p> <p>class UserJoinedEventHandler(EventHandler[UserJoinedEvent])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, event: UserJoinedEvent) -&gt; None:\n      await self._meetings_api.notify_room(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"reference/#waku.cqrs.events.handler.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: EventT) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: EventT) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map","title":"map","text":""},{"location":"reference/#waku.cqrs.events.map.EventMapRegistry","title":"EventMapRegistry  <code>module-attribute</code>","text":"<pre><code>EventMapRegistry: TypeAlias = MutableMapping[\n    type[EventT], list[EventHandlerType[EventT]]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap","title":"EventMap","text":"<pre><code>EventMap()\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: EventMapRegistry[Any] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: EventMapRegistry[Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.bind","title":"bind","text":"<pre><code>bind(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def bind(self, event_type: type[EventT], handler_types: list[EventHandlerType[EventT]]) -&gt; Self:\n    for handler_type in handler_types:\n        if handler_type in self._registry[event_type]:\n            raise EventHandlerAlreadyRegistered(event_type, handler_type)\n        self._registry[event_type].append(handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.merge","title":"merge","text":"<pre><code>merge(other: EventMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def merge(self, other: EventMap) -&gt; Self:\n    for event_type, handlers in other.registry.items():\n        self.bind(event_type, handlers)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.events.publish","title":"publish","text":""},{"location":"reference/#waku.cqrs.events.publish.EventPublisher","title":"EventPublisher","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.cqrs.events.publish.SequentialEventPublisher","title":"SequentialEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.events.publish.GroupEventPublisher","title":"GroupEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.cqrs.exceptions.MediatorError","title":"MediatorError","text":"<p>               Bases: <code>WakuError</code></p> <p>Base exception for all cqrs-related errors.</p>"},{"location":"reference/#waku.cqrs.exceptions.ImproperlyConfiguredError","title":"ImproperlyConfiguredError","text":"<p>               Bases: <code>MediatorError</code></p> <p>Raised when cqrs configuration is invalid.</p>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered","title":"RequestHandlerAlreadyRegistered","text":"<pre><code>RequestHandlerAlreadyRegistered(\n    request_type: type[Request[Any]],\n    handler_type: RequestHandlerType[Any, Any],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a request handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[Request[Any]], handler_type: RequestHandlerType[Any, Any]) -&gt; None:\n    self.request_type = request_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerNotFound","title":"RequestHandlerNotFound","text":"<pre><code>RequestHandlerNotFound(request_type: type[Request[Any]])\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when a request handler is not found.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[Request[Any]]) -&gt; None:\n    self.request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerNotFound.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered","title":"EventHandlerAlreadyRegistered","text":"<pre><code>EventHandlerAlreadyRegistered(\n    event_type: type[EventT],\n    handler_type: EventHandlerType[EventT],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when an event handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, event_type: type[EventT], handler_type: EventHandlerType[EventT]) -&gt; None:\n    self.event_type = event_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type = event_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerNotFound","title":"EventHandlerNotFound","text":"<pre><code>EventHandlerNotFound(event_type: type[Event])\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when an event handler is not found.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, event_type: type[Event]) -&gt; None:\n    self.event_type = event_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerNotFound.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type = event_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered","title":"PipelineBehaviorAlreadyRegistered","text":"<pre><code>PipelineBehaviorAlreadyRegistered(\n    request_type: type[Request],\n    behavior_type: type[IPipelineBehavior[Any, Any]],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a pipeline behavior is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> <code>behavior_type</code> <p>The type of behavior that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[Request], behavior_type: type[IPipelineBehavior[Any, Any]]) -&gt; None:\n    self.request_type = request_type\n    self.behavior_type = behavior_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered.behavior_type","title":"behavior_type  <code>instance-attribute</code>","text":"<pre><code>behavior_type = behavior_type\n</code></pre>"},{"location":"reference/#waku.cqrs.impl","title":"impl","text":""},{"location":"reference/#waku.cqrs.impl.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default CQRS implementation.</p> <p>Initialize the mediator.</p> PARAMETER DESCRIPTION <code>container</code> <p>Container used to resolve handlers and behaviors</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>event_publisher</code> <p>Function to publish events to handlers</p> <p> TYPE: <code>EventPublisher</code> </p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>def __init__(self, container: AsyncContainer, event_publisher: EventPublisher) -&gt; None:\n    \"\"\"Initialize the mediator.\n\n    Args:\n        container: Container used to resolve handlers and behaviors\n        event_publisher: Function to publish events to handlers\n    \"\"\"\n    self._container = container\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.cqrs.impl.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the CQRS pipeline chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the CQRS pipeline chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.cqrs.impl.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces","title":"interfaces","text":""},{"location":"reference/#waku.cqrs.interfaces.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the cqrs middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.cqrs.interfaces.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the cqrs to be handled by multiple handlers.</p>"},{"location":"reference/#waku.cqrs.interfaces.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a cqrs to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.cqrs.interfaces.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.modules","title":"modules","text":""},{"location":"reference/#waku.cqrs.modules.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    pipeline_behaviors: Sequence[\n        type[IPipelineBehavior[Any, Any]]\n    ] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the cqrs pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the cqrs interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>pipeline_behaviors</code> <p>A sequence of pipeline behavior configurations that will be applied to the cqrs pipeline. Behaviors are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[IPipelineBehavior[Any, Any]]]</code> </p> Example <pre><code>config = MediatorConfig(\n    pipeline_behaviors=[\n        LoggingBehavior,\n        ValidationBehavior,\n    ]\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.pipeline_behaviors","title":"pipeline_behaviors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pipeline_behaviors: Sequence[\n    type[IPipelineBehavior[Any, Any]]\n] = ()\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.cqrs.modules.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=[\n            *cls._create_mediator_providers(config_),\n            *cls._create_pipeline_behavior_providers(config_),\n        ],\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n    self._behavior_map = PipelineBehaviourMap()\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[\n        type[IPipelineBehavior[RequestT, ResponseT]]\n    ]\n    | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, ResponseT]]] | None = None,\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    if behaviors:\n        self._behavior_map.bind(request_type, behaviors)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n            self._create_pipeline_behavior_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline","title":"pipeline","text":""},{"location":"reference/#waku.cqrs.pipeline.PipelineBehaviorWrapper","title":"PipelineBehaviorWrapper","text":"<pre><code>PipelineBehaviorWrapper(\n    behaviors: Sequence[\n        IPipelineBehavior[RequestT, ResponseT]\n    ],\n)\n</code></pre> <p>               Bases: <code>Generic[RequestT, ResponseT]</code></p> <p>Composes pipeline behaviors into a processing chain.</p> <p>Initialize the pipeline behavior chain.</p> PARAMETER DESCRIPTION <code>behaviors</code> <p>Sequence of pipeline behaviors to execute in order</p> <p> TYPE: <code>Sequence[IPipelineBehavior[RequestT, ResponseT]]</code> </p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def __init__(self, behaviors: Sequence[IPipelineBehavior[RequestT, ResponseT]]) -&gt; None:\n    \"\"\"Initialize the pipeline behavior chain.\n\n    Args:\n        behaviors: Sequence of pipeline behaviors to execute in order\n    \"\"\"\n    self._behaviors = list(behaviors)  # Convert to list immediately\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.PipelineBehaviorWrapper.wrap","title":"wrap","text":"<pre><code>wrap(\n    handle: NextHandlerType[RequestT, ResponseT],\n) -&gt; NextHandlerType[RequestT, ResponseT]\n</code></pre> <p>Create a pipeline that wraps the handler function with behaviors.</p> <p>Pipeline behaviors are executed in the order they are provided.</p> PARAMETER DESCRIPTION <code>handle</code> <p>The handler function to wrap with behaviors</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>NextHandlerType[RequestT, ResponseT]</code> <p>A function that executes the entire pipeline</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def wrap(self, handle: NextHandlerType[RequestT, ResponseT]) -&gt; NextHandlerType[RequestT, ResponseT]:\n    \"\"\"Create a pipeline that wraps the handler function with behaviors.\n\n    Pipeline behaviors are executed in the order they are provided.\n\n    Args:\n        handle: The handler function to wrap with behaviors\n\n    Returns:\n        A function that executes the entire pipeline\n    \"\"\"\n    for behavior in reversed(self._behaviors):\n        handle = functools.partial(behavior.handle, next_handler=handle)\n\n    return handle\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.chain","title":"chain","text":""},{"location":"reference/#waku.cqrs.pipeline.chain.PipelineBehaviorWrapper","title":"PipelineBehaviorWrapper","text":"<pre><code>PipelineBehaviorWrapper(\n    behaviors: Sequence[\n        IPipelineBehavior[RequestT, ResponseT]\n    ],\n)\n</code></pre> <p>               Bases: <code>Generic[RequestT, ResponseT]</code></p> <p>Composes pipeline behaviors into a processing chain.</p> <p>Initialize the pipeline behavior chain.</p> PARAMETER DESCRIPTION <code>behaviors</code> <p>Sequence of pipeline behaviors to execute in order</p> <p> TYPE: <code>Sequence[IPipelineBehavior[RequestT, ResponseT]]</code> </p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def __init__(self, behaviors: Sequence[IPipelineBehavior[RequestT, ResponseT]]) -&gt; None:\n    \"\"\"Initialize the pipeline behavior chain.\n\n    Args:\n        behaviors: Sequence of pipeline behaviors to execute in order\n    \"\"\"\n    self._behaviors = list(behaviors)  # Convert to list immediately\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.chain.PipelineBehaviorWrapper.wrap","title":"wrap","text":"<pre><code>wrap(\n    handle: NextHandlerType[RequestT, ResponseT],\n) -&gt; NextHandlerType[RequestT, ResponseT]\n</code></pre> <p>Create a pipeline that wraps the handler function with behaviors.</p> <p>Pipeline behaviors are executed in the order they are provided.</p> PARAMETER DESCRIPTION <code>handle</code> <p>The handler function to wrap with behaviors</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>NextHandlerType[RequestT, ResponseT]</code> <p>A function that executes the entire pipeline</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def wrap(self, handle: NextHandlerType[RequestT, ResponseT]) -&gt; NextHandlerType[RequestT, ResponseT]:\n    \"\"\"Create a pipeline that wraps the handler function with behaviors.\n\n    Pipeline behaviors are executed in the order they are provided.\n\n    Args:\n        handle: The handler function to wrap with behaviors\n\n    Returns:\n        A function that executes the entire pipeline\n    \"\"\"\n    for behavior in reversed(self._behaviors):\n        handle = functools.partial(behavior.handle, next_handler=handle)\n\n    return handle\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map","title":"map","text":""},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMapRegistry","title":"PipelineBehaviorMapRegistry  <code>module-attribute</code>","text":"<pre><code>PipelineBehaviorMapRegistry = MutableMapping[\n    type[RequestT],\n    list[type[IPipelineBehavior[RequestT, ResponseT]]],\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap","title":"PipelineBehaviourMap","text":"<pre><code>PipelineBehaviourMap()\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: PipelineBehaviorMapRegistry[Any, Any] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: PipelineBehaviorMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    behavior_types: list[\n        type[IPipelineBehavior[RequestT, ResponseT]]\n    ],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def bind(\n    self,\n    request_type: type[RequestT],\n    behavior_types: list[type[IPipelineBehavior[RequestT, ResponseT]]],\n) -&gt; Self:\n    for behavior_type in behavior_types:\n        if behavior_type in self._registry[request_type]:\n            raise PipelineBehaviorAlreadyRegistered(request_type, behavior_type)\n        self._registry[request_type].append(behavior_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap.merge","title":"merge","text":"<pre><code>merge(other: PipelineBehaviourMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def merge(self, other: PipelineBehaviourMap) -&gt; Self:\n    for event_type, handlers in other.registry.items():\n        self.bind(event_type, handlers)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.requests","title":"requests","text":""},{"location":"reference/#waku.cqrs.requests.handler","title":"handler","text":""},{"location":"reference/#waku.cqrs.requests.handler.RequestHandlerType","title":"RequestHandlerType  <code>module-attribute</code>","text":"<pre><code>RequestHandlerType: TypeAlias = type[\n    RequestHandler[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map","title":"map","text":""},{"location":"reference/#waku.cqrs.requests.map.RequestMapRegistry","title":"RequestMapRegistry  <code>module-attribute</code>","text":"<pre><code>RequestMapRegistry: TypeAlias = MutableMapping[\n    type[RequestT], RequestHandlerType[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: RequestMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        raise RequestHandlerAlreadyRegistered(request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.merge","title":"merge","text":"<pre><code>merge(other: RequestMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.utils","title":"utils","text":""},{"location":"reference/#waku.cqrs.utils.get_request_response_type","title":"get_request_response_type  <code>cached</code>","text":"<pre><code>get_request_response_type(\n    request_type: type[Request[ResponseT]],\n) -&gt; type[ResponseT]\n</code></pre> Source code in <code>src/waku/cqrs/utils.py</code> <pre><code>@functools.cache\ndef get_request_response_type(request_type: type[Request[ResponseT]]) -&gt; type[ResponseT]:\n    return typing.cast(type[ResponseT], typing.get_args(get_original_bases(request_type)[0])[0])\n</code></pre>"},{"location":"reference/#waku.di","title":"di","text":""},{"location":"reference/#waku.di.contextual","title":"contextual","text":"<pre><code>contextual(\n    provided_type: Any, *, scope: Scope = REQUEST\n) -&gt; Provider\n</code></pre> <p>Provide a dependency from the current context (e.g., app/request).</p> PARAMETER DESCRIPTION <code>provided_type</code> <p>The type to resolve from context.</p> <p> TYPE: <code>Any</code> </p> <code>scope</code> <p>Scope of the context variable (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Contextual provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def contextual(provided_type: Any, *, scope: Scope = Scope.REQUEST) -&gt; Provider:\n    \"\"\"Provide a dependency from the current context (e.g., app/request).\n\n    Args:\n        provided_type: The type to resolve from context.\n        scope: Scope of the context variable (default: Scope.REQUEST).\n\n    Returns:\n        Provider: Contextual provider instance.\n    \"\"\"\n    provider_ = Provider()\n    provider_.from_context(provided_type, scope=scope)\n    return provider_\n</code></pre>"},{"location":"reference/#waku.di.many","title":"many","text":"<pre><code>many(\n    interface: Any,\n    *implementations: Any,\n    scope: Scope = REQUEST,\n    cache: bool = True,\n) -&gt; Provider\n</code></pre> <p>Register multiple implementations as a collection.</p> PARAMETER DESCRIPTION <code>interface</code> <p>Interface type for the collection.</p> <p> TYPE: <code>Any</code> </p> <code>*implementations</code> <p>Implementation types to include in collection.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>scope</code> <p>Scope of the collection (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> <code>cache</code> <p>Whether to cache the resolve results within scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Collection provider instance.</p> <p> TYPE: <code>Provider</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If no implementations are provided.</p> <p>Examples:</p> <p>many(IPipelineBehavior[Any, Any], ValidationBehavior, LoggingBehavior) many(IEventHandler[UserCreated], EmailHandler, AuditHandler, scope=Scope.APP)</p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def many(\n    interface: Any,\n    *implementations: Any,\n    scope: Scope = Scope.REQUEST,\n    cache: bool = True,\n) -&gt; Provider:\n    \"\"\"Register multiple implementations as a collection.\n\n    Args:\n        interface: Interface type for the collection.\n        *implementations: Implementation types to include in collection.\n        scope: Scope of the collection (default: Scope.REQUEST).\n        cache: Whether to cache the resolve results within scope.\n\n    Returns:\n        Provider: Collection provider instance.\n\n    Raises:\n        ValueError: If no implementations are provided.\n\n    Examples:\n        many(IPipelineBehavior[Any, Any], ValidationBehavior, LoggingBehavior)\n        many(IEventHandler[UserCreated], EmailHandler, AuditHandler, scope=Scope.APP)\n    \"\"\"\n    if not implementations:\n        msg = 'At least one implementation must be provided'\n        raise ValueError(msg)\n\n    provider_ = Provider(scope=scope)\n    provider_.provide_all(*implementations, cache=cache)\n\n    provider_.provide(\n        lambda: [],  # noqa: PIE807\n        provides=list[interface],\n        cache=cache,\n    )\n    provider_.alias(list[interface], provides=Sequence[interface], cache=cache)\n\n    for cls in implementations:\n\n        @provider_.decorate\n        def _(many_: list[interface], one: cls) -&gt; list[interface]:  # type: ignore[valid-type]\n            return [*many_, one]\n\n    return provider_\n</code></pre>"},{"location":"reference/#waku.di.object_","title":"object_","text":"<pre><code>object_(\n    obj: Any, *, provided_type: Any | None = None\n) -&gt; Provider\n</code></pre> <p>Provide the exact object passed at creation time as a singleton dependency.</p> <p>The provider always returns the same object instance, without instantiation or copying.</p> PARAMETER DESCRIPTION <code>obj</code> <p>The instance to provide as-is.</p> <p> TYPE: <code>Any</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Provider that always returns the given object.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def object_(obj: Any, *, provided_type: Any | None = None) -&gt; Provider:\n    \"\"\"Provide the exact object passed at creation time as a singleton dependency.\n\n    The provider always returns the same object instance, without instantiation or copying.\n\n    Args:\n        obj: The instance to provide as-is.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Provider that always returns the given object.\n    \"\"\"\n    return provider(lambda: obj, scope=Scope.APP, provided_type=provided_type, cache=True)\n</code></pre>"},{"location":"reference/#waku.di.provider","title":"provider","text":"<pre><code>provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = REQUEST,\n    provided_type: Any | None = None,\n    cache: bool = True,\n) -&gt; Provider\n</code></pre> <p>Create a Dishka provider for a callable or type.</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>scope</code> <p>Scope of the dependency (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any | None</code> DEFAULT: <code>None</code> </p> <code>cache</code> <p>Whether to cache the instance in the scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Configured provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = Scope.REQUEST,\n    provided_type: Any | None = None,\n    cache: bool = True,\n) -&gt; Provider:\n    \"\"\"Create a Dishka provider for a callable or type.\n\n    Args:\n        source: Callable or type to provide as a dependency.\n        scope: Scope of the dependency (default: Scope.REQUEST).\n        provided_type: Explicit type to provide (default: inferred).\n        cache: Whether to cache the instance in the scope.\n\n    Returns:\n        Provider: Configured provider instance.\n    \"\"\"\n    provider_ = Provider(scope=scope)\n    provider_.provide(source, provides=provided_type, cache=cache)\n    return provider_\n</code></pre>"},{"location":"reference/#waku.di.scoped","title":"scoped","text":"<pre><code>scoped(source: type[_T] | Callable[..., _T]) -&gt; Provider\n</code></pre><pre><code>scoped(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n) -&gt; Provider\n</code></pre> <pre><code>scoped(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any]\n    | Callable[..., Any]\n    | None = None,\n) -&gt; Provider\n</code></pre> <p>Create a scoped provider (lifetime: request).</p> PARAMETER DESCRIPTION <code>interface_or_source</code> <p>Interface type or source if no separate implementation.</p> <p> TYPE: <code>type[Any] | Callable[..., Any]</code> </p> <code>implementation</code> <p>Implementation type if interface is provided.</p> <p> TYPE: <code>type[Any] | Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Scoped provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def scoped(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any] | Callable[..., Any] | None = None,\n    /,\n) -&gt; Provider:\n    \"\"\"Create a scoped provider (lifetime: request).\n\n    Args:\n        interface_or_source: Interface type or source if no separate implementation.\n        implementation: Implementation type if interface is provided.\n\n    Returns:\n        Provider: Scoped provider instance.\n    \"\"\"\n    if implementation is not None:\n        return provider(implementation, scope=Scope.REQUEST, provided_type=interface_or_source)\n    return provider(interface_or_source, scope=Scope.REQUEST)\n</code></pre>"},{"location":"reference/#waku.di.singleton","title":"singleton","text":"<pre><code>singleton(source: type[_T] | Callable[..., _T]) -&gt; Provider\n</code></pre><pre><code>singleton(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n) -&gt; Provider\n</code></pre> <pre><code>singleton(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any]\n    | Callable[..., Any]\n    | None = None,\n) -&gt; Provider\n</code></pre> <p>Create a singleton provider (lifetime: app).</p> PARAMETER DESCRIPTION <code>interface_or_source</code> <p>Interface type or source if no separate implementation.</p> <p> TYPE: <code>type[Any] | Callable[..., Any]</code> </p> <code>implementation</code> <p>Implementation type if interface is provided.</p> <p> TYPE: <code>type[Any] | Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Singleton provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def singleton(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any] | Callable[..., Any] | None = None,\n    /,\n) -&gt; Provider:\n    \"\"\"Create a singleton provider (lifetime: app).\n\n    Args:\n        interface_or_source: Interface type or source if no separate implementation.\n        implementation: Implementation type if interface is provided.\n\n    Returns:\n        Provider: Singleton provider instance.\n    \"\"\"\n    if implementation is not None:\n        return provider(implementation, scope=Scope.APP, provided_type=interface_or_source)\n    return provider(interface_or_source, scope=Scope.APP)\n</code></pre>"},{"location":"reference/#waku.di.transient","title":"transient","text":"<pre><code>transient(source: type[_T] | Callable[..., _T]) -&gt; Provider\n</code></pre><pre><code>transient(\n    interface: Any,\n    implementation: type[_T] | Callable[..., _T],\n) -&gt; Provider\n</code></pre> <pre><code>transient(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any]\n    | Callable[..., Any]\n    | None = None,\n) -&gt; Provider\n</code></pre> <p>Create a transient provider (new instance per injection).</p> PARAMETER DESCRIPTION <code>interface_or_source</code> <p>Interface type or source if no separate implementation.</p> <p> TYPE: <code>type[Any] | Callable[..., Any]</code> </p> <code>implementation</code> <p>Implementation type if interface is provided.</p> <p> TYPE: <code>type[Any] | Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Transient provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def transient(\n    interface_or_source: type[Any] | Callable[..., Any],\n    implementation: type[Any] | Callable[..., Any] | None = None,\n    /,\n) -&gt; Provider:\n    \"\"\"Create a transient provider (new instance per injection).\n\n    Args:\n        interface_or_source: Interface type or source if no separate implementation.\n        implementation: Implementation type if interface is provided.\n\n    Returns:\n        Provider: Transient provider instance.\n    \"\"\"\n    if implementation is not None:\n        return provider(implementation, scope=Scope.REQUEST, provided_type=interface_or_source, cache=False)\n    return provider(interface_or_source, scope=Scope.REQUEST, cache=False)\n</code></pre>"},{"location":"reference/#waku.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.exceptions.WakuError","title":"WakuError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/#waku.extensions","title":"extensions","text":""},{"location":"reference/#waku.extensions.ApplicationExtension","title":"ApplicationExtension  <code>module-attribute</code>","text":"<pre><code>ApplicationExtension: TypeAlias = (\n    OnApplicationInit\n    | AfterApplicationInit\n    | OnApplicationShutdown\n)\n</code></pre>"},{"location":"reference/#waku.extensions.ModuleExtension","title":"ModuleExtension  <code>module-attribute</code>","text":"<pre><code>ModuleExtension: TypeAlias = (\n    OnModuleConfigure | OnModuleInit | OnModuleDestroy\n)\n</code></pre>"},{"location":"reference/#waku.extensions.DEFAULT_EXTENSIONS","title":"DEFAULT_EXTENSIONS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EXTENSIONS: Sequence[ApplicationExtension] = (\n    ValidationExtension(\n        [DependenciesAccessibleRule()], strict=True\n    ),\n)\n</code></pre>"},{"location":"reference/#waku.extensions.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions after application initialization.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions after application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.OnApplicationShutdown","title":"OnApplicationShutdown","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application shutdown actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationShutdown.on_app_shutdown","title":"on_app_shutdown  <code>async</code>","text":"<pre><code>on_app_shutdown(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions before application shutdown.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_shutdown(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions before application shutdown.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleConfigure","title":"OnModuleConfigure","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module configuration.</p>"},{"location":"reference/#waku.extensions.OnModuleConfigure.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> <p>Perform actions before module metadata transformed to module.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    \"\"\"Perform actions before module metadata transformed to module.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleDestroy","title":"OnModuleDestroy","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module destroying.</p>"},{"location":"reference/#waku.extensions.OnModuleDestroy.on_module_destroy","title":"on_module_destroy  <code>async</code>","text":"<pre><code>on_module_destroy(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application shutdown.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_destroy(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application shutdown.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry","title":"ExtensionRegistry","text":"<pre><code>ExtensionRegistry()\n</code></pre> <p>Registry for extensions.</p> <p>This registry maintains references to all extensions in the application, allowing for centralized management and discovery.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._app_extensions: dict[type[ApplicationExtension], list[ApplicationExtension]] = defaultdict(list)\n    self._module_extensions: dict[ModuleType, list[ModuleExtension]] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.register_application_extension","title":"register_application_extension","text":"<pre><code>register_application_extension(\n    extension: ApplicationExtension,\n) -&gt; Self\n</code></pre> <p>Register an application extension with optional priority and tags.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_application_extension(self, extension: ApplicationExtension) -&gt; Self:\n    \"\"\"Register an application extension with optional priority and tags.\"\"\"\n    ext_type = type(extension)\n    extension_bases = [\n        base\n        for base in inspect.getmro(ext_type)\n        if (isinstance(base, ApplicationExtension) and base != ext_type)  # type: ignore[unreachable]\n    ]\n    for base in extension_bases:\n        self._app_extensions[cast(type[ApplicationExtension], base)].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.register_module_extension","title":"register_module_extension","text":"<pre><code>register_module_extension(\n    module_type: ModuleType, extension: ModuleExtension\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_module_extension(self, module_type: ModuleType, extension: ModuleExtension) -&gt; Self:\n    self._module_extensions[module_type].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.get_application_extensions","title":"get_application_extensions","text":"<pre><code>get_application_extensions(\n    extension_type: type[_AppExtT],\n) -&gt; list[_AppExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_application_extensions(self, extension_type: type[_AppExtT]) -&gt; list[_AppExtT]:\n    return cast(list[_AppExtT], self._app_extensions.get(cast(type[ApplicationExtension], extension_type), []))\n</code></pre>"},{"location":"reference/#waku.extensions.ExtensionRegistry.get_module_extensions","title":"get_module_extensions","text":"<pre><code>get_module_extensions(\n    module_type: ModuleType, extension_type: type[_ModExtT]\n) -&gt; list[_ModExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_module_extensions(self, module_type: ModuleType, extension_type: type[_ModExtT]) -&gt; list[_ModExtT]:\n    extensions = cast(list[_ModExtT], self._module_extensions.get(module_type, []))\n    return [ext for ext in extensions if isinstance(ext, extension_type)]\n</code></pre>"},{"location":"reference/#waku.extensions.protocols","title":"protocols","text":"<p>Extension protocols for application and module lifecycle hooks.</p>"},{"location":"reference/#waku.extensions.protocols.ApplicationExtension","title":"ApplicationExtension  <code>module-attribute</code>","text":"<pre><code>ApplicationExtension: TypeAlias = (\n    OnApplicationInit\n    | AfterApplicationInit\n    | OnApplicationShutdown\n)\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.ModuleExtension","title":"ModuleExtension  <code>module-attribute</code>","text":"<pre><code>ModuleExtension: TypeAlias = (\n    OnModuleConfigure | OnModuleInit | OnModuleDestroy\n)\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.protocols.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.protocols.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions after application initialization.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions after application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnApplicationShutdown","title":"OnApplicationShutdown","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application shutdown actions.</p>"},{"location":"reference/#waku.extensions.protocols.OnApplicationShutdown.on_app_shutdown","title":"on_app_shutdown  <code>async</code>","text":"<pre><code>on_app_shutdown(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions before application shutdown.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_app_shutdown(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions before application shutdown.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnModuleConfigure","title":"OnModuleConfigure","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module configuration.</p>"},{"location":"reference/#waku.extensions.protocols.OnModuleConfigure.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> <p>Perform actions before module metadata transformed to module.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    \"\"\"Perform actions before module metadata transformed to module.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.protocols.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.protocols.OnModuleDestroy","title":"OnModuleDestroy","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module destroying.</p>"},{"location":"reference/#waku.extensions.protocols.OnModuleDestroy.on_module_destroy","title":"on_module_destroy  <code>async</code>","text":"<pre><code>on_module_destroy(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application shutdown.</p> Source code in <code>src/waku/extensions/protocols.py</code> <pre><code>async def on_module_destroy(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application shutdown.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.registry","title":"registry","text":"<p>Extension registry for centralized management of extensions.</p>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry","title":"ExtensionRegistry","text":"<pre><code>ExtensionRegistry()\n</code></pre> <p>Registry for extensions.</p> <p>This registry maintains references to all extensions in the application, allowing for centralized management and discovery.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._app_extensions: dict[type[ApplicationExtension], list[ApplicationExtension]] = defaultdict(list)\n    self._module_extensions: dict[ModuleType, list[ModuleExtension]] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.register_application_extension","title":"register_application_extension","text":"<pre><code>register_application_extension(\n    extension: ApplicationExtension,\n) -&gt; Self\n</code></pre> <p>Register an application extension with optional priority and tags.</p> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_application_extension(self, extension: ApplicationExtension) -&gt; Self:\n    \"\"\"Register an application extension with optional priority and tags.\"\"\"\n    ext_type = type(extension)\n    extension_bases = [\n        base\n        for base in inspect.getmro(ext_type)\n        if (isinstance(base, ApplicationExtension) and base != ext_type)  # type: ignore[unreachable]\n    ]\n    for base in extension_bases:\n        self._app_extensions[cast(type[ApplicationExtension], base)].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.register_module_extension","title":"register_module_extension","text":"<pre><code>register_module_extension(\n    module_type: ModuleType, extension: ModuleExtension\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def register_module_extension(self, module_type: ModuleType, extension: ModuleExtension) -&gt; Self:\n    self._module_extensions[module_type].append(extension)\n    return self\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.get_application_extensions","title":"get_application_extensions","text":"<pre><code>get_application_extensions(\n    extension_type: type[_AppExtT],\n) -&gt; list[_AppExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_application_extensions(self, extension_type: type[_AppExtT]) -&gt; list[_AppExtT]:\n    return cast(list[_AppExtT], self._app_extensions.get(cast(type[ApplicationExtension], extension_type), []))\n</code></pre>"},{"location":"reference/#waku.extensions.registry.ExtensionRegistry.get_module_extensions","title":"get_module_extensions","text":"<pre><code>get_module_extensions(\n    module_type: ModuleType, extension_type: type[_ModExtT]\n) -&gt; list[_ModExtT]\n</code></pre> Source code in <code>src/waku/extensions/registry.py</code> <pre><code>def get_module_extensions(self, module_type: ModuleType, extension_type: type[_ModExtT]) -&gt; list[_ModExtT]:\n    extensions = cast(list[_ModExtT], self._module_extensions.get(module_type, []))\n    return [ext for ext in extensions if isinstance(ext, extension_type)]\n</code></pre>"},{"location":"reference/#waku.factory","title":"factory","text":""},{"location":"reference/#waku.factory.ContainerConfig","title":"ContainerConfig  <code>dataclass</code>","text":"<pre><code>ContainerConfig(\n    *,\n    lock_factory: _LockFactory = Lock,\n    start_scope: Scope | None = None,\n    skip_validation: bool = False,\n)\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.lock_factory","title":"lock_factory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lock_factory: _LockFactory = Lock\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.start_scope","title":"start_scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_scope: Scope | None = None\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.skip_validation","title":"skip_validation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>skip_validation: bool = False\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(self) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(self._root_module_type).build()\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extension_registry=self._build_extension_registry(registry.modules),\n    )\n</code></pre>"},{"location":"reference/#waku.lifespan","title":"lifespan","text":""},{"location":"reference/#waku.lifespan.LifespanFunc","title":"LifespanFunc  <code>module-attribute</code>","text":"<pre><code>LifespanFunc: TypeAlias = (\n    Callable[\n        ['WakuApplication'],\n        AbstractAsyncContextManager[None],\n    ]\n    | AbstractAsyncContextManager[None]\n)\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper","title":"LifespanWrapper","text":"<pre><code>LifespanWrapper(lifespan_func: LifespanFunc)\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>def __init__(self, lifespan_func: LifespanFunc) -&gt; None:\n    self._lifespan_func = lifespan_func\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app: WakuApplication) -&gt; AsyncIterator[None]\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: WakuApplication) -&gt; AsyncIterator[None]:\n    ctx_manager = (\n        self._lifespan_func\n        if isinstance(self._lifespan_func, AbstractAsyncContextManager)\n        else self._lifespan_func(app)\n    )\n    async with ctx_manager:\n        yield\n</code></pre>"},{"location":"reference/#waku.modules","title":"modules","text":""},{"location":"reference/#waku.modules.ModuleType","title":"ModuleType  <code>module-attribute</code>","text":"<pre><code>ModuleType: TypeAlias = type[object | HasModuleMetadata]\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.modules.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.modules.HasModuleMetadata","title":"HasModuleMetadata","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.modules.ModuleCompiler","title":"ModuleCompiler","text":""},{"location":"reference/#waku.modules.ModuleCompiler.extract_metadata","title":"extract_metadata","text":"<pre><code>extract_metadata(\n    module_type: ModuleType | DynamicModule,\n) -&gt; tuple[ModuleType, ModuleMetadata]\n</code></pre> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def extract_metadata(self, module_type: ModuleType | DynamicModule) -&gt; tuple[ModuleType, ModuleMetadata]:\n    try:\n        return self._extract_metadata(cast(Hashable, module_type))\n    except AttributeError:\n        msg = f'{type(module_type).__name__} is not module'\n        raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata","title":"ModuleMetadata  <code>dataclass</code>","text":"<pre><code>ModuleMetadata(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.Module","title":"Module","text":"<pre><code>Module(module_type: ModuleType, metadata: ModuleMetadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n\n    self.providers: Final[Sequence[BaseProvider]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[type[object] | ModuleType | DynamicModule]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Final[UUID] = id\n</code></pre>"},{"location":"reference/#waku.modules.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: Final[ModuleType] = module_type\n</code></pre>"},{"location":"reference/#waku.modules.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers: Final[Sequence[BaseProvider]] = providers\n</code></pre>"},{"location":"reference/#waku.modules.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports: Final[Sequence[ModuleType | DynamicModule]] = (\n    imports\n)\n</code></pre>"},{"location":"reference/#waku.modules.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports: Final[\n    Sequence[type[object] | ModuleType | DynamicModule]\n] = exports\n</code></pre>"},{"location":"reference/#waku.modules.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Final[Sequence[ModuleExtension]] = extensions\n</code></pre>"},{"location":"reference/#waku.modules.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: Final[bool] = is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/#waku.modules.Module.provider","title":"provider  <code>cached</code> <code>property</code>","text":"<pre><code>provider: BaseProvider\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry","title":"ModuleRegistry","text":"<pre><code>ModuleRegistry(\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    adjacency: AdjacencyMatrix,\n)\n</code></pre> <p>Immutable registry and graph for module queries, traversal, and lookups.</p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def __init__(\n    self,\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    adjacency: AdjacencyMatrix,\n) -&gt; None:\n    self._compiler = compiler\n    self._root_module = root_module\n    self._modules = modules\n    self._providers = tuple(providers)\n    self._adjacency = adjacency\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.root_module","title":"root_module  <code>property</code>","text":"<pre><code>root_module: Module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: tuple[Module, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.providers","title":"providers  <code>property</code>","text":"<pre><code>providers: tuple[BaseProvider, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.compiler","title":"compiler  <code>property</code>","text":"<pre><code>compiler: ModuleCompiler\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get","title":"get","text":"<pre><code>get(module_type: ModuleType | DynamicModule) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get(self, module_type: ModuleType | DynamicModule) -&gt; Module:\n    module_id = self.compiler.extract_metadata(module_type)[1].id\n    return self.get_by_id(module_id)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(module_id: UUID) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get_by_id(self, module_id: UUID) -&gt; Module:\n    module = self._modules.get(module_id)\n    if module is None:\n        msg = f'Module with ID {module_id} is not registered in the graph.'\n        raise KeyError(msg)\n    return module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.traverse","title":"traverse","text":"<pre><code>traverse(from_: Module | None = None) -&gt; Iterator[Module]\n</code></pre> <p>Traverse the module graph in depth-first post-order (children before parent) recursively.</p> PARAMETER DESCRIPTION <code>from_</code> <p>Start module (default: root)</p> <p> TYPE: <code>Module | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>Module</code> <p>Each traversed module (post-order)</p> <p> TYPE:: <code>Module</code> </p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def traverse(self, from_: Module | None = None) -&gt; Iterator[Module]:\n    \"\"\"Traverse the module graph in depth-first post-order (children before parent) recursively.\n\n    Args:\n        from_: Start module (default: root)\n\n    Yields:\n        Module: Each traversed module (post-order)\n    \"\"\"\n    start_module = from_ or self._root_module\n    visited: set[UUID] = set()\n\n    def _dfs(module: Module) -&gt; Iterator[Module]:\n        if module.id in visited:\n            return\n\n        visited.add(module.id)\n\n        # Process children first (maintain original order)\n        neighbor_ids = self._adjacency[module.id]\n        for neighbor_id in neighbor_ids:\n            if neighbor_id == module.id:\n                continue\n            neighbor = self.get_by_id(neighbor_id)\n            yield from _dfs(neighbor)\n\n        # Process current module after children (post-order)\n        yield module\n\n    yield from _dfs(start_module)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder","title":"ModuleRegistryBuilder","text":"<pre><code>ModuleRegistryBuilder(\n    root_module_type: ModuleType,\n    compiler: ModuleCompiler | None = None,\n)\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def __init__(self, root_module_type: ModuleType, compiler: ModuleCompiler | None = None) -&gt; None:\n    self._compiler: Final = compiler or ModuleCompiler()\n    self._root_module_type: Final = root_module_type\n    self._modules: dict[UUID, Module] = {}\n    self._providers: list[BaseProvider] = []\n\n    self._metadata_cache: dict[ModuleType | DynamicModule, tuple[ModuleType, ModuleMetadata]] = {}\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder.build","title":"build","text":"<pre><code>build() -&gt; ModuleRegistry\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def build(self) -&gt; ModuleRegistry:\n    modules, adjacency = self._collect_modules()\n    root_module = self._register_modules(modules)\n    return self._build_registry(root_module, adjacency)\n</code></pre>"},{"location":"reference/#waku.modules.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        type[object] | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[BaseProvider]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[type[object] | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[type[object] | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.testing","title":"testing","text":""},{"location":"reference/#waku.testing.override","title":"override","text":"<pre><code>override(\n    container: AsyncContainer, *providers: BaseProvider\n) -&gt; Iterator[None]\n</code></pre> <p>Temporarily override providers in an AsyncContainer for testing.</p> PARAMETER DESCRIPTION <code>container</code> <p>The container whose providers will be overridden.</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>*providers</code> <p>Providers to override in the container.</p> <p> TYPE: <code>BaseProvider</code> DEFAULT: <code>()</code> </p> YIELDS DESCRIPTION <code>None</code> <p>Context in which the container uses the overridden providers.</p> <p> TYPE:: <code>None</code> </p> Example <pre><code>from waku import WakuFactory, module\nfrom waku.di import Scope, singleton\nfrom waku.testing import override\n\n\nclass Service: ...\n\n\nclass ServiceOverride(Service): ...\n\n\nwith override(application.container, singleton(ServiceOverride, provided_type=Service)):\n    service = await application.container.get(Service)\n    assert isinstance(service, ServiceOverride)\n</code></pre> Source code in <code>src/waku/testing.py</code> <pre><code>@contextmanager\ndef override(container: AsyncContainer, *providers: BaseProvider) -&gt; Iterator[None]:\n    \"\"\"Temporarily override providers in an AsyncContainer for testing.\n\n    Args:\n        container: The container whose providers will be overridden.\n        *providers: Providers to override in the container.\n\n    Yields:\n        None: Context in which the container uses the overridden providers.\n\n    Example:\n        ```python\n        from waku import WakuFactory, module\n        from waku.di import Scope, singleton\n        from waku.testing import override\n\n\n        class Service: ...\n\n\n        class ServiceOverride(Service): ...\n\n\n        with override(application.container, singleton(ServiceOverride, provided_type=Service)):\n            service = await application.container.get(Service)\n            assert isinstance(service, ServiceOverride)\n        ```\n    \"\"\"\n    for provider in providers:\n        for factory in chain(provider.factories, provider.aliases):\n            cast(_Overrideable, factory).override = True\n\n    new_container = make_async_container(\n        _container_provider(container),\n        *providers,\n        context=container._context,  # noqa: SLF001\n        start_scope=container.scope,\n        validation_settings=STRICT_VALIDATION,\n    )\n\n    _swap(container, new_container)\n    yield\n    _swap(new_container, container)\n</code></pre>"},{"location":"reference/#waku.validation","title":"validation","text":""},{"location":"reference/#waku.validation.ValidationRule","title":"ValidationRule","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.validation.ValidationRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/validation/_abc.py</code> <pre><code>def validate(self, context: ValidationContext) -&gt; list[ValidationError]: ...\n</code></pre>"},{"location":"reference/#waku.validation.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>WakuError</code></p>"},{"location":"reference/#waku.validation.ValidationExtension","title":"ValidationExtension","text":"<pre><code>ValidationExtension(\n    rules: Sequence[ValidationRule], *, strict: bool = True\n)\n</code></pre> <p>               Bases: <code>AfterApplicationInit</code></p> Source code in <code>src/waku/validation/_extension.py</code> <pre><code>def __init__(self, rules: Sequence[ValidationRule], *, strict: bool = True) -&gt; None:\n    self.rules = rules\n    self.strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.validation.ValidationExtension.rules","title":"rules  <code>instance-attribute</code>","text":"<pre><code>rules = rules\n</code></pre>"},{"location":"reference/#waku.validation.ValidationExtension.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.validation.ValidationExtension.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/validation/_extension.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    context = ValidationContext(app=app)\n\n    errors_chain = chain.from_iterable(rule.validate(context) for rule in self.rules)\n    if errors := list(errors_chain):\n        self._raise(errors)\n</code></pre>"},{"location":"reference/#waku.validation.rules","title":"rules","text":""},{"location":"reference/#waku.validation.rules.DependenciesAccessibleRule","title":"DependenciesAccessibleRule","text":"<pre><code>DependenciesAccessibleRule(cache_size: int = 1000)\n</code></pre> <p>               Bases: <code>ValidationRule</code></p> <p>Validates that all dependencies required by providers are accessible.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, cache_size: int = 1000) -&gt; None:\n    self._cache = LRUCache[set[type[object]]](cache_size)\n    self._types_extractor = ModuleTypesExtractor(self._cache)\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependenciesAccessibleRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    self._cache.clear()  # Clear cache before validation\n\n    registry = context.app.registry\n    modules = list(registry.modules)\n\n    checker = DependencyAccessChecker(modules, context, self._types_extractor)\n    errors: list[ValidationError] = []\n\n    for module in modules:\n        module_provider = module.provider\n        for factory in module_provider.factories:\n            inaccessible_deps = checker.find_inaccessible_dependencies(\n                dependencies=factory.dependencies,\n                module=module,\n            )\n            errors.extend(\n                DependencyInaccessibleError(\n                    required_type=dep_type,\n                    required_by=factory.source,\n                    from_module=module,\n                )\n                for dep_type in inaccessible_deps\n            )\n\n    return errors\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError","title":"DependencyInaccessibleError","text":"<pre><code>DependencyInaccessibleError(\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n)\n</code></pre> <p>               Bases: <code>ValidationError</code></p> <p>Error indicating a dependency is not accessible to a provider/module.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n) -&gt; None:\n    self.required_type = required_type\n    self.required_by = required_by\n    self.from_module = from_module\n    super().__init__(str(self))\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError.required_type","title":"required_type  <code>instance-attribute</code>","text":"<pre><code>required_type = required_type\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError.required_by","title":"required_by  <code>instance-attribute</code>","text":"<pre><code>required_by = required_by\n</code></pre>"},{"location":"reference/#waku.validation.rules.DependencyInaccessibleError.from_module","title":"from_module  <code>instance-attribute</code>","text":"<pre><code>from_module = from_module\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible","title":"dependency_accessible","text":""},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError","title":"DependencyInaccessibleError","text":"<pre><code>DependencyInaccessibleError(\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n)\n</code></pre> <p>               Bases: <code>ValidationError</code></p> <p>Error indicating a dependency is not accessible to a provider/module.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n) -&gt; None:\n    self.required_type = required_type\n    self.required_by = required_by\n    self.from_module = from_module\n    super().__init__(str(self))\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError.required_type","title":"required_type  <code>instance-attribute</code>","text":"<pre><code>required_type = required_type\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError.required_by","title":"required_by  <code>instance-attribute</code>","text":"<pre><code>required_by = required_by\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyInaccessibleError.from_module","title":"from_module  <code>instance-attribute</code>","text":"<pre><code>from_module = from_module\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyAccessChecker","title":"DependencyAccessChecker","text":"<pre><code>DependencyAccessChecker(\n    modules: list[Module],\n    context: ValidationContext,\n    types_extractor: ModuleTypesExtractor,\n)\n</code></pre> <p>Handles dependency accessibility checks between modules.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    modules: list[Module],\n    context: ValidationContext,\n    types_extractor: ModuleTypesExtractor,\n) -&gt; None:\n    self._modules = modules\n    self._context = context\n    self._registry = context.app.registry\n    self._type_provider = types_extractor\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependencyAccessChecker.find_inaccessible_dependencies","title":"find_inaccessible_dependencies","text":"<pre><code>find_inaccessible_dependencies(\n    dependencies: Sequence[Any], module: Module\n) -&gt; Iterable[type[object]]\n</code></pre> <p>Find dependencies that are not accessible to a module.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def find_inaccessible_dependencies(self, dependencies: Sequence[Any], module: Module) -&gt; Iterable[type[object]]:\n    \"\"\"Find dependencies that are not accessible to a module.\"\"\"\n    return (\n        dependency.type_hint for dependency in dependencies if not self._is_accessible(dependency.type_hint, module)\n    )\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependenciesAccessibleRule","title":"DependenciesAccessibleRule","text":"<pre><code>DependenciesAccessibleRule(cache_size: int = 1000)\n</code></pre> <p>               Bases: <code>ValidationRule</code></p> <p>Validates that all dependencies required by providers are accessible.</p> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, cache_size: int = 1000) -&gt; None:\n    self._cache = LRUCache[set[type[object]]](cache_size)\n    self._types_extractor = ModuleTypesExtractor(self._cache)\n</code></pre>"},{"location":"reference/#waku.validation.rules.dependency_accessible.DependenciesAccessibleRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    self._cache.clear()  # Clear cache before validation\n\n    registry = context.app.registry\n    modules = list(registry.modules)\n\n    checker = DependencyAccessChecker(modules, context, self._types_extractor)\n    errors: list[ValidationError] = []\n\n    for module in modules:\n        module_provider = module.provider\n        for factory in module_provider.factories:\n            inaccessible_deps = checker.find_inaccessible_dependencies(\n                dependencies=factory.dependencies,\n                module=module,\n            )\n            errors.extend(\n                DependencyInaccessibleError(\n                    required_type=dep_type,\n                    required_by=factory.source,\n                    from_module=module,\n                )\n                for dep_type in inaccessible_deps\n            )\n\n    return errors\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering a contribution to <code>waku</code>! \ud83c\udf89</p> <p>This guide will help you get started and ensure a smooth process.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher</li> <li>uv \u2013 a modern Python package manager</li> <li>Task \u2013 a task runner for automating development workflows (we recommend setting up auto-completion for Task)</li> <li>Git</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Install UV (if not already installed):</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# For other platforms, see:\n# https://docs.astral.sh/uv/getting-started/installation/\n\n# If uv is already installed, ensure it's up to date:\nuv self update\n</code></pre> </li> <li> <p>Install Task (if not already installed):</p> <pre><code># Using the install script\nsh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin\n\n# For other installation options, see:\n# https://taskfile.dev/installation/\n</code></pre> </li> <li> <p>Set up the development environment:</p> <pre><code># Install dependencies and configure pre-commit hooks\ntask install\n</code></pre> <p>Tip: Run <code>task -l</code> after setup to verify everything is working and to see available commands.</p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Fork the repository to your own GitHub account.</li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Create a new branch for your changes:</p> <pre><code>git checkout -b feat/your-feature-name\n</code></pre> </li> <li> <p>Make your changes, following our code style guidelines.</p> </li> <li>Write or update tests for your changes.</li> <li> <p>Run all checks and ensure tests pass:</p> <pre><code>task\n</code></pre> </li> <li> <p>Commit your changes with clear, descriptive messages.</p> </li> <li> <p>Push to your fork:</p> <pre><code>git push origin feat/your-feature-name\n</code></pre> </li> <li> <p>Open a pull request on GitHub. Link related issues in your PR description (e.g., \"Fixes #123\").</p> </li> <li>Participate in the review process and make any requested changes.</li> </ol>"},{"location":"contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li> Tests added or updated</li> <li> Documentation updated (if needed)</li> <li> Code is formatted and linted</li> <li> All checks pass</li> <li> Type hints added or refined</li> <li> Commit messages include a detailed description for the changelog</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Ensure your changes are thoroughly tested by running the following commands:</p> <pre><code># Run all checks (recommended)\ntask\n\n# Run linters and type checkers\ntask check\n\n# Run specific checks\ntask test         # Run tests only\ntask test:cov     # Run tests with coverage\ntask lint         # Run linters only\ntask format       # Format code\ntask typecheck    # Run type checkers only\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Ruff for linting and formatting</li> <li>MyPy and basedpyright for type checking</li> <li>pre-commit for running checks before commits and pushes</li> </ul> <p>Key style guidelines:</p> <ul> <li>Maximum line length: 120 characters</li> <li>Use explicit type annotations throughout the codebase</li> <li>Follow PEP 8 conventions</li> <li>Write descriptive docstrings using the Google style</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you have questions or need help, you can:</p> <ul> <li>Open a discussion</li> <li>Open an issue for bugs or feature requests</li> </ul>"},{"location":"contributing/#first-time-contributors","title":"First-time Contributors","text":"<ul> <li>Look for issues labeled \"good first issue\" or \"help wanted\".</li> <li>Comment on the issue to let others know you're working on it.</li> <li>Don't hesitate to ask questions if anything is unclear.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Before creating an issue:</p> <ul> <li>Search existing issues to avoid duplicates.</li> <li>Use the appropriate issue template for bug reports or feature requests.</li> <li>Provide as much context as possible (e.g., steps to reproduce, environment details).</li> </ul> <p>Please follow the bug report and feature request templates when submitting issues.</p> <p>We welcome:</p> <ul> <li>Bug reports</li> <li>Feature requests</li> <li>Documentation improvements</li> <li>General questions or ideas</li> </ul>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<ul> <li><code>src/</code> \u2013 main source code</li> <li><code>tests/</code> \u2013 test suite</li> <li><code>docs/</code> \u2013 documentation</li> <li><code>Taskfile.yml</code> \u2013 development automation</li> <li><code>README.md</code> \u2013 project overview</li> </ul>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<ul> <li>Use clear, descriptive commit messages.</li> <li>Example: <code>fix(core): handle edge case in dependency resolution</code></li> </ul> <p>Thank you for contributing to <code>waku</code>! \ud83d\ude4f</p>"},{"location":"contributing/docs/","title":"Documentation","text":""},{"location":"contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub or by opening an issue.</p>"},{"location":"contributing/docs/#how-to-get-started","title":"How to get started","text":"<ol> <li>Follow the steps for development setup in the contributing guide</li> <li> <p>Start the local documentation server for live preview of changes</p> <pre><code>mkdocs serve\n</code></pre> </li> <li> <p>Go to the <code>docs/</code> directory and make your changes</p> </li> </ol> <p>After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"examples/cqrs/","title":"Mediator (CQRS)","text":"<p>Based on the CQRS pattern, the mediator is used to decouple the command and query logic from the domain model.</p> <p>Implementation heavily inspired by C# MediatR library.</p> <p>For full documentation, visit the Mediator (CQRS) section.</p>"},{"location":"examples/cqrs/#code","title":"Code","text":""},{"location":"examples/modularity/","title":"Modularity","text":"<p>Example of how to use modules, dynamic modules and linking them together to build an application.</p> <p>For full documentation on modules, visit the Modules section.</p>"},{"location":"examples/modularity/#code","title":"Code","text":""},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/asgi/","title":"ASGI Integration","text":"<p><code>waku</code> can be seamlessly integrated into any ASGI application. To achieve this, set up <code>waku</code> as you normally would, then add the <code>ApplicationMiddleware</code> to your ASGI application\u2019s middleware stack.</p>"},{"location":"integrations/asgi/#example-with-fastapi","title":"Example with FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.middleware import Middleware\nfrom waku import WakuApplication\nfrom waku.contrib.asgi import WakuMiddleware\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the FastAPI app with the waku middleware\napp = FastAPI(\n    middleware=[\n        Middleware(WakuMiddleware, application=application),\n    ],\n)\n</code></pre> <p>In this example, the <code>ApplicationMiddleware</code> bridges <code>waku</code> with FastAPI, allowing dependency injection and module management within your ASGI routes.</p>"},{"location":"integrations/litestar/","title":"Litestar Integration","text":"<p><code>waku</code> can be seamlessly integrated with Litestar using the <code>ApplicationPlugin</code>. To do this, set up <code>waku</code> as usual and then include the plugin in your Litestar application configuration.</p>"},{"location":"integrations/litestar/#example","title":"Example","text":"<p>Here\u2019s how to integrate <code>waku</code> with a Litestar application:</p> <pre><code>from litestar import Litestar\nfrom waku import WakuApplication\nfrom waku.contrib.litestar import WakuPlugin\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the Litestar app with the waku plugin\napp = Litestar(plugins=[WakuPlugin(application)])\n</code></pre> <p>In this example, the <code>ApplicationPlugin</code> enables <code>waku</code> dependency injection and module system within your Litestar application.</p>"},{"location":"usage/lifespan/","title":"Lifespan","text":""},{"location":"usage/modules/","title":"Modules","text":"<p><code>waku</code> modularity system is heavily inspired by the NestJS and Tramvai frameworks.</p> <p>The concept of modularity is well-explained with examples in the NestJS documentation.</p>"},{"location":"usage/modules/#module","title":"Module","text":"<p>A module is a class annotated with the <code>@module()</code> decorator. This decorator attaches metadata to the class, which <code>waku</code> uses to construct the application graph.</p> <p>Every <code>waku</code> application has at least one module: the root module, also known as the composition root. This module serves as the starting point for <code>waku</code> to build the entire application graph.</p> Parameter Description <code>providers</code> List of providers for dependency injection <code>imports</code> List of modules imported by this module <code>exports</code> List of types or modules exported by this module <code>extensions</code> List of module extensions for lifecycle hooks <code>is_global</code> Whether this module is global or not <p>The module encapsulates providers by default, meaning you can only inject providers that are either part of the current module or explicitly exported from other imported modules. The exported providers from a module essentially serve as the module's public interface or API.</p> <pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.config.module import ConfigModule\n\n\nclass UsersService:\n    pass\n\n\n@module(\n    providers=[Scoped(UsersService)],  # Register the service with a scoped lifetime\n    imports=[ConfigModule],  # Import another module\n    exports=[UsersService],  # Expose the service to other modules\n)\nclass UsersModule:\n    pass\n\n\n@module(imports=[UsersModule])  # Root module importing UsersModule\nclass AppModule:\n    pass\n</code></pre> <p>Note</p> <p>Encapsulation is enforced by validators, which you can disable at runtime if needed. However, disabling them entirely is not recommended, as they help maintain modularity.</p>"},{"location":"usage/modules/#module-re-exporting","title":"Module Re-exporting","text":"<p>You can re-export a module by including it in the <code>exports</code> list of another module. This is useful for exposing a module\u2019s providers to other modules that import the re-exporting module.</p> <pre><code>@module(\n    imports=[UsersModule],\n    exports=[UsersModule],\n)\nclass IAMModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#global-modules","title":"Global modules","text":"<p>If you need to import the same set of modules across your application, you can mark a module as global. Once a module is global, its providers can be injected anywhere in the application without requiring explicit imports in every module.</p> <p>To make a module global, set the <code>is_global</code> param to <code>True</code> in the <code>@module()</code> decorator.</p> <p>Note</p> <p>Root module are always global.</p> <p>Warning</p> <p>Global modules are not recommended for large applications, as they can lead to tight coupling and make the application harder to maintain.</p> <pre><code>from waku import module\n\n\n@module(is_global=True)\nclass UsersModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#dynamic-module","title":"Dynamic Module","text":"<p>Dynamic modules allow you to create modules dynamically based on conditions, such as the runtime environment of your application.</p> <pre><code>from waku import DynamicModule, module\nfrom waku.di import Scoped\n\n\nclass ConfigService:\n    pass\n\n\nclass DevConfigService(ConfigService):\n    pass\n\n\nclass DefaultConfigService(ConfigService):\n    pass\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # Choose the config provider based on the environment\n        config_provider = DevConfigService if env == 'dev' else DefaultConfigService\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Scoped(config_provider, type_=ConfigService)],  # Register with interface type\n        )\n</code></pre> <p>And then you can use it in any of your modules or in the root module:</p> <pre><code>from waku import module\n\nfrom app.modules.config.module import ConfigModule\n\n\n@module(\n    imports=[\n        ConfigModule.register(env='dev'),\n    ],\n)\nclass AppModule:\n    pass\n</code></pre> <p>You can also make a dynamic module global by setting <code>is_global=True</code> in the <code>DynamicModule</code> constructor.</p> <p>Note</p> <p>While you can use any method name instead of <code>register</code>, we recommend sticking with <code>register</code> for consistency.</p>"},{"location":"usage/providers/","title":"Providers","text":""},{"location":"usage/providers/#introduction","title":"Introduction","text":"<p>Providers are the core of <code>waku</code> dependency injection system. The idea behind a provider is that it can be injected as a dependency into other provider constructors, allowing objects to form various relationships with each other.</p> <p><code>waku</code> responsibility is to \"wire up\" all the providers using the DI framework and manage their lifecycle. This way you can focus on writing your application logic.</p>"},{"location":"usage/providers/#dependency-injection","title":"Dependency Injection","text":"<p><code>waku</code> is designed to be modular and extensible. To support this principle, it provides a flexible dependency injection (DI) system that integrates seamlessly with various DI frameworks. <code>waku</code> itself acts as an IoC container, allowing you to register and resolve dependencies using the modules system.</p> <p>Note</p> <p><code>waku</code> uses the Dishka IoC container under the hood. All provider lifecycles and dependency resolution are handled by Dishka.</p>"},{"location":"usage/providers/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that addresses the issue of tightly coupled code by decoupling the creation and management of dependencies from the classes that rely on them. In traditional approaches, classes directly instantiate their dependencies, resulting in rigid, hard-to-maintain code. DI solves this problem by enabling dependencies to be supplied externally, typically through mechanisms like constructor or setter injection.</p> <p>By shifting the responsibility of dependency management outside the class, DI promotes loose coupling, allowing classes to focus on their core functionality rather than how dependencies are created. This separation enhances maintainability, testability, and flexibility, as dependencies can be easily swapped or modified without altering the class's code. Ultimately, DI improves system design by reducing interdependencies and making code more modular and scalable.</p> Manual DI Example <pre><code>from abc import ABC, abstractmethod\n\n\n# Use an interface to define contract for clients\n# This allows us injecting different implementations\nclass IClient(ABC):\n    @abstractmethod\n    def request(self, url: str) -&gt; str:\n        pass\n\n\n# Regular implementation\nclass RealClient(IClient):\n    def request(self, url: str) -&gt; str:\n        # Some HTTP requesting logic\n        return f'\"{url}\" call result'\n\n\n# Implementation for tests\nclass MockClient(IClient):\n    def __init__(self, return_data: str) -&gt; None:\n        self._return_data = return_data\n\n    def request(self, url: str) -&gt; str:\n        # Mocked behavior for testing\n        return f'{self._return_data} from \"{url}\"'\n\n\nclass Service:\n    # Accepts any IClient implementation\n    def __init__(self, client: IClient) -&gt; None:\n        self._client = client\n\n    def do_something(self) -&gt; str:\n        return self._client.request('https://example.com')\n\n\n# Usage in regular code\nreal_client = RealClient()\nservice = Service(real_client)\nprint(service.do_something())  # Output: \"https://example.com\" call result\n\n# Usage in tests\nmocked_client = MockClient('mocked data')\nservice = Service(mocked_client)\nprint(service.do_something())  # Output: mocked data from \"https://example.com\"\n</code></pre> <p>Here, a <code>MockClient</code> is injected into <code>Service</code>, making it easy to test <code>Service</code> in isolation without relying on a real client implementation.</p>"},{"location":"usage/providers/#what-is-ioc-container","title":"What is IoC-container?","text":"<p>An IoC container is a framework that automates object creation and dependency management based on the Inversion of Control (IoC) principle. It centralizes the configuration and instantiation of components, reducing tight coupling and simplifying code maintenance. By handling dependency resolution, an IoC container promotes modular, testable, and scalable application design.</p> <p>With the power of an IoC container, you can leverage all the benefits of DI without manually managing dependencies.</p>"},{"location":"usage/providers/#providers_1","title":"Providers","text":"<p><code>Provider</code> is an object that holds dependency metadata, such as its type, lifetime scope and factory.</p> <p>In <code>waku</code>, there are five types of providers, one for each scope:</p> <ul> <li><code>Transient</code></li> <li><code>Scoped</code></li> <li><code>Singleton</code></li> <li><code>Object</code></li> <li><code>Contextual</code></li> </ul> <p>Each provider (except <code>Contextual</code>) takes two arguments:</p> <ul> <li><code>source</code>: type or callable that returns or yields an instance of the dependency.</li> <li><code>provided_type</code>: type of the dependency. If not provided, it will be inferred from the factory function's return type.</li> </ul>"},{"location":"usage/providers/#scopes","title":"Scopes","text":"<p><code>waku</code> supports four different lifetime scopes for providers, inspired by the service lifetimes from .NET Core's DI system.</p>"},{"location":"usage/providers/#transient","title":"Transient","text":"<p>Dependencies defined with the <code>Transient</code> provider are created each time they're requested.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import transient\n\n\n@module(providers=[transient(list)])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application:\n        async with application.container() as request_container:\n            obj_1 = await request_container.get(list)\n            obj_2 = await request_container.get(list)\n            assert obj_1 is not obj_2\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#scoped","title":"Scoped","text":"<p>Dependencies defined with the <code>Scoped</code> provider are created once per dependency provider context entry and disposed when the context exits.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import scoped\n\n\n@module(providers=[scoped(list)])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application:\n        async with application.container() as request_container:\n            obj_1 = await request_container.get(list)\n            obj_2 = await request_container.get(list)\n            assert obj_1 is obj_2\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#singleton","title":"Singleton","text":"<p>Dependencies defined with the <code>Singleton</code> provider are created the first time they're requested and disposed when the application lifecycle ends.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import singleton\n\n\n@module(providers=[singleton(list)])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application:\n        async with application.container() as request_container:\n            obj_1 = await request_container.get(list)\n\n        async with application.container():\n            obj_2 = await request_container.get(list)\n\n        assert obj_1 is obj_2\n\n    # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#object","title":"Object","text":"<p>Dependencies defined with the <code>Object</code> provider behave like <code>Singleton</code>, but you must provide the implementation instance directly to the provider and manage its lifecycle manually, outside the IoC container.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import object_\n\nsome_object = (1, 2, 3)\n\n\n@module(\n    providers=[\n        object_(some_object, provided_type=tuple),\n    ],\n)\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with application, application.container() as request_container:\n        obj = await request_container.get(tuple)\n        assert obj is some_object\n\n    # Providers are not disposed at this point automatically\n    # because they are not part of the application container lifecycle\n</code></pre>"},{"location":"usage/providers/#contextual","title":"Contextual","text":"<p>The <code>Contextual</code> provider enables you to inject external objects that originate outside the DI container directly into your dependency graph. This is particularly valuable for framework-specific objects like HTTP requests, database transactions, or event data that have their own lifecycle managed externally.</p> <p>When to use Contextual providers:</p> <ul> <li>Framework integration: Inject HTTP request objects, user sessions, or authentication contexts</li> <li>Event-driven scenarios: Process queue messages, webhooks, or callback data</li> <li>External resources: Integrate database transactions, file handles, or network connections managed by external systems</li> <li>Per-request data: Handle any data that varies per request/operation and originates from outside your application</li> </ul> <p>How it works:</p> <ol> <li>Declare the contextual dependency using the <code>contextual</code> provider in your module</li> <li>Use the dependency in other providers just like any regular dependency</li> <li>Provide the actual value when entering the container scope using the <code>context=</code> parameter</li> </ol> <p>The <code>contextual</code> provider accepts two arguments:</p> <ul> <li><code>provided_type</code>: The type of the dependency to be injected</li> <li><code>scope</code>: The scope where the context is available (defaults to <code>Scope.REQUEST</code>)</li> </ul> <pre><code>from waku import WakuFactory, module\nfrom waku.di import contextual, Scope\n\nsome_object = (1, 2, 3)\n\n\n@module(\n    providers=[\n        contextual(provided_type=tuple, scope=Scope.REQUEST),\n    ],\n)\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    application = WakuFactory(AppModule).create()\n    async with (\n        application,\n        application.container(\n            context={tuple: some_object},\n        ) as request_container,\n    ):\n        obj = await request_container.get(tuple)\n        assert obj is some_object\n\n    # Providers are not disposed at this point automatically\n    # because they are not part of the application container lifecycle\n</code></pre> <p>Slightly more realistic example:</p> <p>Consider building a web application with FastAPI where you need to inject the current request into your service layer. Here's how you can accomplish this:</p> <pre><code>from fastapi import FastAPI, Request\nfrom waku import WakuFactory, module\nfrom waku.di import contextual, scoped, Scope\n\n\nclass UserService:\n    \"\"\"Service that uses the current HTTP request for user-specific operations.\"\"\"\n\n    def __init__(self, request: Request) -&gt; None:\n        self.request = request\n\n    def get_user_info(self) -&gt; dict[str, str]:\n        \"\"\"Extract user information from the request headers.\"\"\"\n        return {\n            'user_id': self.request.headers.get('user-id', 'anonymous'),\n            'session_id': self.request.headers.get('session-id', 'none'),\n            'user_agent': self.request.headers.get('user-agent', 'unknown'),\n        }\n\n\n@module(\n    providers=[\n        contextual(provided_type=Request, scope=Scope.REQUEST),\n        scoped(UserService),\n    ],\n)\nclass WebModule:\n    pass\n\n\n# FastAPI application setup\napp = FastAPI()\napplication = WakuFactory(WebModule).create()\n\n\n@app.get('/user-info')\nasync def get_user_info(request: Request) -&gt; dict[str, str]:\n    \"\"\"Endpoint that uses contextual dependency injection.\"\"\"\n    async with (\n        application,\n        application.container(\n            context={Request: request},\n        ) as request_container,\n    ):\n        # UserService automatically receives the current HTTP request\n        user_service = await request_container.get(UserService)\n        return user_service.get_user_info()\n\n\n# Example usage:\n# curl -H \"user-id: john123\" -H \"session-id: abc456\" http://localhost:8000/user-info\n</code></pre> <p>Important</p> <p>In this example, the <code>contextual</code> provider and <code>waku</code> itself are used to manually inject the current request into the <code>UserService</code>. However, in real-world applications, you should use the Dishka FastAPI integration to inject the request automatically.</p> <p>This pattern is essential for integrating with web frameworks, message brokers, and other external systems where objects have lifecycles managed outside your application.</p>"},{"location":"usage/providers/#where-and-how-to-inject-dependencies","title":"Where and how to inject dependencies?","text":"<p>To inject dependencies with <code>waku</code>, you need to:</p> <ol> <li>Register them as <code>providers</code> with the desired scope in modules.</li> <li>Identify your application entrypoints and decorate them with the <code>@inject</code> decorator for your framework. Consult the    Dishka integrations section for your framework to    find out how to do this.</li> <li>Add dependencies as arguments to your entrypoint signature using the <code>Injected</code> type hint.</li> </ol>"},{"location":"usage/providers/#next-steps","title":"Next steps","text":"<p>For advanced features and customization options, refer to the Dishka documentation.</p>"}]}
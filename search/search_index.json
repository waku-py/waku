{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"waku","text":"<p> <sup>waku [\u67a0 or \u308f\u304f] means framework in Japanese.</sup> </p> <p> </p> <p> </p> <p>waku is a modular, type-safe Python framework for scalable, maintainable applications. Inspired by NestJS, powered by Dishka IoC.</p> <p>[!WARNING] <code>waku</code> is currently undergoing a near-complete rewrite, so the documentation is not fully up-to-date with recent changes. Please refer to this README and the examples until the documentation is updated.</p> <p>You can also consult the <code>waku</code> deepwiki page as a reference.</p>"},{"location":"#why-waku","title":"Why <code>waku</code>?","text":"<ul> <li>\ud83e\udde9 Modular by design: Enforces clear boundaries and single responsibility.</li> <li>\ud83d\udc89 First-class Dependency Injection: Powered by Dishka.</li> <li>\u26a1 Event-driven and extensible: Built-in hooks, CQRS, and plugin system.</li> <li>\ud83d\udd0c Framework-agnostic: Integrates with FastAPI, Litestar, FastStream, Aiogram, and more.</li> <li>\ud83d\udee1\ufe0f Production-ready: Type-safe, testable, and maintainable.</li> </ul>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<ul> <li>Teams building enterprise or microservice Python apps</li> <li>Developers seeking a clean, maintainable architecture</li> <li>Projects that require testability, loose coupling, and clear module boundaries</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udde9 Modular architecture: Build applications as a set of loosely coupled modules with clear boundaries, automatic dependency validation, and controlled visibility.</li> <li>\ud83d\udc89 Dependency Injection: Use Dishka's IoC container for type-safe, testable, and maintainable dependency management.</li> <li>\ud83d\udce8 CQRS/Mediator: Handle commands, queries, and events with a mediator abstraction inspired by C# MediatR.</li> <li>\ud83e\uddf0 Extensions &amp; plugins: Extend <code>waku</code> with custom plugins that can hook into the application lifecycle, add providers, or integrate with external systems.</li> <li>\ud83d\udd04 Lifespan management: Automatically manage application and IoC container lifecycles with built-in hooks and an event system.</li> <li>\ud83e\udd1d Integrations: Out-of-the-box support for FastAPI, Litestar, FastStream, Aiogram, and more, leveraging Dishka's integrations.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>uv add waku\n# or\npip install waku\n</code></pre>"},{"location":"#minimal-example","title":"Minimal Example","text":"<pre><code>import asyncio\n\nfrom waku import WakuFactory, module\nfrom waku.di import scoped\n\n\nclass GreetingService:\n    async def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n\n\n@module(providers=[scoped(GreetingService)])\nclass GreetingModule:\n    pass\n\n\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\nasync def main() -&gt; None:\n    app = WakuFactory(AppModule).create()\n\n    async with app, app.container() as c:\n        svc = await c.get(GreetingService)\n        print(await svc.greet('waku'))\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>For more realistic examples, see the Getting Started guide or check out the examples directory.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>Module System</li> <li>Providers</li> <li>Extensions</li> <li>Mediator (CQRS)</li> <li>API Reference</li> <li>Dishka Documentation</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ul> <li>Contributing Guide</li> <li>Development Setup</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Improve inner architecture</li> <li> Improve documentation</li> <li> Add new and improve existing validation rules</li> <li> Provide example projects for common architectures</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Issues</li> <li>Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Note</p> <p>For our examples we stick with aioinject as DI provider. Install it directly using your preferred package manager or as extra dependency of <code>waku</code>:</p> uvpip <pre><code>uv add \"waku[aioinject]\"\n# or\nuv add aioinject\n</code></pre> <pre><code>pip install \"waku[aioinject]\"\n# or\npip install aioinject\n</code></pre>"},{"location":"getting-started/#creating-your-first-waku-application","title":"Creating Your First <code>waku</code> Application","text":"<p>Let's create a simple application that demonstrates <code>waku</code> core concepts.</p>"},{"location":"getting-started/#step-1-create-the-basic-structure","title":"Step 1: Create the Basic Structure","text":"<p>Create a new directory for your project and set up your files:</p> <pre><code>project/\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 services.py\n</code></pre>"},{"location":"getting-started/#step-2-define-your-services","title":"Step 2: Define Your Services","text":"<p>In <code>services.py</code>, let's define a simple service:</p> services.py<pre><code>class GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n</code></pre>"},{"location":"getting-started/#step-3-create-modules","title":"Step 3: Create Modules","text":"<p>In <code>app.py</code>, let's define our modules and application setup:</p> app.py<pre><code>import asyncio\n\nfrom waku import WakuApplication, WakuFactory, module\nfrom waku.di import Scoped, Injected, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nfrom project.services import GreetingService\n\n\n# Define a feature module\n@module(\n    providers=[Scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n\n\n# Define the root application module\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\n# Define a function that will use our service\n@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n\n\n# Bootstrap the application\ndef bootstrap() -&gt; WakuApplication:\n    return WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n\n\n# Run the application\nasync def main() -&gt; None:\n    application = bootstrap()\n\n    # Create a context for our application\n    async with application, application.container.context():\n        # Use our service\n        message = await greet_user()  # type: ignore[call-arg]\n        print(message)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-4-run-your-application","title":"Step 4: Run Your Application","text":"<p>Run the application with:</p> <pre><code>python app.py\n</code></pre> <p>You should see the output:</p> <pre><code>Hello, waku!\n</code></pre>"},{"location":"getting-started/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what's happening in our simple application:</p>"},{"location":"getting-started/#modules","title":"Modules","text":"<p>Modules are the building blocks of a <code>waku</code> application. Each module encapsulates a specific feature or functionality.</p> <pre><code>@module(\n    providers=[Scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre> <p>In this example:</p> <ul> <li><code>providers</code> defines which providers this module creates and manages</li> <li><code>exports</code> makes these providers (or imported modules) available to other modules that import this one</li> <li><code>Scoped</code> indicates this provider should be created once for every container context entrance.</li> </ul> <p>Info</p> <p>For more information on providers and scopes, see Providers.</p>"},{"location":"getting-started/#application-bootstrap","title":"Application Bootstrap","text":"<p>The application is created using an <code>ApplicationFactory</code>:</p> <pre><code>def bootstrap() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n</code></pre> <p>This creates an application instance with:</p> <ul> <li><code>AppModule</code> as the root module</li> <li><code>AioinjectDependencyProvider</code> as the dependency injection provider</li> </ul>"},{"location":"getting-started/#dependency-injection","title":"Dependency Injection","text":"<p>Providers are injected into functions using the @inject decorator:</p> <pre><code>@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n</code></pre> <p>The <code>Injected[GreetingService]</code> type annotation tells <code>waku</code> which provider to inject.</p>"},{"location":"getting-started/#context-management","title":"Context Management","text":"<p><code>waku</code> uses context managers to manage the lifecycle of your application and its providers:</p> <pre><code>async with application, application.container.context():\n    message = await greet_user()\n</code></pre> <p>In real applications, you would typically use this context managers in <code>lifespan</code> of your framework.</p>"},{"location":"getting-started/#creating-a-more-realistic-application","title":"Creating a More Realistic Application","text":"<p>Let's extend our example to demonstrate a more realistic scenario with multiple modules and configuration.</p>"},{"location":"getting-started/#step-1-enhanced-structure","title":"Step 1: Enhanced Structure","text":"<p>Create a more complete project structure:</p> <pre><code>app/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __main__.py\n\u251c\u2500\u2500 application.py\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 greetings/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 services.py\n\u2502   \u2502   \u2514\u2500\u2500 module.py\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 services.py\n\u2502       \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 settings.py\n</code></pre>"},{"location":"getting-started/#step-2-add-configuration-module","title":"Step 2: Add Configuration Module","text":"<p>Define an application settings class and configuration module for providing settings object to your application:</p> app/settings.py<pre><code>from dataclasses import dataclass\nfrom typing import Literal\n\nfrom waku import DynamicModule, module\nfrom waku.di import Object\n\nEnvironment = Literal['dev', 'prod']\n\n\n# You may consider using `pydantic-settings` or similar libs for settings management\n@dataclass(kw_only=True)\nclass AppSettings:\n    environment: Environment\n    debug: bool\n\n\n@module(is_global=True)\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: Environment) -&gt; DynamicModule:\n        settings = AppSettings(\n            environment=env,\n            debug=env == 'dev',\n        )\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Object(settings)],\n        )\n</code></pre>"},{"location":"getting-started/#step-3-create-modules_1","title":"Step 3: Create Modules","text":""},{"location":"getting-started/#greeting-module","title":"Greeting Module","text":"app/modules/greetings/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Greeting:\n    language: str\n    template: str\n</code></pre> app/modules/greetings/services.py<pre><code>from app.config import AppConfig\nfrom app.modules.greetings.models import Greeting\n\n\nclass GreetingService:\n    def __init__(self, config: AppConfig) -&gt; None:\n        self.config = config\n        self.greetings: dict[str, Greeting] = {\n            'en': Greeting(language='en', template='Hello, {}!'),\n            'es': Greeting(language='es', template='\u00a1Hola, {}!'),\n            'fr': Greeting(language='fr', template='Bonjour, {}!'),\n        }\n\n    def get_greeting(self, language: str = 'en') -&gt; Greeting:\n        # If in debug mode and language not found, return default\n        if self.config.debug and language not in self.greetings:\n            return self.greetings['en']\n        return self.greetings.get(language, self.greetings['en'])\n\n    def greet(self, name: str, language: str = 'en') -&gt; str:\n        greeting = self.get_greeting(language)\n        return greeting.template.format(name)\n\n    def available_languages(self) -&gt; list[str]:\n        return list(self.greetings.keys())\n</code></pre> app/modules/greetings/module.py<pre><code>from waku import module\nfrom waku.di import Singleton\n\nfrom app.modules.greetings.services import GreetingService\n\n\n@module(\n    providers=[Singleton(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre>"},{"location":"getting-started/#user-module","title":"User Module","text":"app/modules/users/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: str\n    name: str\n    preferred_language: str = 'en'\n</code></pre> app/modules/users/services.py<pre><code>from app.modules.users.models import User\n\n\nclass UserService:\n    def __init__(self) -&gt; None:\n        # Mock database\n        self.users: dict[str, User] = {\n            '1': User(id='1', name='Alice', preferred_language='en'),\n            '2': User(id='2', name='Bob', preferred_language='fr'),\n            '3': User(id='3', name='Carlos', preferred_language='es'),\n        }\n\n    def get_user(self, user_id: str) -&gt; User | None:\n        return self.users.get(user_id)\n</code></pre> app/modules/users/module.py<pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.users.services import UserService\n\n\n@module(\n    providers=[Scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n</code></pre>"},{"location":"getting-started/#step-4-create-the-application-module","title":"Step 4: Create the Application Module","text":"<p>Define the application module and bootstrap function for initializing your application:</p> app/application.py<pre><code>from waku import WakuApplication, WakuFactory, module\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nfrom app.settings import ConfigModule\nfrom app.greetings.module import GreetingModule\nfrom app.users.module import UserModule\n\n\n@module(\n    # Import all top-level modules\n    imports=[\n        ConfigModule.register(env='dev'),\n        GreetingModule,\n        UserModule,\n    ],\n)\nclass AppModule:\n    pass\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    return WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n</code></pre>"},{"location":"getting-started/#step-5-create-the-main-entrypoint","title":"Step 5: Create the Main Entrypoint","text":"<p>In real world scenarios, you would use a framework like FastAPI, Flask, etc. for defining your entry points, also known as handlers. For the sake of simplicity, we don't use any framework in this example.</p> app/__main__.py<pre><code>import asyncio\n\nfrom waku.di import Injected, inject\n\nfrom app.application import bootstrap_application\nfrom app.modules.users.services import UserService\nfrom app.modules.greetings.services import GreetingService\n\n\n@inject\nasync def greet_user_by_id(\n    user_id: str,\n    user_service: Injected[UserService],\n    greeting_service: Injected[GreetingService],\n) -&gt; str:\n    user = user_service.get_user(user_id)\n    if not user:\n        return f'User {user_id} not found'\n\n    return greeting_service.greet(name=user.name, language=user.preferred_language)\n\n\nasync def main() -&gt; None:\n    application = bootstrap_application()\n\n    async with application, application.container.context():\n        # Greet different users\n        for user_id in ['1', '2', '3', '4']:  # '4' doesn't exist\n            greeting = await greet_user_by_id(user_id)  # type: ignore[call-arg]\n            print(greeting)\n\n        # Get service directly for demonstration\n        greeting_service = application.container.get(GreetingService)\n        print(f'Available languages: {greeting_service.available_languages()}')\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-6-run-your-application","title":"Step 6: Run Your Application","text":"<pre><code>python -m app\n</code></pre> <p>Expected output:</p> <pre><code>Hello, Alice!\nBonjour, Bob!\n\u00a1Hola, Carlos!\nUser 4 not found\nAvailable languages: ['en', 'es', 'fr']\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of <code>waku</code>, you can:</p> <ol> <li>Explore more advanced features like Mediator (CQRS)</li> <li>Learn about Extensions for adding functionality to your application</li> <li>Integrate with web frameworks like FastAPI</li> <li>Understand Module System in depth</li> <li>Explore Dependency Injection techniques</li> </ol> <p><code>waku</code> modular architecture allows your application to grow while maintaining clear separation of concerns and a clean, maintainable codebase.</p> <p>Note</p> <p>This guide is a starting point. It's highly recommended to read The Software Architecture Chronicles by Herberto Gra\u00e7a. He distills all popular software architectural styles into a single one to rule them all. It's a great read and will help you understand the principles behind <code>waku</code>.</p> <p>Happy coding with <code>waku</code>!</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#waku","title":"waku","text":""},{"location":"reference/#waku.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extensions = list(extensions)\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.WakuApplication.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def close(self) -&gt; None:\n    if not self._initialized:\n        return\n    await self._call_on_shutdown_extensions()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n</code></pre>"},{"location":"reference/#waku.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(\n    self,\n) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(self._root_module_type).build()\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extensions=self._extensions,\n    )\n</code></pre>"},{"location":"reference/#waku.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.Module","title":"Module","text":"<pre><code>Module(module_type: ModuleType, metadata: ModuleMetadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n\n    self.providers: Final[Sequence[BaseProvider]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[type[object] | ModuleType | DynamicModule]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n</code></pre>"},{"location":"reference/#waku.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Final[UUID] = id\n</code></pre>"},{"location":"reference/#waku.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: Final[ModuleType] = module_type\n</code></pre>"},{"location":"reference/#waku.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers: Final[Sequence[BaseProvider]] = providers\n</code></pre>"},{"location":"reference/#waku.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports: Final[Sequence[ModuleType | DynamicModule]] = (\n    imports\n)\n</code></pre>"},{"location":"reference/#waku.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports: Final[\n    Sequence[type[object] | ModuleType | DynamicModule]\n] = exports\n</code></pre>"},{"location":"reference/#waku.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Final[Sequence[ModuleExtension]] = extensions\n</code></pre>"},{"location":"reference/#waku.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: Final[bool] = is_global\n</code></pre>"},{"location":"reference/#waku.Module.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/#waku.Module.provider","title":"provider  <code>cached</code> <code>property</code>","text":"<pre><code>provider: BaseProvider\n</code></pre>"},{"location":"reference/#waku.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        type[object] | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[BaseProvider]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[type[object] | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[type[object] | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.application","title":"application","text":""},{"location":"reference/#waku.application.WakuApplication","title":"WakuApplication","text":"<pre><code>WakuApplication(\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    *,\n    container: AsyncContainer,\n    registry: ModuleRegistry,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n) -&gt; None:\n    self._container = container\n    self._registry = registry\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extensions = list(extensions)\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.container","title":"container  <code>property</code>","text":"<pre><code>container: AsyncContainer\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: ModuleRegistry\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.application.WakuApplication.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def close(self) -&gt; None:\n    if not self._initialized:\n        return\n    await self._call_on_shutdown_extensions()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.cqrs","title":"cqrs","text":""},{"location":"reference/#waku.cqrs.NextHandlerType","title":"NextHandlerType  <code>module-attribute</code>","text":"<pre><code>NextHandlerType: TypeAlias = Callable[\n    [RequestT], Awaitable[ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for events.</p>"},{"location":"reference/#waku.cqrs.IPipelineBehavior","title":"IPipelineBehavior","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Interface for pipeline behaviors that wrap request handling.</p>"},{"location":"reference/#waku.cqrs.IPipelineBehavior.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(\n    request: RequestT,\n    next_handler: NextHandlerType[RequestT, ResponseT],\n) -&gt; ResponseT\n</code></pre> <p>Handle the request and call the next handler in the pipeline.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to handle</p> <p> TYPE: <code>RequestT</code> </p> <code>next_handler</code> <p>Function to call the next handler in the pipeline</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The response from the pipeline</p> Source code in <code>src/waku/cqrs/contracts/pipeline.py</code> <pre><code>@abstractmethod\nasync def handle(self, request: RequestT, next_handler: NextHandlerType[RequestT, ResponseT]) -&gt; ResponseT:\n    \"\"\"Handle the request and call the next handler in the pipeline.\n\n    Args:\n        request: The request to handle\n        next_handler: Function to call the next handler in the pipeline\n\n    Returns:\n        The response from the pipeline\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.cqrs.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.cqrs.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventT]</code></p> <p>The event handler interface.</p> <p>Usage::</p> <p>class UserJoinedEventHandler(EventHandler[UserJoinedEvent])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, event: UserJoinedEvent) -&gt; None:\n      await self._meetings_api.notify_room(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"reference/#waku.cqrs.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: EventT) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: EventT) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default CQRS implementation.</p> <p>Initialize the mediator.</p> PARAMETER DESCRIPTION <code>container</code> <p>Container used to resolve handlers and behaviors</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>event_publisher</code> <p>Function to publish events to handlers</p> <p> TYPE: <code>EventPublisher</code> </p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>def __init__(self, container: AsyncContainer, event_publisher: EventPublisher) -&gt; None:\n    \"\"\"Initialize the mediator.\n\n    Args:\n        container: Container used to resolve handlers and behaviors\n        event_publisher: Function to publish events to handlers\n    \"\"\"\n    self._container = container\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the CQRS pipeline chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the CQRS pipeline chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.cqrs.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.cqrs.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a cqrs to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.cqrs.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the cqrs to be handled by multiple handlers.</p>"},{"location":"reference/#waku.cqrs.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the cqrs middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.cqrs.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    pipeline_behaviors: Sequence[\n        type[IPipelineBehavior[Any, Any]]\n    ] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the cqrs pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the cqrs interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>pipeline_behaviors</code> <p>A sequence of pipeline behavior configurations that will be applied to the cqrs pipeline. Behaviors are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[IPipelineBehavior[Any, Any]]]</code> </p> Example <pre><code>config = MediatorConfig(\n    pipeline_behaviors=[\n        LoggingBehavior,\n        ValidationBehavior,\n    ]\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorConfig.pipeline_behaviors","title":"pipeline_behaviors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pipeline_behaviors: Sequence[\n    type[IPipelineBehavior[Any, Any]]\n] = ()\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n    self._behavior_map = PipelineBehaviourMap()\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[\n        type[IPipelineBehavior[RequestT, ResponseT]]\n    ]\n    | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, ResponseT]]] | None = None,\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    if behaviors:\n        self._behavior_map.bind(request_type, behaviors)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n            self._create_pipeline_behavior_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.cqrs.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=[\n            *cls._create_mediator_providers(config_),\n            *cls._create_pipeline_behavior_providers(config_),\n        ],\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: RequestMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        raise RequestHandlerAlreadyRegistered(request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.RequestMap.merge","title":"merge","text":"<pre><code>merge(other: RequestMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts","title":"contracts","text":""},{"location":"reference/#waku.cqrs.contracts.event","title":"event","text":""},{"location":"reference/#waku.cqrs.contracts.event.EventT","title":"EventT  <code>module-attribute</code>","text":"<pre><code>EventT = TypeVar(\n    'EventT', bound='Event', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.event.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for events.</p>"},{"location":"reference/#waku.cqrs.contracts.pipeline","title":"pipeline","text":""},{"location":"reference/#waku.cqrs.contracts.pipeline.NextHandlerType","title":"NextHandlerType  <code>module-attribute</code>","text":"<pre><code>NextHandlerType: TypeAlias = Callable[\n    [RequestT], Awaitable[ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.pipeline.IPipelineBehavior","title":"IPipelineBehavior","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>Interface for pipeline behaviors that wrap request handling.</p>"},{"location":"reference/#waku.cqrs.contracts.pipeline.IPipelineBehavior.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(\n    request: RequestT,\n    next_handler: NextHandlerType[RequestT, ResponseT],\n) -&gt; ResponseT\n</code></pre> <p>Handle the request and call the next handler in the pipeline.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to handle</p> <p> TYPE: <code>RequestT</code> </p> <code>next_handler</code> <p>Function to call the next handler in the pipeline</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The response from the pipeline</p> Source code in <code>src/waku/cqrs/contracts/pipeline.py</code> <pre><code>@abstractmethod\nasync def handle(self, request: RequestT, next_handler: NextHandlerType[RequestT, ResponseT]) -&gt; ResponseT:\n    \"\"\"Handle the request and call the next handler in the pipeline.\n\n    Args:\n        request: The request to handle\n        next_handler: Function to call the next handler in the pipeline\n\n    Returns:\n        The response from the pipeline\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request","title":"request","text":""},{"location":"reference/#waku.cqrs.contracts.request.RequestT","title":"RequestT  <code>module-attribute</code>","text":"<pre><code>RequestT = TypeVar(\n    'RequestT', bound='Request[Any]', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.ResponseT","title":"ResponseT  <code>module-attribute</code>","text":"<pre><code>ResponseT = TypeVar(\n    'ResponseT',\n    bound='Response | None',\n    default=None,\n    covariant=True,\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.cqrs.contracts.request.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.cqrs.contracts.request.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.cqrs.events","title":"events","text":""},{"location":"reference/#waku.cqrs.events.handler","title":"handler","text":""},{"location":"reference/#waku.cqrs.events.handler.EventHandlerType","title":"EventHandlerType  <code>module-attribute</code>","text":"<pre><code>EventHandlerType: TypeAlias = type[EventHandler[EventT]]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.handler.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventT]</code></p> <p>The event handler interface.</p> <p>Usage::</p> <p>class UserJoinedEventHandler(EventHandler[UserJoinedEvent])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, event: UserJoinedEvent) -&gt; None:\n      await self._meetings_api.notify_room(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"reference/#waku.cqrs.events.handler.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event: EventT) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: EventT) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map","title":"map","text":""},{"location":"reference/#waku.cqrs.events.map.EventMapRegistry","title":"EventMapRegistry  <code>module-attribute</code>","text":"<pre><code>EventMapRegistry: TypeAlias = MutableMapping[\n    type[EventT], list[EventHandlerType[EventT]]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap","title":"EventMap","text":"<pre><code>EventMap()\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: EventMapRegistry[Any] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: EventMapRegistry[Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.bind","title":"bind","text":"<pre><code>bind(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def bind(self, event_type: type[EventT], handler_types: list[EventHandlerType[EventT]]) -&gt; Self:\n    for handler_type in handler_types:\n        if handler_type in self._registry[event_type]:\n            raise EventHandlerAlreadyRegistered(event_type, handler_type)\n        self._registry[event_type].append(handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.events.map.EventMap.merge","title":"merge","text":"<pre><code>merge(other: EventMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/events/map.py</code> <pre><code>def merge(self, other: EventMap) -&gt; Self:\n    for event_type, handlers in other.registry.items():\n        self.bind(event_type, handlers)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.events.publish","title":"publish","text":""},{"location":"reference/#waku.cqrs.events.publish.EventPublisher","title":"EventPublisher","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.cqrs.events.publish.SequentialEventPublisher","title":"SequentialEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.events.publish.GroupEventPublisher","title":"GroupEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.cqrs.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.cqrs.exceptions.MediatorError","title":"MediatorError","text":"<p>               Bases: <code>WakuError</code></p> <p>Base exception for all cqrs-related errors.</p>"},{"location":"reference/#waku.cqrs.exceptions.ImproperlyConfiguredError","title":"ImproperlyConfiguredError","text":"<p>               Bases: <code>MediatorError</code></p> <p>Raised when cqrs configuration is invalid.</p>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered","title":"RequestHandlerAlreadyRegistered","text":"<pre><code>RequestHandlerAlreadyRegistered(\n    request_type: type[Request[Any]],\n    handler_type: RequestHandlerType[Any, Any],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a request handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[Request[Any]], handler_type: RequestHandlerType[Any, Any]) -&gt; None:\n    self.request_type = request_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerNotFound","title":"RequestHandlerNotFound","text":"<pre><code>RequestHandlerNotFound(request_type: type[Request[Any]])\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when a request handler is not found.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[Request[Any]]) -&gt; None:\n    self.request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.RequestHandlerNotFound.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered","title":"EventHandlerAlreadyRegistered","text":"<pre><code>EventHandlerAlreadyRegistered(\n    event_type: type[EventT],\n    handler_type: EventHandlerType[EventT],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when an event handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, event_type: type[EventT], handler_type: EventHandlerType[EventT]) -&gt; None:\n    self.event_type = event_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type = event_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerNotFound","title":"EventHandlerNotFound","text":"<pre><code>EventHandlerNotFound(event_type: type[Event])\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when an event handler is not found.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, event_type: type[Event]) -&gt; None:\n    self.event_type = event_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.EventHandlerNotFound.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type = event_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered","title":"PipelineBehaviorAlreadyRegistered","text":"<pre><code>PipelineBehaviorAlreadyRegistered(\n    request_type: type[Request],\n    behavior_type: type[IPipelineBehavior[Any, Any]],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a pipeline behavior is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> </p> <code>behavior_type</code> <p>The type of behavior that was already registered.</p> <p> </p> Source code in <code>src/waku/cqrs/exceptions.py</code> <pre><code>def __init__(self, request_type: type[Request], behavior_type: type[IPipelineBehavior[Any, Any]]) -&gt; None:\n    self.request_type = request_type\n    self.behavior_type = behavior_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.cqrs.exceptions.PipelineBehaviorAlreadyRegistered.behavior_type","title":"behavior_type  <code>instance-attribute</code>","text":"<pre><code>behavior_type = behavior_type\n</code></pre>"},{"location":"reference/#waku.cqrs.impl","title":"impl","text":""},{"location":"reference/#waku.cqrs.impl.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    container: AsyncContainer,\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default CQRS implementation.</p> <p>Initialize the mediator.</p> PARAMETER DESCRIPTION <code>container</code> <p>Container used to resolve handlers and behaviors</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>event_publisher</code> <p>Function to publish events to handlers</p> <p> TYPE: <code>EventPublisher</code> </p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>def __init__(self, container: AsyncContainer, event_publisher: EventPublisher) -&gt; None:\n    \"\"\"Initialize the mediator.\n\n    Args:\n        container: Container used to resolve handlers and behaviors\n        event_publisher: Function to publish events to handlers\n    \"\"\"\n    self._container = container\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.cqrs.impl.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the CQRS pipeline chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the CQRS pipeline chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.cqrs.impl.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/cqrs/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces","title":"interfaces","text":""},{"location":"reference/#waku.cqrs.interfaces.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the cqrs middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.cqrs.interfaces.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the cqrs to be handled by multiple handlers.</p>"},{"location":"reference/#waku.cqrs.interfaces.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a cqrs to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.cqrs.interfaces.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.interfaces.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/cqrs/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.cqrs.modules","title":"modules","text":""},{"location":"reference/#waku.cqrs.modules.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    pipeline_behaviors: Sequence[\n        type[IPipelineBehavior[Any, Any]]\n    ] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the cqrs pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the cqrs interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>pipeline_behaviors</code> <p>A sequence of pipeline behavior configurations that will be applied to the cqrs pipeline. Behaviors are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[IPipelineBehavior[Any, Any]]]</code> </p> Example <pre><code>config = MediatorConfig(\n    pipeline_behaviors=[\n        LoggingBehavior,\n        ValidationBehavior,\n    ]\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type: type[IMediator] = Mediator\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher: type[EventPublisher] = (\n    SequentialEventPublisher\n)\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorConfig.pipeline_behaviors","title":"pipeline_behaviors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pipeline_behaviors: Sequence[\n    type[IPipelineBehavior[Any, Any]]\n] = ()\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.cqrs.modules.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    config_ = config or MediatorConfig()\n    return DynamicModule(\n        parent_module=cls,\n        providers=[\n            *cls._create_mediator_providers(config_),\n            *cls._create_pipeline_behavior_providers(config_),\n        ],\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n    self._behavior_map = PipelineBehaviourMap()\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[\n        type[IPipelineBehavior[RequestT, ResponseT]]\n    ]\n    | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n    *,\n    behaviors: list[type[IPipelineBehavior[RequestT, ResponseT]]] | None = None,\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    if behaviors:\n        self._behavior_map.bind(request_type, behaviors)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.modules.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> Source code in <code>src/waku/cqrs/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n            self._create_pipeline_behavior_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline","title":"pipeline","text":""},{"location":"reference/#waku.cqrs.pipeline.PipelineBehaviorWrapper","title":"PipelineBehaviorWrapper","text":"<pre><code>PipelineBehaviorWrapper(\n    behaviors: Sequence[\n        IPipelineBehavior[RequestT, ResponseT]\n    ],\n)\n</code></pre> <p>               Bases: <code>Generic[RequestT, ResponseT]</code></p> <p>Composes pipeline behaviors into a processing chain.</p> <p>Initialize the pipeline behavior chain.</p> PARAMETER DESCRIPTION <code>behaviors</code> <p>Sequence of pipeline behaviors to execute in order</p> <p> TYPE: <code>Sequence[IPipelineBehavior[RequestT, ResponseT]]</code> </p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def __init__(self, behaviors: Sequence[IPipelineBehavior[RequestT, ResponseT]]) -&gt; None:\n    \"\"\"Initialize the pipeline behavior chain.\n\n    Args:\n        behaviors: Sequence of pipeline behaviors to execute in order\n    \"\"\"\n    self._behaviors = list(behaviors)  # Convert to list immediately\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.PipelineBehaviorWrapper.wrap","title":"wrap","text":"<pre><code>wrap(\n    handle: NextHandlerType[RequestT, ResponseT],\n) -&gt; NextHandlerType[RequestT, ResponseT]\n</code></pre> <p>Create a pipeline that wraps the handler function with behaviors.</p> <p>Pipeline behaviors are executed in the order they are provided.</p> PARAMETER DESCRIPTION <code>handle</code> <p>The handler function to wrap with behaviors</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>NextHandlerType[RequestT, ResponseT]</code> <p>A function that executes the entire pipeline</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def wrap(self, handle: NextHandlerType[RequestT, ResponseT]) -&gt; NextHandlerType[RequestT, ResponseT]:\n    \"\"\"Create a pipeline that wraps the handler function with behaviors.\n\n    Pipeline behaviors are executed in the order they are provided.\n\n    Args:\n        handle: The handler function to wrap with behaviors\n\n    Returns:\n        A function that executes the entire pipeline\n    \"\"\"\n    for behavior in reversed(self._behaviors):\n        handle = functools.partial(behavior.handle, next_handler=handle)\n\n    return handle\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.chain","title":"chain","text":""},{"location":"reference/#waku.cqrs.pipeline.chain.PipelineBehaviorWrapper","title":"PipelineBehaviorWrapper","text":"<pre><code>PipelineBehaviorWrapper(\n    behaviors: Sequence[\n        IPipelineBehavior[RequestT, ResponseT]\n    ],\n)\n</code></pre> <p>               Bases: <code>Generic[RequestT, ResponseT]</code></p> <p>Composes pipeline behaviors into a processing chain.</p> <p>Initialize the pipeline behavior chain.</p> PARAMETER DESCRIPTION <code>behaviors</code> <p>Sequence of pipeline behaviors to execute in order</p> <p> TYPE: <code>Sequence[IPipelineBehavior[RequestT, ResponseT]]</code> </p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def __init__(self, behaviors: Sequence[IPipelineBehavior[RequestT, ResponseT]]) -&gt; None:\n    \"\"\"Initialize the pipeline behavior chain.\n\n    Args:\n        behaviors: Sequence of pipeline behaviors to execute in order\n    \"\"\"\n    self._behaviors = list(behaviors)  # Convert to list immediately\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.chain.PipelineBehaviorWrapper.wrap","title":"wrap","text":"<pre><code>wrap(\n    handle: NextHandlerType[RequestT, ResponseT],\n) -&gt; NextHandlerType[RequestT, ResponseT]\n</code></pre> <p>Create a pipeline that wraps the handler function with behaviors.</p> <p>Pipeline behaviors are executed in the order they are provided.</p> PARAMETER DESCRIPTION <code>handle</code> <p>The handler function to wrap with behaviors</p> <p> TYPE: <code>NextHandlerType[RequestT, ResponseT]</code> </p> RETURNS DESCRIPTION <code>NextHandlerType[RequestT, ResponseT]</code> <p>A function that executes the entire pipeline</p> Source code in <code>src/waku/cqrs/pipeline/chain.py</code> <pre><code>def wrap(self, handle: NextHandlerType[RequestT, ResponseT]) -&gt; NextHandlerType[RequestT, ResponseT]:\n    \"\"\"Create a pipeline that wraps the handler function with behaviors.\n\n    Pipeline behaviors are executed in the order they are provided.\n\n    Args:\n        handle: The handler function to wrap with behaviors\n\n    Returns:\n        A function that executes the entire pipeline\n    \"\"\"\n    for behavior in reversed(self._behaviors):\n        handle = functools.partial(behavior.handle, next_handler=handle)\n\n    return handle\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map","title":"map","text":""},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviorMapRegistry","title":"PipelineBehaviorMapRegistry  <code>module-attribute</code>","text":"<pre><code>PipelineBehaviorMapRegistry = MutableMapping[\n    type[RequestT],\n    list[type[IPipelineBehavior[RequestT, ResponseT]]],\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap","title":"PipelineBehaviourMap","text":"<pre><code>PipelineBehaviourMap()\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: PipelineBehaviorMapRegistry[Any, Any] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: PipelineBehaviorMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    behavior_types: list[\n        type[IPipelineBehavior[RequestT, ResponseT]]\n    ],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def bind(\n    self,\n    request_type: type[RequestT],\n    behavior_types: list[type[IPipelineBehavior[RequestT, ResponseT]]],\n) -&gt; Self:\n    for behavior_type in behavior_types:\n        if behavior_type in self._registry[request_type]:\n            raise PipelineBehaviorAlreadyRegistered(request_type, behavior_type)\n        self._registry[request_type].append(behavior_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.pipeline.map.PipelineBehaviourMap.merge","title":"merge","text":"<pre><code>merge(other: PipelineBehaviourMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/pipeline/map.py</code> <pre><code>def merge(self, other: PipelineBehaviourMap) -&gt; Self:\n    for event_type, handlers in other.registry.items():\n        self.bind(event_type, handlers)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.requests","title":"requests","text":""},{"location":"reference/#waku.cqrs.requests.handler","title":"handler","text":""},{"location":"reference/#waku.cqrs.requests.handler.RequestHandlerType","title":"RequestHandlerType  <code>module-attribute</code>","text":"<pre><code>RequestHandlerType: TypeAlias = type[\n    RequestHandler[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.handler.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request: RequestT) -&gt; ResponseT\n</code></pre> Source code in <code>src/waku/cqrs/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map","title":"map","text":""},{"location":"reference/#waku.cqrs.requests.map.RequestMapRegistry","title":"RequestMapRegistry  <code>module-attribute</code>","text":"<pre><code>RequestMapRegistry: TypeAlias = MutableMapping[\n    type[RequestT], RequestHandlerType[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: RequestMapRegistry[Any, Any]\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.bind","title":"bind","text":"<pre><code>bind(\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        raise RequestHandlerAlreadyRegistered(request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.requests.map.RequestMap.merge","title":"merge","text":"<pre><code>merge(other: RequestMap) -&gt; Self\n</code></pre> Source code in <code>src/waku/cqrs/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.cqrs.utils","title":"utils","text":""},{"location":"reference/#waku.cqrs.utils.get_request_response_type","title":"get_request_response_type  <code>cached</code>","text":"<pre><code>get_request_response_type(\n    request_type: type[Request[ResponseT]],\n) -&gt; type[ResponseT]\n</code></pre> Source code in <code>src/waku/cqrs/utils.py</code> <pre><code>@functools.cache\ndef get_request_response_type(request_type: type[Request[ResponseT]]) -&gt; type[ResponseT]:\n    return typing.cast(type[ResponseT], typing.get_args(get_original_bases(request_type)[0])[0])\n</code></pre>"},{"location":"reference/#waku.di","title":"di","text":""},{"location":"reference/#waku.di.provider","title":"provider","text":"<pre><code>provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = REQUEST,\n    provided_type: Any = None,\n    cache: bool = True,\n) -&gt; Provider\n</code></pre> <p>Create a Dishka provider for a callable or type.</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>scope</code> <p>Scope of the dependency (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>cache</code> <p>Whether to cache the instance in the scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Configured provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def provider(\n    source: Callable[..., Any] | type[Any],\n    *,\n    scope: Scope = Scope.REQUEST,\n    provided_type: Any = None,\n    cache: bool = True,\n) -&gt; Provider:\n    \"\"\"Create a Dishka provider for a callable or type.\n\n    Args:\n        source: Callable or type to provide as a dependency.\n        scope: Scope of the dependency (default: Scope.REQUEST).\n        provided_type: Explicit type to provide (default: inferred).\n        cache: Whether to cache the instance in the scope.\n\n    Returns:\n        Provider: Configured provider instance.\n    \"\"\"\n    provider_ = Provider(scope=scope)\n    provider_.provide(source, provides=provided_type, cache=cache)\n    return provider_\n</code></pre>"},{"location":"reference/#waku.di.singleton","title":"singleton","text":"<pre><code>singleton(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider\n</code></pre> <p>Create a singleton provider (lifetime: app).</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a singleton.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Singleton provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def singleton(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Create a singleton provider (lifetime: app).\n\n    Args:\n        source: Callable or type to provide as a singleton.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Singleton provider instance.\n    \"\"\"\n    return provider(source, scope=Scope.APP, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.di.scoped","title":"scoped","text":"<pre><code>scoped(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider\n</code></pre> <p>Create a scoped provider (lifetime: request).</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a scoped dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Scoped provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def scoped(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Create a scoped provider (lifetime: request).\n\n    Args:\n        source: Callable or type to provide as a scoped dependency.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Scoped provider instance.\n    \"\"\"\n    return provider(source, scope=Scope.REQUEST, provided_type=provided_type)\n</code></pre>"},{"location":"reference/#waku.di.transient","title":"transient","text":"<pre><code>transient(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider\n</code></pre> <p>Create a transient provider (new instance per injection).</p> PARAMETER DESCRIPTION <code>source</code> <p>Callable or type to provide as a transient dependency.</p> <p> TYPE: <code>Callable[..., Any] | type[Any]</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Transient provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def transient(\n    source: Callable[..., Any] | type[Any],\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Create a transient provider (new instance per injection).\n\n    Args:\n        source: Callable or type to provide as a transient dependency.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Transient provider instance.\n    \"\"\"\n    return provider(source, scope=Scope.REQUEST, provided_type=provided_type, cache=False)\n</code></pre>"},{"location":"reference/#waku.di.object_","title":"object_","text":"<pre><code>object_(\n    source: Any, *, provided_type: Any = None\n) -&gt; Provider\n</code></pre> <p>Provide the exact object passed at creation time as a singleton dependency.</p> <p>The provider always returns the same object instance, without instantiation or copying.</p> PARAMETER DESCRIPTION <code>source</code> <p>The object to provide as-is.</p> <p> TYPE: <code>Any</code> </p> <code>provided_type</code> <p>Explicit type to provide (default: inferred).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Provider that always returns the given object.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def object_(\n    source: Any,\n    *,\n    provided_type: Any = None,\n) -&gt; Provider:\n    \"\"\"Provide the exact object passed at creation time as a singleton dependency.\n\n    The provider always returns the same object instance, without instantiation or copying.\n\n    Args:\n        source: The object to provide as-is.\n        provided_type: Explicit type to provide (default: inferred).\n\n    Returns:\n        Provider: Provider that always returns the given object.\n    \"\"\"\n    return provider(lambda: source, scope=Scope.APP, provided_type=provided_type, cache=True)\n</code></pre>"},{"location":"reference/#waku.di.contextual","title":"contextual","text":"<pre><code>contextual(\n    provided_type: Any, *, scope: Scope = REQUEST\n) -&gt; Provider\n</code></pre> <p>Provide a dependency from the current context (e.g., app/request).</p> PARAMETER DESCRIPTION <code>provided_type</code> <p>The type to resolve from context.</p> <p> TYPE: <code>Any</code> </p> <code>scope</code> <p>Scope of the context variable (default: Scope.REQUEST).</p> <p> TYPE: <code>Scope</code> DEFAULT: <code>REQUEST</code> </p> RETURNS DESCRIPTION <code>Provider</code> <p>Contextual provider instance.</p> <p> TYPE: <code>Provider</code> </p> Source code in <code>src/waku/di.py</code> <pre><code>def contextual(\n    provided_type: Any,\n    *,\n    scope: Scope = Scope.REQUEST,\n) -&gt; Provider:\n    \"\"\"Provide a dependency from the current context (e.g., app/request).\n\n    Args:\n        provided_type: The type to resolve from context.\n        scope: Scope of the context variable (default: Scope.REQUEST).\n\n    Returns:\n        Provider: Contextual provider instance.\n    \"\"\"\n    provider_ = Provider()\n    provider_.from_context(provided_type, scope=scope)\n    return provider_\n</code></pre>"},{"location":"reference/#waku.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.exceptions.WakuError","title":"WakuError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/#waku.ext","title":"ext","text":""},{"location":"reference/#waku.ext.DEFAULT_EXTENSIONS","title":"DEFAULT_EXTENSIONS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EXTENSIONS: Sequence[ApplicationExtension] = (\n    ValidationExtension(\n        [DependenciesAccessibleRule()], strict=True\n    ),\n)\n</code></pre>"},{"location":"reference/#waku.ext.validation","title":"validation","text":""},{"location":"reference/#waku.ext.validation.ValidationRule","title":"ValidationRule","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.ext.validation.ValidationRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/ext/validation/_abc.py</code> <pre><code>def validate(self, context: ValidationContext) -&gt; list[ValidationError]: ...\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>WakuError</code></p>"},{"location":"reference/#waku.ext.validation.ValidationExtension","title":"ValidationExtension","text":"<pre><code>ValidationExtension(\n    rules: Sequence[ValidationRule], *, strict: bool = True\n)\n</code></pre> <p>               Bases: <code>AfterApplicationInit</code></p> Source code in <code>src/waku/ext/validation/_extension.py</code> <pre><code>def __init__(self, rules: Sequence[ValidationRule], *, strict: bool = True) -&gt; None:\n    self.rules = rules\n    self.strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.rules","title":"rules  <code>instance-attribute</code>","text":"<pre><code>rules = rules\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> Source code in <code>src/waku/ext/validation/_extension.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    context = ValidationContext(app=app)\n\n    errors_chain = chain.from_iterable(rule.validate(context) for rule in self.rules)\n    if errors := list(errors_chain):\n        self._raise(errors)\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules","title":"rules","text":""},{"location":"reference/#waku.ext.validation.rules.DependenciesAccessibleRule","title":"DependenciesAccessibleRule","text":"<pre><code>DependenciesAccessibleRule(cache_size: int = 1000)\n</code></pre> <p>               Bases: <code>ValidationRule</code></p> <p>Validates that all dependencies required by providers are accessible.</p> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, cache_size: int = 1000) -&gt; None:\n    self._cache = LRUCache[set[type[object]]](cache_size)\n    self._types_extractor = ModuleTypesExtractor(self._cache)\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.DependenciesAccessibleRule.validate","title":"validate","text":"<pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    self._cache.clear()  # Clear cache before validation\n\n    registry = context.app.registry\n    modules = list(registry.modules)\n\n    checker = DependencyAccessChecker(modules, context, self._types_extractor)\n    errors: list[ValidationError] = []\n\n    for module in modules:\n        module_provider = module.provider\n        for factory in module_provider.factories:\n            inaccessible_deps = checker.find_inaccessible_dependencies(\n                dependencies=factory.dependencies,\n                module=module,\n            )\n            errors.extend(\n                DependencyInaccessibleError(\n                    required_type=dep_type,\n                    required_by=factory.source,\n                    from_module=module,\n                )\n                for dep_type in inaccessible_deps\n            )\n\n    return errors\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.DependencyInaccessibleError","title":"DependencyInaccessibleError","text":"<pre><code>DependencyInaccessibleError(\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n)\n</code></pre> <p>               Bases: <code>ValidationError</code></p> <p>Error indicating a dependency is not accessible to a provider/module.</p> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n) -&gt; None:\n    self.required_type = required_type\n    self.required_by = required_by\n    self.from_module = from_module\n    super().__init__(str(self))\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.DependencyInaccessibleError.required_type","title":"required_type  <code>instance-attribute</code>","text":"<pre><code>required_type = required_type\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.DependencyInaccessibleError.required_by","title":"required_by  <code>instance-attribute</code>","text":"<pre><code>required_by = required_by\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.DependencyInaccessibleError.from_module","title":"from_module  <code>instance-attribute</code>","text":"<pre><code>from_module = from_module\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.dependency_accessible","title":"dependency_accessible","text":""},{"location":"reference/#waku.ext.validation.rules.dependency_accessible.DependencyInaccessibleError","title":"DependencyInaccessibleError","text":"<pre><code>DependencyInaccessibleError(\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n)\n</code></pre> <p>               Bases: <code>ValidationError</code></p> <p>Error indicating a dependency is not accessible to a provider/module.</p> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    required_type: type[object],\n    required_by: object,\n    from_module: Module,\n) -&gt; None:\n    self.required_type = required_type\n    self.required_by = required_by\n    self.from_module = from_module\n    super().__init__(str(self))\n</code></pre> <code></code> required_type <code>instance-attribute</code> \u00b6 <pre><code>required_type = required_type\n</code></pre> <code></code> required_by <code>instance-attribute</code> \u00b6 <pre><code>required_by = required_by\n</code></pre> <code></code> from_module <code>instance-attribute</code> \u00b6 <pre><code>from_module = from_module\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.dependency_accessible.DependencyAccessChecker","title":"DependencyAccessChecker","text":"<pre><code>DependencyAccessChecker(\n    modules: list[Module],\n    context: ValidationContext,\n    types_extractor: ModuleTypesExtractor,\n)\n</code></pre> <p>Handles dependency accessibility checks between modules.</p> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(\n    self,\n    modules: list[Module],\n    context: ValidationContext,\n    types_extractor: ModuleTypesExtractor,\n) -&gt; None:\n    self._modules = modules\n    self._context = context\n    self._registry = context.app.registry\n    self._type_provider = types_extractor\n</code></pre> <code></code> find_inaccessible_dependencies \u00b6 <pre><code>find_inaccessible_dependencies(\n    dependencies: Sequence[Any], module: Module\n) -&gt; Iterable[type[object]]\n</code></pre> <p>Find dependencies that are not accessible to a module.</p> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>def find_inaccessible_dependencies(self, dependencies: Sequence[Any], module: Module) -&gt; Iterable[type[object]]:\n    \"\"\"Find dependencies that are not accessible to a module.\"\"\"\n    return (\n        dependency.type_hint for dependency in dependencies if not self._is_accessible(dependency.type_hint, module)\n    )\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.dependency_accessible.DependenciesAccessibleRule","title":"DependenciesAccessibleRule","text":"<pre><code>DependenciesAccessibleRule(cache_size: int = 1000)\n</code></pre> <p>               Bases: <code>ValidationRule</code></p> <p>Validates that all dependencies required by providers are accessible.</p> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>def __init__(self, cache_size: int = 1000) -&gt; None:\n    self._cache = LRUCache[set[type[object]]](cache_size)\n    self._types_extractor = ModuleTypesExtractor(self._cache)\n</code></pre> <code></code> validate \u00b6 <pre><code>validate(\n    context: ValidationContext,\n) -&gt; list[ValidationError]\n</code></pre> Source code in <code>src/waku/ext/validation/rules/dependency_accessible.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    self._cache.clear()  # Clear cache before validation\n\n    registry = context.app.registry\n    modules = list(registry.modules)\n\n    checker = DependencyAccessChecker(modules, context, self._types_extractor)\n    errors: list[ValidationError] = []\n\n    for module in modules:\n        module_provider = module.provider\n        for factory in module_provider.factories:\n            inaccessible_deps = checker.find_inaccessible_dependencies(\n                dependencies=factory.dependencies,\n                module=module,\n            )\n            errors.extend(\n                DependencyInaccessibleError(\n                    required_type=dep_type,\n                    required_by=factory.source,\n                    from_module=module,\n                )\n                for dep_type in inaccessible_deps\n            )\n\n    return errors\n</code></pre>"},{"location":"reference/#waku.extensions","title":"extensions","text":"<p>Extension protocols for the waku framework.</p> <p>This module defines protocols for extending module behavior. These protocols allow for hooking into various lifecycle events.</p>"},{"location":"reference/#waku.extensions.ApplicationExtension","title":"ApplicationExtension  <code>module-attribute</code>","text":"<pre><code>ApplicationExtension: TypeAlias = (\n    OnApplicationInit | AfterApplicationInit\n)\n</code></pre>"},{"location":"reference/#waku.extensions.ModuleExtension","title":"ModuleExtension  <code>module-attribute</code>","text":"<pre><code>ModuleExtension: TypeAlias = (\n    OnModuleConfigure | OnModuleInit | OnModuleDestroy\n)\n</code></pre>"},{"location":"reference/#waku.extensions.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: WakuApplication) -&gt; None\n</code></pre> <p>Perform actions after application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def after_app_init(self, app: WakuApplication) -&gt; None:\n    \"\"\"Perform actions after application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleConfigure","title":"OnModuleConfigure","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module configuration.</p>"},{"location":"reference/#waku.extensions.OnModuleConfigure.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata: ModuleMetadata) -&gt; None\n</code></pre> <p>Perform actions before module metadata transformed to module.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    \"\"\"Perform actions before module metadata transformed to module.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleDestroy","title":"OnModuleDestroy","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module destroying.</p>"},{"location":"reference/#waku.extensions.OnModuleDestroy.on_module_destroy","title":"on_module_destroy  <code>async</code>","text":"<pre><code>on_module_destroy(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application shutdown.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_module_destroy(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application shutdown.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.factory","title":"factory","text":""},{"location":"reference/#waku.factory.ContainerConfig","title":"ContainerConfig  <code>dataclass</code>","text":"<pre><code>ContainerConfig(\n    *,\n    lock_factory: _LockFactory = Lock,\n    start_scope: Scope | None = None,\n    skip_validation: bool = False,\n    validation_settings: ValidationSettings = lambda: STRICT_VALIDATION(),\n)\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.lock_factory","title":"lock_factory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lock_factory: _LockFactory = Lock\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.start_scope","title":"start_scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_scope: Scope | None = None\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.skip_validation","title":"skip_validation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>skip_validation: bool = False\n</code></pre>"},{"location":"reference/#waku.factory.ContainerConfig.validation_settings","title":"validation_settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>validation_settings: ValidationSettings = field(\n    default_factory=lambda: STRICT_VALIDATION\n)\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory","title":"WakuFactory","text":"<pre><code>WakuFactory(\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[\n        ApplicationExtension\n    ] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def __init__(\n    self,\n    root_module_type: ModuleType,\n    /,\n    context: dict[Any, Any] | None = None,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n    container_config: ContainerConfig | None = None,\n) -&gt; None:\n    self._root_module_type = root_module_type\n\n    self._context = context\n    self._lifespan = lifespan\n    self._extensions = extensions\n    self._container_config = container_config or ContainerConfig()\n</code></pre>"},{"location":"reference/#waku.factory.WakuFactory.create","title":"create","text":"<pre><code>create() -&gt; WakuApplication\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>def create(\n    self,\n) -&gt; WakuApplication:\n    registry = ModuleRegistryBuilder(self._root_module_type).build()\n    container = self._build_container(registry.providers)\n    return WakuApplication(\n        container=container,\n        registry=registry,\n        lifespan=self._lifespan,\n        extensions=self._extensions,\n    )\n</code></pre>"},{"location":"reference/#waku.lifespan","title":"lifespan","text":""},{"location":"reference/#waku.lifespan.LifespanFunc","title":"LifespanFunc  <code>module-attribute</code>","text":"<pre><code>LifespanFunc: TypeAlias = (\n    Callable[\n        ['WakuApplication'],\n        AbstractAsyncContextManager[None],\n    ]\n    | AbstractAsyncContextManager[None]\n)\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper","title":"LifespanWrapper","text":"<pre><code>LifespanWrapper(lifespan_func: LifespanFunc)\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>def __init__(self, lifespan_func: LifespanFunc) -&gt; None:\n    self._lifespan_func = lifespan_func\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app: WakuApplication) -&gt; AsyncIterator[None]\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: WakuApplication) -&gt; AsyncIterator[None]:\n    ctx_manager = (\n        self._lifespan_func\n        if isinstance(self._lifespan_func, AbstractAsyncContextManager)\n        else self._lifespan_func(app)\n    )\n    async with ctx_manager:\n        yield\n</code></pre>"},{"location":"reference/#waku.modules","title":"modules","text":""},{"location":"reference/#waku.modules.ModuleType","title":"ModuleType  <code>module-attribute</code>","text":"<pre><code>ModuleType: TypeAlias = type[object | HasModuleMetadata]\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n    parent_module: ModuleType,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.modules.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module: ModuleType\n</code></pre>"},{"location":"reference/#waku.modules.HasModuleMetadata","title":"HasModuleMetadata","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.modules.ModuleCompiler","title":"ModuleCompiler","text":""},{"location":"reference/#waku.modules.ModuleCompiler.extract_metadata","title":"extract_metadata","text":"<pre><code>extract_metadata(\n    module_type: ModuleType | DynamicModule,\n) -&gt; tuple[ModuleType, ModuleMetadata]\n</code></pre> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def extract_metadata(self, module_type: ModuleType | DynamicModule) -&gt; tuple[ModuleType, ModuleMetadata]:\n    try:\n        return self._extract_metadata(cast(Hashable, module_type))\n    except AttributeError:\n        msg = f'{type(module_type).__name__} is not module'\n        raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata","title":"ModuleMetadata  <code>dataclass</code>","text":"<pre><code>ModuleMetadata(\n    *,\n    providers: list[BaseProvider] = list(),\n    imports: list[ModuleType | DynamicModule] = list(),\n    exports: list[\n        type[object] | ModuleType | DynamicModule\n    ] = list(),\n    extensions: list[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: list[BaseProvider] = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: list[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: list[type[object] | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: list[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.Module","title":"Module","text":"<pre><code>Module(module_type: ModuleType, metadata: ModuleMetadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n\n    self.providers: Final[Sequence[BaseProvider]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[type[object] | ModuleType | DynamicModule]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Final[UUID] = id\n</code></pre>"},{"location":"reference/#waku.modules.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: Final[ModuleType] = module_type\n</code></pre>"},{"location":"reference/#waku.modules.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers: Final[Sequence[BaseProvider]] = providers\n</code></pre>"},{"location":"reference/#waku.modules.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports: Final[Sequence[ModuleType | DynamicModule]] = (\n    imports\n)\n</code></pre>"},{"location":"reference/#waku.modules.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports: Final[\n    Sequence[type[object] | ModuleType | DynamicModule]\n] = exports\n</code></pre>"},{"location":"reference/#waku.modules.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Final[Sequence[ModuleExtension]] = extensions\n</code></pre>"},{"location":"reference/#waku.modules.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: Final[bool] = is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/#waku.modules.Module.provider","title":"provider  <code>cached</code> <code>property</code>","text":"<pre><code>provider: BaseProvider\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry","title":"ModuleRegistry","text":"<pre><code>ModuleRegistry(\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    extensions: list[ModuleExtension],\n    adjacency: AdjacencyMatrix,\n)\n</code></pre> <p>Immutable registry and graph for module queries, traversal, and lookups.</p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def __init__(\n    self,\n    *,\n    compiler: ModuleCompiler,\n    root_module: Module,\n    modules: dict[UUID, Module],\n    providers: list[BaseProvider],\n    extensions: list[ModuleExtension],\n    adjacency: AdjacencyMatrix,\n) -&gt; None:\n    self._compiler = compiler\n    self._root_module = root_module\n    self._modules = modules\n    self._providers = tuple(providers)\n    self._extensions = tuple(extensions)\n    self._adjacency = adjacency\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.root_module","title":"root_module  <code>property</code>","text":"<pre><code>root_module: Module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: tuple[Module, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.providers","title":"providers  <code>property</code>","text":"<pre><code>providers: tuple[BaseProvider, ...]\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.compiler","title":"compiler  <code>property</code>","text":"<pre><code>compiler: ModuleCompiler\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get","title":"get","text":"<pre><code>get(module_type: ModuleType | DynamicModule) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get(self, module_type: ModuleType | DynamicModule) -&gt; Module:\n    module_id = self._compiler.extract_metadata(module_type)[1].id\n    return self.get_by_id(module_id)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(module_id: UUID) -&gt; Module\n</code></pre> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def get_by_id(self, module_id: UUID) -&gt; Module:\n    module = self._modules.get(module_id)\n    if module is None:\n        msg = f'Module with ID {module_id} is not registered in the graph.'\n        raise KeyError(msg)\n    return module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistry.traverse","title":"traverse","text":"<pre><code>traverse(from_: Module | None = None) -&gt; Iterator[Module]\n</code></pre> <p>Traverse the module graph in depth-first post-order (children before parent) recursively.</p> PARAMETER DESCRIPTION <code>from_</code> <p>Start module (default: root)</p> <p> TYPE: <code>Module | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>Module</code> <p>Each traversed module (post-order)</p> <p> TYPE:: <code>Module</code> </p> Source code in <code>src/waku/modules/_registry.py</code> <pre><code>def traverse(self, from_: Module | None = None) -&gt; Iterator[Module]:\n    \"\"\"Traverse the module graph in depth-first post-order (children before parent) recursively.\n\n    Args:\n        from_: Start module (default: root)\n\n    Yields:\n        Module: Each traversed module (post-order)\n    \"\"\"\n    start_module = from_ or self._root_module\n    visited: set[UUID] = set()\n\n    def _dfs(module: Module) -&gt; Iterator[Module]:\n        if module.id in visited:\n            return\n\n        visited.add(module.id)\n\n        # Process children first (maintain original order)\n        neighbor_ids = self._adjacency[module.id]\n        for neighbor_id in neighbor_ids:\n            if neighbor_id == module.id:\n                continue\n            neighbor = self.get_by_id(neighbor_id)\n            yield from _dfs(neighbor)\n\n        # Process current module after children (post-order)\n        yield module\n\n    yield from _dfs(start_module)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder","title":"ModuleRegistryBuilder","text":"<pre><code>ModuleRegistryBuilder(\n    root_module_type: ModuleType,\n    compiler: ModuleCompiler | None = None,\n)\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def __init__(self, root_module_type: ModuleType, compiler: ModuleCompiler | None = None) -&gt; None:\n    self._compiler: Final = compiler or ModuleCompiler()\n    self._root_module_type: Final = root_module_type\n    self._modules: dict[UUID, Module] = {}\n    self._providers: list[BaseProvider] = []\n    self._extensions: list[ModuleExtension] = []\n\n    self._metadata_cache: dict[ModuleType | DynamicModule, tuple[ModuleType, ModuleMetadata]] = {}\n</code></pre>"},{"location":"reference/#waku.modules.ModuleRegistryBuilder.build","title":"build","text":"<pre><code>build() -&gt; ModuleRegistry\n</code></pre> Source code in <code>src/waku/modules/_registry_builder.py</code> <pre><code>def build(self) -&gt; ModuleRegistry:\n    modules, adjacency = self._collect_modules()\n    root_module = self._register_modules(modules)\n    return self._build_registry(root_module, adjacency)\n</code></pre>"},{"location":"reference/#waku.modules.module","title":"module","text":"<pre><code>module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[\n        type[object] | ModuleType | DynamicModule\n    ] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[BaseProvider]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[type[object] | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[BaseProvider] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[type[object] | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        for extension in metadata.extensions:\n            if isinstance(extension, OnModuleConfigure):\n                extension.on_module_configure(metadata)\n\n        setattr(cls, _MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.testing","title":"testing","text":""},{"location":"reference/#waku.testing.override","title":"override","text":"<pre><code>override(\n    container: AsyncContainer, *providers: BaseProvider\n) -&gt; Iterator[None]\n</code></pre> <p>Temporarily override providers in an AsyncContainer for testing.</p> PARAMETER DESCRIPTION <code>container</code> <p>The container whose providers will be overridden.</p> <p> TYPE: <code>AsyncContainer</code> </p> <code>*providers</code> <p>Providers to override in the container.</p> <p> TYPE: <code>BaseProvider</code> DEFAULT: <code>()</code> </p> YIELDS DESCRIPTION <code>None</code> <p>Context in which the container uses the overridden providers.</p> <p> TYPE:: <code>None</code> </p> Example <pre><code>from waku import WakuFactory, module\nfrom waku.di import Scope, singleton\nfrom waku.testing import override\n\n\nclass Service: ...\n\n\nclass ServiceOverride(Service): ...\n\n\nwith override(application.container, singleton(ServiceOverride, provided_type=Service)):\n    service = await application.container.get(Service)\n    assert isinstance(service, ServiceOverride)\n</code></pre> Source code in <code>src/waku/testing.py</code> <pre><code>@contextmanager\ndef override(container: AsyncContainer, *providers: BaseProvider) -&gt; Iterator[None]:\n    \"\"\"Temporarily override providers in an AsyncContainer for testing.\n\n    Args:\n        container: The container whose providers will be overridden.\n        *providers: Providers to override in the container.\n\n    Yields:\n        None: Context in which the container uses the overridden providers.\n\n    Example:\n        ```python\n        from waku import WakuFactory, module\n        from waku.di import Scope, singleton\n        from waku.testing import override\n\n\n        class Service: ...\n\n\n        class ServiceOverride(Service): ...\n\n\n        with override(application.container, singleton(ServiceOverride, provided_type=Service)):\n            service = await application.container.get(Service)\n            assert isinstance(service, ServiceOverride)\n        ```\n    \"\"\"\n    new_container = make_async_container(\n        _container_provider(container),\n        *providers,\n        context=container._context,  # noqa: SLF001\n    )\n    _swap(container, new_container)\n    yield\n    _swap(new_container, container)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering a contribution to <code>waku</code>! \ud83c\udf89</p> <p>This guide will help you get started and ensure a smooth process.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher</li> <li>uv \u2013 a modern Python package manager</li> <li>Task \u2013 a task runner for automating development workflows (we recommend setting up auto-completion for Task)</li> <li>Git</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Install UV (if not already installed):</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# For other platforms, see:\n# https://docs.astral.sh/uv/getting-started/installation/\n\n# If uv is already installed, ensure it's up to date:\nuv self update\n</code></pre> </li> <li> <p>Install Task (if not already installed):</p> <pre><code># Using the install script\nsh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin\n\n# For other installation options, see:\n# https://taskfile.dev/installation/\n</code></pre> </li> <li> <p>Set up the development environment:</p> <pre><code># Install dependencies and configure pre-commit hooks\ntask install\n</code></pre> <p>Tip: Run <code>task -l</code> after setup to verify everything is working and to see available commands.</p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Fork the repository to your own GitHub account.</li> <li>Clone your fork locally:     <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre></li> <li>Create a new branch for your changes:     <pre><code>git checkout -b feat/your-feature-name\n</code></pre></li> <li>Make your changes, following our code style guidelines.</li> <li>Write or update tests for your changes.</li> <li>Run all checks and ensure tests pass:     <pre><code>task\n</code></pre></li> <li>Commit your changes with clear, descriptive messages.</li> <li>Push to your fork:     <pre><code>git push origin feat/your-feature-name\n</code></pre></li> <li>Open a pull request on GitHub. Link related issues in your PR description (e.g., \"Fixes #123\").</li> <li>Participate in the review process and make any requested changes.</li> </ol>"},{"location":"contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li> Tests added or updated</li> <li> Documentation updated (if needed)</li> <li> Code is formatted and linted</li> <li> All checks pass</li> <li> Type hints added or refined</li> <li> Commit messages include a detailed description for the changelog</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Ensure your changes are thoroughly tested by running the following commands:</p> <pre><code># Run all checks (recommended)\ntask\n\n# Run linters and type checkers\ntask check\n\n# Run specific checks\ntask test         # Run tests only\ntask test:cov     # Run tests with coverage\ntask lint         # Run linters only\ntask format       # Format code\ntask typecheck    # Run type checkers only\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Ruff for linting and formatting</li> <li>MyPy and basedpyright for type checking</li> <li>pre-commit for running checks before commits and pushes</li> </ul> <p>Key style guidelines:</p> <ul> <li>Maximum line length: 120 characters</li> <li>Use explicit type annotations throughout the codebase</li> <li>Follow PEP 8 conventions</li> <li>Write descriptive docstrings using the Google style</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you have questions or need help, you can: - Open a discussion - Open an issue for bugs or feature requests</p>"},{"location":"contributing/#first-time-contributors","title":"First-time Contributors","text":"<ul> <li>Look for issues labeled \"good first issue\" or \"help wanted\".</li> <li>Comment on the issue to let others know you're working on it.</li> <li>Don't hesitate to ask questions if anything is unclear.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Before creating an issue:</p> <ul> <li>Search existing issues to avoid duplicates.</li> <li>Use the appropriate issue template for bug reports or feature requests.</li> <li>Provide as much context as possible (e.g., steps to reproduce, environment details).</li> </ul> <p>Please follow the bug report and feature request templates when submitting issues.</p> <p>We welcome: - Bug reports - Feature requests - Documentation improvements - General questions or ideas</p>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<ul> <li><code>src/</code> \u2013 main source code</li> <li><code>tests/</code> \u2013 test suite</li> <li><code>docs/</code> \u2013 documentation</li> <li><code>Taskfile.yml</code> \u2013 development automation</li> <li><code>README.md</code> \u2013 project overview</li> </ul>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<ul> <li>Use clear, descriptive commit messages.</li> <li>Example: <code>fix(core): handle edge case in dependency resolution</code></li> </ul> <p>Thank you for contributing to <code>waku</code>! \ud83d\ude4f</p>"},{"location":"contributing/docs/","title":"Documentation","text":""},{"location":"contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub or by opening an issue.</p>"},{"location":"contributing/docs/#how-to-get-started","title":"How to get started","text":"<ol> <li>Follow the steps for development setup in the contributing guide</li> <li> <p>Start the local documentation server for live preview of changes     <pre><code>mkdocs serve\n</code></pre></p> </li> <li> <p>Go to the <code>docs/</code> directory and make your changes</p> </li> </ol> <p>After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"examples/cqrs/","title":"Mediator (CQRS)","text":"<p>Based on the CQRS pattern, the mediator is used to decouple the command and query logic from the domain model.</p> <p>Implementation heavily inspired by C# MediatR library.</p> <p>For full documentation, visit the Mediator (CQRS) section.</p>"},{"location":"examples/cqrs/#code","title":"Code","text":""},{"location":"examples/modularity/","title":"Modularity","text":"<p>Example of how to use modules, dynamic modules and linking them together to build an application.</p> <p>For full documentation on modules, visit the Modules section.</p>"},{"location":"examples/modularity/#code","title":"Code","text":""},{"location":"integrations/asgi/","title":"ASGI Integration","text":"<p><code>waku</code> can be seamlessly integrated into any ASGI application. To achieve this, set up <code>waku</code> as you normally would, then add the <code>ApplicationMiddleware</code> to your ASGI application\u2019s middleware stack.</p>"},{"location":"integrations/asgi/#example-with-fastapi","title":"Example with FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.middleware import Middleware\nfrom waku import WakuApplication\nfrom waku.contrib.asgi import WakuMiddleware\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the FastAPI app with the waku middleware\napp = FastAPI(\n    middleware=[\n        Middleware(WakuMiddleware, application=application),\n    ],\n)\n</code></pre> <p>In this example, the <code>ApplicationMiddleware</code> bridges <code>waku</code> with FastAPI, allowing dependency injection and module management within your ASGI routes.</p>"},{"location":"integrations/litestar/","title":"Litestar Integration","text":"<p><code>waku</code> can be seamlessly integrated with Litestar using the <code>ApplicationPlugin</code>. To do this, set up <code>waku</code> as usual and then include the plugin in your Litestar application configuration.</p>"},{"location":"integrations/litestar/#example","title":"Example","text":"<p>Here\u2019s how to integrate <code>waku</code> with a Litestar application:</p> <pre><code>from litestar import Litestar\nfrom waku import WakuApplication\nfrom waku.contrib.litestar import WakuPlugin\n\n\ndef bootstrap_application() -&gt; WakuApplication:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the Litestar app with the waku plugin\napp = Litestar(plugins=[WakuPlugin(application)])\n</code></pre> <p>In this example, the <code>ApplicationPlugin</code> enables <code>waku</code> dependency injection and module system within your Litestar application.</p>"},{"location":"usage/lifespan/","title":"Lifespan","text":""},{"location":"usage/modules/","title":"Modules","text":"<p><code>waku</code> modularity system is heavily inspired by the NestJS and Tramvai frameworks.</p> <p>The concept of modularity is well-explained with examples in the NestJS documentation.</p>"},{"location":"usage/modules/#module","title":"Module","text":"<p>A module is a class annotated with the <code>@module()</code> decorator. This decorator attaches metadata to the class, which <code>waku</code> uses to construct the application graph.</p> <p>Every <code>waku</code> application has at least one module: the root module, also known as the composition root. This module serves as the starting point for <code>waku</code> to build the entire application graph.</p> Parameter Description <code>providers</code> List of providers for dependency injection <code>imports</code> List of modules imported by this module <code>exports</code> List of types or modules exported by this module <code>extensions</code> List of module extensions for lifecycle hooks <code>is_global</code> Whether this module is global or not <p>The module encapsulates providers by default, meaning you can only inject providers that are either part of the current module or explicitly exported from other imported modules. The exported providers from a module essentially serve as the module's public interface or API.</p> <pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.config.module import ConfigModule\n\n\nclass UsersService:\n    pass\n\n\n@module(\n    providers=[Scoped(UsersService)],  # Register the service with a scoped lifetime\n    imports=[ConfigModule],  # Import another module\n    exports=[UsersService],  # Expose the service to other modules\n)\nclass UsersModule:\n    pass\n\n\n@module(imports=[UsersModule])  # Root module importing UsersModule\nclass AppModule:\n    pass\n</code></pre> <p>Note</p> <p>Encapsulation is enforced by validators, which you can disable at runtime if needed. However, disabling them entirely is not recommended, as they help maintain modularity.</p>"},{"location":"usage/modules/#module-re-exporting","title":"Module Re-exporting","text":"<p>You can re-export a module by including it in the <code>exports</code> list of another module. This is useful for exposing a module\u2019s providers to other modules that import the re-exporting module.</p> <pre><code>@module(\n    imports=[UsersModule],\n    exports=[UsersModule],\n)\nclass IAMModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#global-modules","title":"Global modules","text":"<p>If you need to import the same set of modules across your application, you can mark a module as global. Once a module is global, its providers can be injected anywhere in the application without requiring explicit imports in every module.</p> <p>To make a module global, set the <code>is_global</code> param to <code>True</code> in the <code>@module()</code> decorator.</p> <p>Note</p> <p>Root module are always global.</p> <p>Warning</p> <p>Global modules are not recommended for large applications, as they can lead to tight coupling and make the application harder to maintain.</p> <pre><code>from waku import module\n\n\n@module(is_global=True)\nclass UsersModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#dynamic-module","title":"Dynamic Module","text":"<p>Dynamic modules allow you to create modules dynamically based on conditions, such as the runtime environment of your application.</p> <pre><code>from waku import DynamicModule, module\nfrom waku.di import Scoped\n\n\nclass ConfigService:\n    pass\n\n\nclass DevConfigService(ConfigService):\n    pass\n\n\nclass DefaultConfigService(ConfigService):\n    pass\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # Choose the config provider based on the environment\n        config_provider = DevConfigService if env == 'dev' else DefaultConfigService\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Scoped(config_provider, type_=ConfigService)],  # Register with interface type\n        )\n</code></pre> <p>And then you can use it in any of your modules or in the root module:</p> <pre><code>from waku import module\n\nfrom app.modules.config.module import ConfigModule\n\n\n@module(\n    imports=[\n        ConfigModule.register(env='dev'),\n    ],\n)\nclass AppModule:\n    pass\n</code></pre> <p>You can also make a dynamic module global by setting <code>is_global=True</code> in the <code>DynamicModule</code> constructor.</p> <p>Note</p> <p>While you can use any method name instead of <code>register</code>, we recommend sticking with <code>register</code> for consistency.</p>"},{"location":"usage/providers/","title":"Providers","text":""},{"location":"usage/providers/#introduction","title":"Introduction","text":"<p>Providers are the core of <code>waku</code> dependency injection system. Idea behind a provider is that it can be injected as a dependency into other provider constructors, allowing objects to form various relationships with each other.</p> <p><code>waku</code> responsibility is to \"wire up\" all the providers using DI framework and manage the lifecycle its lifecycle. This way you can focus on writing your application logic.</p>"},{"location":"usage/providers/#dependency-injection","title":"Dependency Injection","text":"<p><code>waku</code> is designed to be modular and extensible. To support this principle, it provides a flexible dependency injection (DI) system that integrates seamlessly with various DI frameworks. <code>waku</code> itself acts like an IoC-container, allowing you to register and resolve dependencies using modules system.</p> <p>Note</p> <p>Instead of relying on a specific DI framework, <code>waku</code> uses an interface called <code>DependencyProvider</code>. This allows you to choose any DI framework you prefer (see Included Dependency Providers) or even create your own provider.</p>"},{"location":"usage/providers/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that addresses the issue of tightly coupled code by decoupling the creation and management of dependencies from the classes that rely on them. In traditional approaches, classes directly instantiate their dependencies, resulting in rigid, hard-to-maintain code. DI solves this problem by enabling dependencies to be supplied externally, typically through mechanisms like constructor or setter injection.</p> <p>By shifting the responsibility of dependency management outside the class, DI promotes loose coupling, allowing classes to focus on their core functionality rather than how dependencies are created. This separation enhances maintainability, testability, and flexibility, as dependencies can be easily swapped or modified without altering the class's code. Ultimately, DI improves system design by reducing interdependencies and making code more modular and scalable.</p> Manual DI Example <pre><code>from abc import ABC, abstractmethod\n\n\n# Use an interface to define contract for clients\n# This allows us injecting different implementations\nclass IClient(ABC):\n    @abstractmethod\n    def request(self, url: str) -&gt; str:\n        pass\n\n\n# Regular implementation\nclass RealClient(IClient):\n    def request(self, url: str) -&gt; str:\n        # Some HTTP requesting logic\n        return f'\"{url}\" call result'\n\n\n# Implementation for tests\nclass MockClient(IClient):\n    def __init__(self, return_data: str) -&gt; None:\n        self._return_data = return_data\n\n    def request(self, url: str) -&gt; str:\n        # Mocked behavior for testing\n        return f'{self._return_data} from \"{url}\"'\n\n\nclass Service:\n    # Accepts any IClient implementation\n    def __init__(self, client: IClient) -&gt; None:\n        self._client = client\n\n    def do_something(self) -&gt; str:\n        return self._client.request('https://example.com')\n\n\n# Usage in regular code\nreal_client = RealClient()\nservice = Service(real_client)\nprint(service.do_something())  # Output: \"https://example.com\" call result\n\n# Usage in tests\nmocked_client = MockClient('mocked data')\nservice = Service(mocked_client)\nprint(service.do_something())  # Output: mocked data from \"https://example.com\"\n</code></pre> <p>Here, a <code>MockClient</code> is injected into <code>Service</code>, making it easy to test <code>Service</code> in isolation without relying on a real client implementation.</p>"},{"location":"usage/providers/#what-is-ioc-container","title":"What is IoC-container?","text":"<p>An IoC container is a framework that automates object creation and dependency management based on the Inversion of Control (IoC) principle. It centralizes the configuration and instantiation of components, reducing tight coupling and simplifying code maintenance. By handling dependency resolution, an IoC container promotes modular, testable, and scalable application design.</p> <p>With power of IoC-container you can leverage all the benefits of DI without manually managing dependencies.</p>"},{"location":"usage/providers/#providers_1","title":"Providers","text":"<p><code>Provider</code> is an object that holds dependency metadata, such as its type, lifetime scope and factory.</p> <p>In <code>waku</code> there are four types of providers, for one for each scope:</p> <ul> <li><code>Transient</code></li> <li><code>Scoped</code></li> <li><code>Singleton</code></li> <li><code>Object</code></li> </ul> <p>Each provider take two arguments:</p> <ul> <li><code>factory</code>: type or callable that returns or yields an instance of the dependency.</li> <li><code>type_</code>: type of the dependency. If not provided, it will be inferred from the factory function's return type.</li> </ul> <p>Note</p> <p><code>Object</code> provider is a special case, it first argument named <code>object</code> instead of a <code>factory</code> because you should pass already instantiated object directly, not a factory function.</p>"},{"location":"usage/providers/#scopes","title":"Scopes","text":"<p><code>waku</code> supports four different lifetime scopes for providers, inspired by the service lifetimes in .NET Core\u2019s DI system.</p>"},{"location":"usage/providers/#transient","title":"Transient","text":"<p>Dependency defined with the <code>Transient</code> provider are created each time they\u2019re requested.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Transient\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Transient(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj_1: Injected[list], obj_2: Injected[list]) -&gt; None:\n    assert obj_1 is not obj_2\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#scoped","title":"Scoped","text":"<p>Dependency defined with the <code>Scoped</code> provider are created once per dependency provider context entrance and disposed when the context exits.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Scoped\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Scoped(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj_1: Injected[list], obj_2: Injected[list]) -&gt; None:\n    assert obj_1 is obj_2\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#singleton","title":"Singleton","text":"<p>Dependency defined with the <code>Singleton</code> provider are created the first time they\u2019re requested and disposed when the application lifecycle ends.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Singleton\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Singleton(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj: Injected[list]) -&gt; list:\n    return obj\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            obj_1 = await handler()\n\n        async with application.container.context():\n            obj_2 = await handler()\n\n        assert obj_1 is obj_2\n\n    # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#object","title":"Object","text":"<p>Dependency defined with the <code>Object</code> provider behave like <code>Singleton</code>, but you must provide the implementation instance directly to the provide and manage its lifecycle manually, outside the IoC-container.</p> <pre><code>from waku import WakuFactory, module\nfrom waku.di import inject, Injected, Object\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nsome_object = (1, 2, 3)\n\n\n@module(providers=[Object(some_object, type_=tuple)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj: Injected[tuple]) -&gt; None:\n    assert obj is some_object\n\n\nasync def main() -&gt; None:\n    application = WakuFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n    # Providers are not disposed at this point automatically\n</code></pre>"},{"location":"usage/providers/#where-and-how-to-inject-dependencies","title":"Where and how to inject dependencies?","text":"<p>To inject dependencies with <code>waku</code> you need:</p> <ol> <li>Register them to <code>providers</code> with desired scope in modules.</li> <li>Identify your application entrypoints and decorate them with <code>@inject</code>.</li> <li>Add dependencies as arguments to your entrypoint signature using <code>Injected</code> type hint.</li> </ol> <pre><code>from waku import module\nfrom waku.di import Injected, inject, Scoped\n\n\nclass Service:\n    def great(self, name: str) -&gt; None:\n        print(f'Hello, {name}!')\n\n\n@module(\n    providers=[Scoped(Service)],\n)\nclass SomeModule:\n    pass\n\n\n@inject\nasync def some_handler(service: Injected[Service]) -&gt; None:\n    service.great('waku')\n</code></pre>"},{"location":"usage/providers/#included-dependency-providers","title":"Included Dependency Providers","text":"<p><code>waku</code> includes out-of-the-box support for several popular DI frameworks through its dependency provider system.</p>"},{"location":"usage/providers/#aioinject","title":"Aioinject","text":"<p><code>waku</code> dependency provider interface is heavily inspired by Aioinject, making it our recommended default choice. Aioinject integrates seamlessly with <code>waku</code> and offers all the necessary features:</p> <ul> <li>Support for all providers scopes (transient, singleton, scoped, object)</li> <li>Container lifecycle management</li> <li>Providers overriding</li> <li>Custom context passing</li> </ul> <p>Available by installing <code>waku</code> with <code>aioinject</code> extra or by directly installing <code>aioinject</code>:</p> uvpip <pre><code>uv add \"waku[aioinject]\"\n# or\nuv add aioinject\n</code></pre> <pre><code>pip install \"waku[aioinject]\"\n# or\npip install aioinject\n</code></pre>"},{"location":"usage/providers/#basic-usage","title":"Basic Usage","text":"<pre><code>from waku import WakuFactory, module\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module()\nclass AppModule:\n    pass\n\n\n# Create application with AioinjectDependencyProvider\napplication = WakuFactory.create(\n    AppModule,\n    dependency_provider=AioinjectDependencyProvider(),\n)\n</code></pre>"},{"location":"usage/providers/#custom-container-configuration","title":"Custom Container Configuration","text":"<p>You can provide your own pre-configured <code>aioinject</code> container:</p> <pre><code>import aioinject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n# Create and configure a custom aioinject container\ncustom_container = aioinject.Container(extensions=[...])\ncustom_container.register(aioinject.Scoped(MyService))  # Example registration\n# ... configure container\n\n# Use the custom container with waku\ndp = AioinjectDependencyProvider(container=custom_container)\n</code></pre>"},{"location":"usage/providers/#dishka","title":"Dishka","text":"<p>Currently not supported but planned.</p>"},{"location":"usage/providers/#writing-custom-dependency-provider","title":"Writing Custom Dependency Provider","text":"<p>To create custom dependency provider you need to implement <code>DependencyProvider</code> interface.</p>"}]}
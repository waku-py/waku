{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"waku","text":"<p> <sup>waku [\u67a0] means framework in Japanese.</sup> </p> <p> </p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p><code>waku</code> is a Python framework for building modular, loosely coupled, and maintainable applications. It draws inspiration from NestJS and Tramvai, adapting their best ideas to the Python ecosystem. Here's list of some <code>waku</code> key features:</p> <ul> <li>\ud83e\udde9 Modularity: Build applications as a set of loosely coupled   modules</li> <li>\ud83d\udc89 Powerful Dependency Injection System: Manage   dependencies with built-in DI framework-agnostic IoC-container</li> <li>\ud83d\udd27 Extensions: Use application and modules lifecycle hooks to   extend <code>waku</code></li> <li>\ud83d\udcca Lifespan: Automatic manage application and IoC-container   lifecycle</li> <li>\u2699\ufe0f Command/Query handling (CQRS): Use mediator abstraction   heavily inspired by C# MediatR library to handle commands and queries</li> <li>\ud83e\udd1d Integrations: <code>waku</code> comes with   built-in integrations for popular web frameworks like FastAPI   or Litestar and allows you to easily create your own integrations with any other   frameworks</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#-modular-architecture","title":"\ud83c\udfd7\ufe0f Modular Architecture","text":"<ul> <li>Build modular monoliths with clear boundaries</li> <li>Enforce loose coupling between components</li> <li>Automatically validate dependency graphs</li> <li>Control module visibility and access</li> </ul>"},{"location":"#-extensible-plugin-system","title":"\ud83d\udd0c Extensible Plugin System","text":"<ul> <li>Built-in extension mechanism</li> <li>Lifecycle hooks for modules and applications</li> <li>Custom extension points</li> <li>Rich ecosystem of built-in extensions (work in progress)</li> </ul>"},{"location":"#-flexible-dependency-injection","title":"\ud83d\udc89 Flexible Dependency Injection","text":"<ul> <li>Framework-agnostic DI implementation</li> <li>Providers with different lifetimes (singleton, scoped, transient, object)</li> <li>Simplified testing and mocking</li> </ul>"},{"location":"#-command-query-responsibility-segregation-cqrs","title":"\ud83c\udfae Command Query Responsibility Segregation (CQRS)","text":"<p><code>waku</code> includes a built-in CQRS implementation with all the features you need to build robust, maintainable applications:</p> <ul> <li>Command and Query request handling</li> <li>Event handling with custom publishers support</li> <li>Middleware support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>Install the <code>waku</code> package using your preferred tool. We recommend <code>uv</code> for managing project dependencies due to its speed and simplicity.</p> <pre><code># Using UV\nuv add waku\n\n# Using pip\npip install waku\n\n# Using poetry\npoetry add waku\n</code></pre> <p>You also need to install some additional dependencies for the DI system to work.</p> <p>You can explore all available providers in our documentation.</p>"},{"location":"#basic-example","title":"Basic Example","text":"<p>For our example we stick with aioinject as DI provider. Install it directly using your preferred package manager or as extra dependency of <code>waku</code>:</p> <pre><code>uv add \"waku[aioinject]\"\n</code></pre> <pre><code>import asyncio\n\nfrom waku import ApplicationFactory, module\nfrom waku.di import Scoped, Injected, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n# Define your providers\nclass GreetingService:\n    async def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n\n\n# Define a module with your providers\n@module(providers=[Scoped(GreetingService)])\nclass GreetingModule:\n    pass\n\n\n# Define the application composition root module\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\n# Define entrypoints\n# In a real-world scenario, this could be FastAPI routes, etc.\n@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n\n\nasync def main() -&gt; None:\n    # Create application via factory\n    application = ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n\n    # Run the application\n    # In a real-world scenario, this would be run by a framework like FastAPI\n    async with application, application.container.context():\n        message = await greet_user()\n        print(message)  # Output: Hello, waku!\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>For explanations of the code above and more realistic examples, see the Getting Started guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Explore detailed documentation on our official site.</p> <p>Key topics include:</p> <ul> <li>Getting Started</li> <li>Module System</li> <li>Providers</li> <li>Extensions</li> <li>Mediator (CQRS)</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We\u2019d love your contributions! Check out our Contributing Guide to get started.</p>"},{"location":"#development-setup","title":"Development Setup","text":"<p>Learn how to set up a development environment in the Contributing Guide.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v050-2025-03-23","title":"v0.5.0 (2025-03-23)","text":""},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li> <p>Add basic modules and providers docs   (<code>9ddbc3b</code>)</p> </li> <li> <p>Further improve documentation #19 #94   (<code>3d061b6</code>)</p> </li> <li> <p>add getting started section * add more usage docs * change api reference appearance * improve   mkdocs config</p> </li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li> <p>mediator: Simplify cqrs handlers registration (#105)   (#107,   <code>65fa07d</code>)</p> </li> <li> <p>Remove <code>MediatorProvidersCreator</code> * Add new module extension type <code>OnModuleConfigure</code> for allowing   change module metadata before module creating * Move handlers binding logic to <code>MediatorExtension</code></p> </li> </ul> <p>Resolves: #105</p>"},{"location":"changelog/#v040-2025-03-16","title":"v0.4.0 (2025-03-16)","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Setup mkdocs and improve documentation   (<code>d5166d7</code>)</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add ability to pass custom context to dependency provider   (<code>a0e055f</code>)</li> </ul>"},{"location":"changelog/#v031-2025-02-13","title":"v0.3.1 (2025-02-13)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Do not unwrap generic annotations in <code>collect_dependencies</code>   (<code>c5f1b7c</code>)</li> </ul>"},{"location":"changelog/#v030-2025-02-10","title":"v0.3.0 (2025-02-10)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Refactor module system   (<code>43a102a</code>)</li> </ul>"},{"location":"changelog/#v020-2025-01-12","title":"v0.2.0 (2025-01-12)","text":""},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li> <p>Add docstrings to mediator related stuff   (<code>10728c0</code>)</p> </li> <li> <p>Deploy mkdocs to github pages #17   (<code>23872d7</code>)</p> </li> <li> <p>Improve readme and contributing guide   (<code>93529d1</code>)</p> </li> <li> <p>Trigger docs deploy #17   (<code>096876f</code>)</p> </li> <li> <p>Use org bot for pages deploy #17   (<code>dfd1786</code>)</p> </li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li> <p>Eliminate maps usage in mediator   (<code>16679d7</code>)</p> </li> <li> <p>Refactor mediator extension, add events handling support   (<code>3441375</code>)</p> </li> </ul> <p>Resolves #12 Fixes #16</p>"},{"location":"changelog/#v016-2024-12-20","title":"v0.1.6 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Skip ci in release commit   (<code>9adbc58</code>)</li> </ul>"},{"location":"changelog/#v015-2024-12-20","title":"v0.1.5 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Remove unused version var from init, run gitlint only for prs   (<code>7a270d4</code>)</li> </ul>"},{"location":"changelog/#v014-2024-12-20","title":"v0.1.4 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Attempt to fix contextvar from different context error   (<code>d98c2f8</code>)</li> </ul>"},{"location":"changelog/#v013-2024-12-20","title":"v0.1.3 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>ext: Make mediator middlewares work   (<code>4e4a593</code>)</li> </ul>"},{"location":"changelog/#build-system","title":"Build System","text":"<ul> <li>Make patch release only for <code>fix</code> &amp; <code>perf</code> tags   (<code>b9cf6bf</code>)</li> </ul>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>Add readme and contributing guide   (<code>32043d7</code>)</li> </ul>"},{"location":"changelog/#v012-2024-12-19","title":"v0.1.2 (2024-12-19)","text":""},{"location":"changelog/#continuous-integration","title":"Continuous Integration","text":"<ul> <li> <p>Fix semantic release step   (<code>c516322</code>)</p> </li> <li> <p>Fix semantic release step 2   (<code>176a466</code>)</p> </li> <li> <p>Setup github actions pipelines   (<code>3f0ec58</code>)</p> </li> </ul>"},{"location":"changelog/#v011-2024-12-19","title":"v0.1.1 (2024-12-19)","text":""},{"location":"changelog/#chores","title":"Chores","text":"<ul> <li>deps: Use litestar-msgspec with litestar extra on all python version   (<code>ef60b04</code>)</li> </ul>"},{"location":"changelog/#v010-2024-12-18","title":"v0.1.0 (2024-12-18)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Module validation   (<code>45c58b1</code>)</li> </ul>"},{"location":"changelog/#chores_1","title":"Chores","text":"<ul> <li> <p>Adjust dev workflow, add semantic release config   (<code>ab3313a</code>)</p> </li> <li> <p>ci: Try fix ci   (<code>2bf8383</code>)</p> </li> </ul>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li> <p>Add providers registration, fix validation   (<code>35ef7f3</code>)</p> </li> <li> <p>Add semantic release, rename package   (<code>a8addaf</code>)</p> </li> <li> <p>Implement di &amp; mediator extension   (<code>f7ebdb9</code>)</p> </li> <li> <p>Improve app &amp; di lifespan, add check for app providers   (<code>d5b3a31</code>)</p> </li> <li> <p>Improve providers validation &amp; add imports to init files   (<code>7bd5999</code>)</p> </li> <li> <p>Make application module itself, improve aioinject provider   (<code>9ae70a2</code>)</p> </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Note</p> <p>For our examples we stick with aioinject as DI provider. Install it directly using your preferred package manager or as extra dependency of <code>waku</code>:</p> uvpip <pre><code>uv add \"waku[aioinject]\"\n# or\nuv add aioinject\n</code></pre> <pre><code>pip install \"waku[aioinject]\"\n# or\npip install aioinject\n</code></pre>"},{"location":"getting-started/#creating-your-first-waku-application","title":"Creating Your First <code>waku</code> Application","text":"<p>Let's create a simple application that demonstrates <code>waku</code> core concepts.</p>"},{"location":"getting-started/#step-1-create-the-basic-structure","title":"Step 1: Create the Basic Structure","text":"<p>Create a new directory for your project and set up your files:</p> <pre><code>project/\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 services.py\n</code></pre>"},{"location":"getting-started/#step-2-define-your-services","title":"Step 2: Define Your Services","text":"<p>In <code>services.py</code>, let's define a simple service:</p> services.py<pre><code>class GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n</code></pre>"},{"location":"getting-started/#step-3-create-modules","title":"Step 3: Create Modules","text":"<p>In <code>app.py</code>, let's define our modules and application setup:</p> app.py<pre><code>import asyncio\n\nfrom waku import Application, ApplicationFactory, module\nfrom waku.di import Scoped, Injected, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nfrom project.services import GreetingService\n\n\n# Define a feature module\n@module(\n    providers=[Scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n\n\n# Define the root application module\n@module(imports=[GreetingModule])\nclass AppModule:\n    pass\n\n\n# Define a function that will use our service\n@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n\n\n# Bootstrap the application\ndef bootstrap() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n\n\n# Run the application\nasync def main() -&gt; None:\n    application = bootstrap()\n\n    # Create a context for our application\n    async with application, application.container.context():\n        # Use our service\n        message = await greet_user()  # type: ignore[call-arg]\n        print(message)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-4-run-your-application","title":"Step 4: Run Your Application","text":"<p>Run the application with:</p> <pre><code>python app.py\n</code></pre> <p>You should see the output:</p> <pre><code>Hello, waku!\n</code></pre>"},{"location":"getting-started/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what's happening in our simple application:</p>"},{"location":"getting-started/#modules","title":"Modules","text":"<p>Modules are the building blocks of a <code>waku</code> application. Each module encapsulates a specific feature or functionality.</p> <pre><code>@module(\n    providers=[Scoped(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre> <p>In this example:</p> <ul> <li><code>providers</code> defines which providers this module creates and manages</li> <li><code>exports</code> makes these providers (or imported modules) available to other modules that import this one</li> <li><code>Scoped</code> indicates this provider should be created once for every container context entrance.</li> </ul> <p>Info</p> <p>For more information on providers and scopes, see Providers.</p>"},{"location":"getting-started/#application-bootstrap","title":"Application Bootstrap","text":"<p>The application is created using an <code>ApplicationFactory</code>:</p> <pre><code>def bootstrap() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n</code></pre> <p>This creates an application instance with:</p> <ul> <li><code>AppModule</code> as the root module</li> <li><code>AioinjectDependencyProvider</code> as the dependency injection provider</li> </ul>"},{"location":"getting-started/#dependency-injection","title":"Dependency Injection","text":"<p>Providers are injected into functions using the @inject decorator:</p> <pre><code>@inject\nasync def greet_user(greeting_service: Injected[GreetingService]) -&gt; str:\n    return greeting_service.greet('waku')\n</code></pre> <p>The <code>Injected[GreetingService]</code> type annotation tells <code>waku</code> which provider to inject.</p>"},{"location":"getting-started/#context-management","title":"Context Management","text":"<p><code>waku</code> uses context managers to manage the lifecycle of your application and its providers:</p> <pre><code>async with application, application.container.context():\n    message = await greet_user()\n</code></pre> <p>In real applications, you would typically use this context managers in <code>lifespan</code> of your framework.</p>"},{"location":"getting-started/#creating-a-more-realistic-application","title":"Creating a More Realistic Application","text":"<p>Let's extend our example to demonstrate a more realistic scenario with multiple modules and configuration.</p>"},{"location":"getting-started/#step-1-enhanced-structure","title":"Step 1: Enhanced Structure","text":"<p>Create a more complete project structure:</p> <pre><code>app/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __main__.py\n\u251c\u2500\u2500 application.py\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 greetings/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 services.py\n\u2502   \u2502   \u2514\u2500\u2500 module.py\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 services.py\n\u2502       \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 settings.py\n</code></pre>"},{"location":"getting-started/#step-2-add-configuration-module","title":"Step 2: Add Configuration Module","text":"<p>Define an application settings class and configuration module for providing settings object to your application:</p> app/settings.py<pre><code>from dataclasses import dataclass\nfrom typing import Literal\n\nfrom waku import DynamicModule, module\nfrom waku.di import Object\n\nEnvironment = Literal['dev', 'prod']\n\n\n# You may consider using `pydantic-settings` or similar libs for settings management\n@dataclass(kw_only=True)\nclass AppSettings:\n    environment: Environment\n    debug: bool\n\n\n@module(is_global=True)\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: Environment) -&gt; DynamicModule:\n        settings = AppSettings(\n            environment=env,\n            debug=env == 'dev',\n        )\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Object(settings)],\n        )\n</code></pre>"},{"location":"getting-started/#step-3-create-modules_1","title":"Step 3: Create Modules","text":""},{"location":"getting-started/#greeting-module","title":"Greeting Module","text":"app/modules/greetings/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Greeting:\n    language: str\n    template: str\n</code></pre> app/modules/greetings/services.py<pre><code>from app.config import AppConfig\nfrom app.modules.greetings.models import Greeting\n\n\nclass GreetingService:\n    def __init__(self, config: AppConfig) -&gt; None:\n        self.config = config\n        self.greetings: dict[str, Greeting] = {\n            'en': Greeting(language='en', template='Hello, {}!'),\n            'es': Greeting(language='es', template='\u00a1Hola, {}!'),\n            'fr': Greeting(language='fr', template='Bonjour, {}!'),\n        }\n\n    def get_greeting(self, language: str = 'en') -&gt; Greeting:\n        # If in debug mode and language not found, return default\n        if self.config.debug and language not in self.greetings:\n            return self.greetings['en']\n        return self.greetings.get(language, self.greetings['en'])\n\n    def greet(self, name: str, language: str = 'en') -&gt; str:\n        greeting = self.get_greeting(language)\n        return greeting.template.format(name)\n\n    def available_languages(self) -&gt; list[str]:\n        return list(self.greetings.keys())\n</code></pre> app/modules/greetings/module.py<pre><code>from waku import module\nfrom waku.di import Singleton\n\nfrom app.modules.greetings.services import GreetingService\n\n\n@module(\n    providers=[Singleton(GreetingService)],\n    exports=[GreetingService],\n)\nclass GreetingModule:\n    pass\n</code></pre>"},{"location":"getting-started/#user-module","title":"User Module","text":"app/modules/users/models.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: str\n    name: str\n    preferred_language: str = 'en'\n</code></pre> app/modules/users/services.py<pre><code>from app.modules.users.models import User\n\n\nclass UserService:\n    def __init__(self) -&gt; None:\n        # Mock database\n        self.users: dict[str, User] = {\n            '1': User(id='1', name='Alice', preferred_language='en'),\n            '2': User(id='2', name='Bob', preferred_language='fr'),\n            '3': User(id='3', name='Carlos', preferred_language='es'),\n        }\n\n    def get_user(self, user_id: str) -&gt; User | None:\n        return self.users.get(user_id)\n</code></pre> app/modules/users/module.py<pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.users.services import UserService\n\n\n@module(\n    providers=[Scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n</code></pre>"},{"location":"getting-started/#step-4-create-the-application-module","title":"Step 4: Create the Application Module","text":"<p>Define the application module and bootstrap function for initializing your application:</p> app/application.py<pre><code>from waku import Application, ApplicationFactory, module\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nfrom app.settings import ConfigModule\nfrom app.greetings.module import GreetingModule\nfrom app.users.module import UserModule\n\n\n@module(\n    # Import all top-level modules\n    imports=[\n        ConfigModule.register(env='dev'),\n        GreetingModule,\n        UserModule,\n    ],\n)\nclass AppModule:\n    pass\n\n\ndef bootstrap_application() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n</code></pre>"},{"location":"getting-started/#step-5-create-the-main-entrypoint","title":"Step 5: Create the Main Entrypoint","text":"<p>In real world scenarios, you would use a framework like FastAPI, Flask, etc. for defining your entry points, also known as handlers. For the sake of simplicity, we don't use any framework in this example.</p> app/__main__.py<pre><code>import asyncio\n\nfrom waku.di import Injected, inject\n\nfrom app.application import bootstrap_application\nfrom app.modules.users.services import UserService\nfrom app.modules.greetings.services import GreetingService\n\n\n@inject\nasync def greet_user_by_id(\n    user_id: str,\n    user_service: Injected[UserService],\n    greeting_service: Injected[GreetingService],\n) -&gt; str:\n    user = user_service.get_user(user_id)\n    if not user:\n        return f'User {user_id} not found'\n\n    return greeting_service.greet(name=user.name, language=user.preferred_language)\n\n\nasync def main() -&gt; None:\n    application = bootstrap_application()\n\n    async with application, application.container.context():\n        # Greet different users\n        for user_id in ['1', '2', '3', '4']:  # '4' doesn't exist\n            greeting = await greet_user_by_id(user_id)  # type: ignore[call-arg]\n            print(greeting)\n\n        # Get service directly for demonstration\n        greeting_service = application.container.get(GreetingService)\n        print(f'Available languages: {greeting_service.available_languages()}')\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#step-6-run-your-application","title":"Step 6: Run Your Application","text":"<pre><code>python -m app\n</code></pre> <p>Expected output:</p> <pre><code>Hello, Alice!\nBonjour, Bob!\n\u00a1Hola, Carlos!\nUser 4 not found\nAvailable languages: ['en', 'es', 'fr']\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of <code>waku</code>, you can:</p> <ol> <li>Explore more advanced features like Mediator (CQRS)</li> <li>Learn about Extensions for adding functionality to your application</li> <li>Integrate with web frameworks like FastAPI</li> <li>Understand Module System in depth</li> <li>Explore Dependency Injection techniques</li> </ol> <p><code>waku</code> modular architecture allows your application to grow while maintaining clear separation of concerns and a clean, maintainable codebase.</p> <p>Note</p> <p>This guide is a starting point. It's highly recommended to read The Software Architecture Chronicles by Herberto Gra\u00e7a. He distills all popular software architectural styles into a single one to rule them all. It's a great read and will help you understand the principles behind <code>waku</code>.</p> <p>Happy coding with <code>waku</code>!</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#waku","title":"waku","text":""},{"location":"reference/#waku.Application","title":"Application","text":"<pre><code>Application(container, lifespan, extensions)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    container: ApplicationContainer,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n) -&gt; None:\n    self._container = container\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extensions = list(extensions)\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.Application.container","title":"container  <code>property</code>","text":"<pre><code>container\n</code></pre>"},{"location":"reference/#waku.Application.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize()\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.ApplicationFactory","title":"ApplicationFactory","text":""},{"location":"reference/#waku.ApplicationFactory.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    root_module,\n    /,\n    dependency_provider,\n    lifespan=(),\n    extensions=DEFAULT_EXTENSIONS,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    root_module: ModuleType,\n    /,\n    dependency_provider: DependencyProvider,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n) -&gt; Application:\n    container = cls._build_container(root_module, dependency_provider)\n    return Application(container, lifespan, extensions)\n</code></pre>"},{"location":"reference/#waku.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers=list(),\n    imports=list(),\n    exports=list(),\n    extensions=list(),\n    is_global=False,\n    id=uuid4(),\n    parent_module,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports = field(default_factory=list)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports = field(default_factory=list)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = field(default_factory=list)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module\n</code></pre>"},{"location":"reference/#waku.module","title":"module","text":"<pre><code>module(\n    *,\n    providers=(),\n    imports=(),\n    exports=(),\n    extensions=(),\n    is_global=False,\n)\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[Provider[Any]]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[object | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[Provider[Any]] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[object | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        setattr(cls, MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#waku.application","title":"application","text":""},{"location":"reference/#waku.application.Application","title":"Application","text":"<pre><code>Application(container, lifespan, extensions)\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>def __init__(\n    self,\n    container: ApplicationContainer,\n    lifespan: Sequence[LifespanFunc | LifespanWrapper],\n    extensions: Sequence[ApplicationExtension],\n) -&gt; None:\n    self._container = container\n    self._lifespan = tuple(\n        LifespanWrapper(lifespan_func) if not isinstance(lifespan_func, LifespanWrapper) else lifespan_func\n        for lifespan_func in lifespan\n    )\n    self._extensions = list(extensions)\n\n    self._exit_stack = AsyncExitStack()\n    self._initialized = False\n</code></pre>"},{"location":"reference/#waku.application.Application.container","title":"container  <code>property</code>","text":"<pre><code>container\n</code></pre>"},{"location":"reference/#waku.application.Application.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize()\n</code></pre> Source code in <code>src/waku/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    if self._initialized:\n        return\n    await self._call_on_init_extensions()\n    self._initialized = True\n    await self._call_after_init_extensions()\n</code></pre>"},{"location":"reference/#waku.container","title":"container","text":""},{"location":"reference/#waku.container.ApplicationContainer","title":"ApplicationContainer","text":"<pre><code>ApplicationContainer(dependency_provider, root_module)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>def __init__(self, dependency_provider: DependencyProvider, root_module: ModuleType) -&gt; None:\n    self._dependency_provider = dependency_provider\n\n    self._modules: dict[UUID, Module] = {}\n    self._compiler = ModuleCompiler()\n\n    self._root_module = Module(*self._compiler.extract_metadata(root_module))\n    self._graph = ModuleGraph(self._root_module)\n\n    self._dependency_provider.register(Object(dependency_provider, DependencyProvider))\n    self._dependency_provider.register(Object(self, ApplicationContainer))\n\n    self._exit_stack = AsyncExitStack()\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.graph","title":"graph  <code>property</code>","text":"<pre><code>graph\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.compiler","title":"compiler  <code>property</code>","text":"<pre><code>compiler\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.add_module","title":"add_module","text":"<pre><code>add_module(module_type)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>def add_module(self, module_type: ModuleType | DynamicModule) -&gt; tuple[Module, bool]:\n    type_, metadata = self._compiler.extract_metadata(module_type)\n    if self.has(metadata.id):\n        return self._modules[metadata.id], False\n\n    for extension in metadata.extensions:\n        if isinstance(extension, OnModuleConfigure):\n            extension.on_module_configure(metadata)\n\n    module = Module(type_, metadata)\n\n    self._modules[module.id] = module\n    self._graph.add_node(module)\n\n    for provider in module.providers:\n        self._dependency_provider.register(provider)\n\n    return module, True\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.has","title":"has","text":"<pre><code>has(id_)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>def has(self, id_: UUID) -&gt; bool:\n    return id_ in self._modules\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.get_module","title":"get_module","text":"<pre><code>get_module(module_type)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>def get_module(self, module_type: ModuleType | DynamicModule) -&gt; Module:\n    return self._modules[self._compiler.extract_metadata(module_type)[1].id]\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.get_module_by_id","title":"get_module_by_id","text":"<pre><code>get_module_by_id(id_)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>def get_module_by_id(self, id_: UUID) -&gt; Module:\n    return self._modules[id_]\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.get_modules","title":"get_modules","text":"<pre><code>get_modules(from_=None)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>def get_modules(self, from_: Module | None = None) -&gt; Iterable[Module]:\n    return self._graph.traverse(from_)\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.override","title":"override","text":"<pre><code>override(*providers)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>@contextmanager\ndef override(self, *providers: Provider[Any]) -&gt; Iterator[None]:\n    with self._dependency_provider.override(*providers):\n        yield\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.is_global_module","title":"is_global_module","text":"<pre><code>is_global_module(module)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>def is_global_module(self, module: Module) -&gt; bool:\n    return module.is_global or module is self._root_module\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.context","title":"context  <code>async</code>","text":"<pre><code>context(context=None)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>@asynccontextmanager\nasync def context(self, context: Mapping[Any, Any] | None = None) -&gt; AsyncIterator[InjectionContext]:\n    async with self._dependency_provider.context(context) as ctx:\n        yield ctx\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.get","title":"get  <code>async</code>","text":"<pre><code>get(type_)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>async def get(self, type_: type[_T]) -&gt; _T:\n    return await self._dependency_provider.get(type_)\n</code></pre>"},{"location":"reference/#waku.container.ApplicationContainer.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(type_)\n</code></pre> Source code in <code>src/waku/container.py</code> <pre><code>async def get_all(self, type_: type[_T]) -&gt; Iterable[_T]:\n    return await self._dependency_provider.get_all(type_)\n</code></pre>"},{"location":"reference/#waku.contrib","title":"contrib","text":""},{"location":"reference/#waku.contrib.asgi","title":"asgi","text":""},{"location":"reference/#waku.contrib.asgi.Scope","title":"Scope  <code>module-attribute</code>","text":"<pre><code>Scope = MutableMapping[str, Any]\n</code></pre>"},{"location":"reference/#waku.contrib.asgi.Message","title":"Message  <code>module-attribute</code>","text":"<pre><code>Message = MutableMapping[str, Any]\n</code></pre>"},{"location":"reference/#waku.contrib.asgi.Receive","title":"Receive  <code>module-attribute</code>","text":"<pre><code>Receive = Callable[[], Awaitable[Message]]\n</code></pre>"},{"location":"reference/#waku.contrib.asgi.Send","title":"Send  <code>module-attribute</code>","text":"<pre><code>Send = Callable[[Message], Awaitable[None]]\n</code></pre>"},{"location":"reference/#waku.contrib.asgi.ASGIApp","title":"ASGIApp  <code>module-attribute</code>","text":"<pre><code>ASGIApp = Callable[[Scope, Receive, Send], Awaitable[None]]\n</code></pre>"},{"location":"reference/#waku.contrib.asgi.ApplicationMiddleware","title":"ApplicationMiddleware","text":"<pre><code>ApplicationMiddleware(app, *, application)\n</code></pre> Source code in <code>src/waku/contrib/asgi.py</code> <pre><code>def __init__(self, app: ASGIApp, *, application: Application) -&gt; None:\n    self.app = app\n    self._application = application\n</code></pre>"},{"location":"reference/#waku.contrib.asgi.ApplicationMiddleware.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = app\n</code></pre>"},{"location":"reference/#waku.contrib.litestar","title":"litestar","text":""},{"location":"reference/#waku.contrib.litestar.ApplicationMiddleware","title":"ApplicationMiddleware","text":"<pre><code>ApplicationMiddleware(app)\n</code></pre> <p>               Bases: <code>MiddlewareProtocol</code></p> Source code in <code>src/waku/contrib/litestar.py</code> <pre><code>def __init__(self, app: ASGIApp) -&gt; None:\n    self.app = app\n</code></pre>"},{"location":"reference/#waku.contrib.litestar.ApplicationMiddleware.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = app\n</code></pre>"},{"location":"reference/#waku.contrib.litestar.ApplicationPlugin","title":"ApplicationPlugin","text":"<pre><code>ApplicationPlugin(application)\n</code></pre> <p>               Bases: <code>InitPluginProtocol</code></p> Source code in <code>src/waku/contrib/litestar.py</code> <pre><code>def __init__(self, application: Application) -&gt; None:\n    self._application = application\n</code></pre>"},{"location":"reference/#waku.contrib.litestar.ApplicationPlugin.on_app_init","title":"on_app_init","text":"<pre><code>on_app_init(app_config)\n</code></pre> Source code in <code>src/waku/contrib/litestar.py</code> <pre><code>def on_app_init(self, app_config: AppConfig) -&gt; AppConfig:\n    app_config.state[_STATE_KEY] = self._application\n    app_config.middleware.append(ApplicationMiddleware)\n    app_config.lifespan.append(self._lifespan)  # pyright: ignore [reportUnknownMemberType]\n    app_config.after_exception.append(_after_exception)  # pyright: ignore [reportUnknownMemberType]\n    return app_config\n</code></pre>"},{"location":"reference/#waku.di","title":"di","text":""},{"location":"reference/#waku.di.AnyProvider","title":"AnyProvider  <code>module-attribute</code>","text":"<pre><code>AnyProvider = (\n    Scoped[_T] | Singleton[_T] | Transient[_T] | Object[_T]\n)\n</code></pre>"},{"location":"reference/#waku.di.Injected","title":"Injected","text":"<p>               Bases: <code>Generic[_T]</code></p>"},{"location":"reference/#waku.di.DependencyProvider","title":"DependencyProvider","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/#waku.di.DependencyProvider.register","title":"register  <code>abstractmethod</code>","text":"<pre><code>register(*providers)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>@abstractmethod\ndef register(self, *providers: Provider[Any]) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.di.DependencyProvider.try_register","title":"try_register  <code>abstractmethod</code>","text":"<pre><code>try_register(*providers)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>@abstractmethod\ndef try_register(self, *providers: Provider[Any]) -&gt; None: ...\n</code></pre>"},{"location":"reference/#waku.di.DependencyProvider.context","title":"context  <code>async</code>","text":"<pre><code>context(context=None)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def context(self, context: Mapping[Any, Any] | None = None) -&gt; AsyncIterator[InjectionContext]:\n    if current_ctx := context_var.get(None):\n        yield current_ctx\n    else:\n        async with self._context(context) as ctx:\n            token = context_var.set(ctx)\n            try:\n                yield ctx\n            finally:\n                context_var.reset(token)\n</code></pre>"},{"location":"reference/#waku.di.DependencyProvider.get","title":"get  <code>async</code>","text":"<pre><code>get(type_)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>async def get(self, type_: type[_T]) -&gt; _T:\n    async with self.context() as ctx:\n        return await ctx.resolve(type_)\n</code></pre>"},{"location":"reference/#waku.di.DependencyProvider.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(type_)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>async def get_all(self, type_: type[_T]) -&gt; list[_T]:\n    async with self.context() as ctx:\n        return await ctx.resolve_iterable(type_)\n</code></pre>"},{"location":"reference/#waku.di.DependencyProvider.override","title":"override  <code>abstractmethod</code>","text":"<pre><code>override(*providers)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>@abstractmethod\ndef override(self, *providers: Provider[Any]) -&gt; AbstractContextManager[None]: ...\n</code></pre>"},{"location":"reference/#waku.di.InjectionContext","title":"InjectionContext","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.di.InjectionContext.resolve","title":"resolve  <code>async</code>","text":"<pre><code>resolve(type_)\n</code></pre> Source code in <code>src/waku/di/_context.py</code> <pre><code>async def resolve(self, type_: type[_T]) -&gt; _T: ...\n</code></pre>"},{"location":"reference/#waku.di.InjectionContext.resolve_iterable","title":"resolve_iterable  <code>async</code>","text":"<pre><code>resolve_iterable(type_)\n</code></pre> Source code in <code>src/waku/di/_context.py</code> <pre><code>async def resolve_iterable(self, type_: type[_T]) -&gt; list[_T]: ...\n</code></pre>"},{"location":"reference/#waku.di.InjectionContext.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(\n    function: Callable[_P, Coroutine[Any, Any, _T]],\n    dependencies: Iterable[Dependency[object]],\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; _T\n</code></pre><pre><code>execute(\n    function: Callable[_P, _T],\n    dependencies: Iterable[Dependency[object]],\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; _T\n</code></pre> <pre><code>execute(function, dependencies, *args, **kwargs)\n</code></pre> Source code in <code>src/waku/di/_context.py</code> <pre><code>async def execute(\n    self,\n    function: Callable[_P, Coroutine[Any, Any, _T] | _T],\n    dependencies: Iterable[Dependency[object]],\n    *args: _P.args,\n    **kwargs: _P.kwargs,\n) -&gt; _T: ...\n</code></pre>"},{"location":"reference/#waku.di.Object","title":"Object","text":"<pre><code>Object(object_, type_=None)\n</code></pre> <p>               Bases: <code>Provider[_T]</code></p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def __init__(\n    self,\n    object_: _T,\n    type_: type[_T] | None = None,\n) -&gt; None:\n    self.type_ = type_ or type(object_)\n    self.impl = object_\n</code></pre>"},{"location":"reference/#waku.di.Object.impl","title":"impl  <code>instance-attribute</code>","text":"<pre><code>impl = object_\n</code></pre>"},{"location":"reference/#waku.di.Object.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_ = type_ or type(object_)\n</code></pre>"},{"location":"reference/#waku.di.Object.collect_dependencies","title":"collect_dependencies","text":"<pre><code>collect_dependencies()\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def collect_dependencies(self) -&gt; Sequence[Dependency[object]]:\n    try:\n        return self._cached_dependencies\n    except AttributeError:\n        self._cached_dependencies = self._collect_dependencies()\n        return self._cached_dependencies\n</code></pre>"},{"location":"reference/#waku.di.Provider","title":"Provider","text":"<p>               Bases: <code>Hashable</code>, <code>Protocol[_T]</code></p>"},{"location":"reference/#waku.di.Provider.impl","title":"impl  <code>instance-attribute</code>","text":"<pre><code>impl\n</code></pre>"},{"location":"reference/#waku.di.Provider.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_\n</code></pre>"},{"location":"reference/#waku.di.Provider.collect_dependencies","title":"collect_dependencies","text":"<pre><code>collect_dependencies()\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def collect_dependencies(self) -&gt; Sequence[Dependency[object]]:\n    try:\n        return self._cached_dependencies\n    except AttributeError:\n        self._cached_dependencies = self._collect_dependencies()\n        return self._cached_dependencies\n</code></pre>"},{"location":"reference/#waku.di.Scoped","title":"Scoped","text":"<pre><code>Scoped(factory, type_=None)\n</code></pre> <p>               Bases: <code>Provider[_T]</code></p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def __init__(\n    self,\n    factory: FactoryType[_T],\n    type_: type[_T] | None = None,\n) -&gt; None:\n    self.impl = factory\n    self.type_ = type_ or guess_return_type(factory)\n</code></pre>"},{"location":"reference/#waku.di.Scoped.impl","title":"impl  <code>instance-attribute</code>","text":"<pre><code>impl = factory\n</code></pre>"},{"location":"reference/#waku.di.Scoped.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_ = type_ or guess_return_type(factory)\n</code></pre>"},{"location":"reference/#waku.di.Scoped.collect_dependencies","title":"collect_dependencies","text":"<pre><code>collect_dependencies()\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def collect_dependencies(self) -&gt; Sequence[Dependency[object]]:\n    try:\n        return self._cached_dependencies\n    except AttributeError:\n        self._cached_dependencies = self._collect_dependencies()\n        return self._cached_dependencies\n</code></pre>"},{"location":"reference/#waku.di.Singleton","title":"Singleton","text":"<pre><code>Singleton(factory, type_=None)\n</code></pre> <p>               Bases: <code>Scoped[_T]</code></p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def __init__(\n    self,\n    factory: FactoryType[_T],\n    type_: type[_T] | None = None,\n) -&gt; None:\n    self.impl = factory\n    self.type_ = type_ or guess_return_type(factory)\n</code></pre>"},{"location":"reference/#waku.di.Singleton.impl","title":"impl  <code>instance-attribute</code>","text":"<pre><code>impl = factory\n</code></pre>"},{"location":"reference/#waku.di.Singleton.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_ = type_ or guess_return_type(factory)\n</code></pre>"},{"location":"reference/#waku.di.Singleton.collect_dependencies","title":"collect_dependencies","text":"<pre><code>collect_dependencies()\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def collect_dependencies(self) -&gt; Sequence[Dependency[object]]:\n    try:\n        return self._cached_dependencies\n    except AttributeError:\n        self._cached_dependencies = self._collect_dependencies()\n        return self._cached_dependencies\n</code></pre>"},{"location":"reference/#waku.di.Transient","title":"Transient","text":"<pre><code>Transient(factory, type_=None)\n</code></pre> <p>               Bases: <code>Scoped[_T]</code></p> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def __init__(\n    self,\n    factory: FactoryType[_T],\n    type_: type[_T] | None = None,\n) -&gt; None:\n    self.impl = factory\n    self.type_ = type_ or guess_return_type(factory)\n</code></pre>"},{"location":"reference/#waku.di.Transient.impl","title":"impl  <code>instance-attribute</code>","text":"<pre><code>impl = factory\n</code></pre>"},{"location":"reference/#waku.di.Transient.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_ = type_ or guess_return_type(factory)\n</code></pre>"},{"location":"reference/#waku.di.Transient.collect_dependencies","title":"collect_dependencies","text":"<pre><code>collect_dependencies()\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>def collect_dependencies(self) -&gt; Sequence[Dependency[object]]:\n    try:\n        return self._cached_dependencies\n    except AttributeError:\n        self._cached_dependencies = self._collect_dependencies()\n        return self._cached_dependencies\n</code></pre>"},{"location":"reference/#waku.di.Dependency","title":"Dependency  <code>dataclass</code>","text":"<pre><code>Dependency(*, name, type_)\n</code></pre> <p>               Bases: <code>Generic[_T]</code></p>"},{"location":"reference/#waku.di.Dependency.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"reference/#waku.di.Dependency.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_\n</code></pre>"},{"location":"reference/#waku.di.Dependency.inner_type","title":"inner_type  <code>cached</code> <code>property</code>","text":"<pre><code>inner_type\n</code></pre>"},{"location":"reference/#waku.di.Dependency.is_iterable","title":"is_iterable  <code>cached</code> <code>property</code>","text":"<pre><code>is_iterable\n</code></pre>"},{"location":"reference/#waku.di.inject","title":"inject","text":"<pre><code>inject(function)\n</code></pre> Source code in <code>src/waku/di/_inject.py</code> <pre><code>def inject(function: Callable[_P, _T]) -&gt; Callable[_P, _T]:\n    wrapper = _inject(function)\n    return clear_wrapper(wrapper)\n</code></pre>"},{"location":"reference/#waku.di.contrib","title":"contrib","text":""},{"location":"reference/#waku.di.contrib.aioinject","title":"aioinject","text":""},{"location":"reference/#waku.di.contrib.aioinject.AioinjectDependencyProvider","title":"AioinjectDependencyProvider","text":"<pre><code>AioinjectDependencyProvider(container=None)\n</code></pre> <p>               Bases: <code>DependencyProvider</code></p> Source code in <code>src/waku/di/contrib/aioinject.py</code> <pre><code>def __init__(self, container: aioinject.Container | None = None) -&gt; None:\n    self._container = container or aioinject.Container()\n    self._exit_stack = AsyncExitStack()\n</code></pre>"},{"location":"reference/#waku.di.contrib.aioinject.AioinjectDependencyProvider.context","title":"context  <code>async</code>","text":"<pre><code>context(context=None)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def context(self, context: Mapping[Any, Any] | None = None) -&gt; AsyncIterator[InjectionContext]:\n    if current_ctx := context_var.get(None):\n        yield current_ctx\n    else:\n        async with self._context(context) as ctx:\n            token = context_var.set(ctx)\n            try:\n                yield ctx\n            finally:\n                context_var.reset(token)\n</code></pre>"},{"location":"reference/#waku.di.contrib.aioinject.AioinjectDependencyProvider.get","title":"get  <code>async</code>","text":"<pre><code>get(type_)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>async def get(self, type_: type[_T]) -&gt; _T:\n    async with self.context() as ctx:\n        return await ctx.resolve(type_)\n</code></pre>"},{"location":"reference/#waku.di.contrib.aioinject.AioinjectDependencyProvider.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(type_)\n</code></pre> Source code in <code>src/waku/di/_providers.py</code> <pre><code>async def get_all(self, type_: type[_T]) -&gt; list[_T]:\n    async with self.context() as ctx:\n        return await ctx.resolve_iterable(type_)\n</code></pre>"},{"location":"reference/#waku.di.contrib.aioinject.AioinjectDependencyProvider.register","title":"register","text":"<pre><code>register(*providers)\n</code></pre> Source code in <code>src/waku/di/contrib/aioinject.py</code> <pre><code>@override_\ndef register(self, *providers: Provider[Any]) -&gt; None:\n    self._container.register(*[self._map_provider(provider) for provider in providers])\n</code></pre>"},{"location":"reference/#waku.di.contrib.aioinject.AioinjectDependencyProvider.try_register","title":"try_register","text":"<pre><code>try_register(*providers)\n</code></pre> Source code in <code>src/waku/di/contrib/aioinject.py</code> <pre><code>@override_\ndef try_register(self, *providers: Provider[Any]) -&gt; None:\n    self._container.try_register(*[self._map_provider(provider) for provider in providers])\n</code></pre>"},{"location":"reference/#waku.di.contrib.aioinject.AioinjectDependencyProvider.override","title":"override","text":"<pre><code>override(*providers)\n</code></pre> Source code in <code>src/waku/di/contrib/aioinject.py</code> <pre><code>@override_\n@contextmanager\ndef override(self, *providers: Provider[Any]) -&gt; Iterator[None]:\n    override_providers = tuple(self._map_provider(provider) for provider in providers)\n    with self._container.override(*override_providers):\n        yield\n</code></pre>"},{"location":"reference/#waku.ext","title":"ext","text":""},{"location":"reference/#waku.ext.DEFAULT_EXTENSIONS","title":"DEFAULT_EXTENSIONS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EXTENSIONS = (\n    ValidationExtension(\n        [DependenciesAccessible(), DIScopeMismatch()],\n        strict=True,\n    ),\n)\n</code></pre>"},{"location":"reference/#waku.ext.validation","title":"validation","text":""},{"location":"reference/#waku.ext.validation.ValidationRule","title":"ValidationRule","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.ext.validation.ValidationRule.validate","title":"validate","text":"<pre><code>validate(context)\n</code></pre> Source code in <code>src/waku/ext/validation/_abc.py</code> <pre><code>def validate(self, context: ValidationContext) -&gt; list[ValidationError]: ...\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/#waku.ext.validation.ValidationExtension","title":"ValidationExtension","text":"<pre><code>ValidationExtension(rules, *, strict=True)\n</code></pre> <p>               Bases: <code>AfterApplicationInit</code></p> Source code in <code>src/waku/ext/validation/_extension.py</code> <pre><code>def __init__(self, rules: Sequence[ValidationRule], *, strict: bool = True) -&gt; None:\n    self.rules = rules\n    self.strict: Final = strict\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.rules","title":"rules  <code>instance-attribute</code>","text":"<pre><code>rules = rules\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict = strict\n</code></pre>"},{"location":"reference/#waku.ext.validation.ValidationExtension.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app)\n</code></pre> Source code in <code>src/waku/ext/validation/_extension.py</code> <pre><code>async def after_app_init(self, app: Application) -&gt; None:\n    context = ValidationContext(app=app)\n\n    errors_chain = chain.from_iterable(rule.validate(context) for rule in self.rules)\n    if errors := list(errors_chain):\n        self._raise(errors)\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules","title":"rules","text":""},{"location":"reference/#waku.ext.validation.rules.DependenciesAccessible","title":"DependenciesAccessible","text":"<p>               Bases: <code>ValidationRule</code></p> <p>Check if all dependencies of providers are accessible.</p> <p>This validation rule ensures that all dependencies required by providers are either: 1. Available globally 2. Provided by the current module 3. Provided by any of the imported modules</p>"},{"location":"reference/#waku.ext.validation.rules.DependenciesAccessible.validate","title":"validate","text":"<pre><code>validate(context)\n</code></pre> Source code in <code>src/waku/ext/validation/rules.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    container = context.app.container\n\n    # fmt: off\n    global_providers = {\n        provider_type\n        for module in container.get_modules()\n        for provider_type in _module_provided_types(module)\n        if container.is_global_module(module)\n    }\n    # fmt: on\n    global_providers |= {Application, DependencyProvider}\n\n    errors: list[ValidationError] = []\n    for module in container.get_modules():\n        for provider in module.providers:\n            for dependency in provider.collect_dependencies():\n                # 1. Dep available globally or provided by current module\n                dep_type = dependency.inner_type\n                if dep_type in global_providers or dep_type in _module_provided_types(module):\n                    continue\n                # 2. Dep provided by any of imported modules\n                dependency_accessible = any(\n                    _is_exported_dependency(dependency, imported_module)\n                    for imported_module in container.get_modules(module)\n                )\n                if not dependency_accessible:\n                    err_msg = (\n                        f'Provider \"{provider!r}\" from \"{module!r}\" depends on \"{dep_type!r}\" but it\\'s not accessible to it\\n'\n                        f'To resolve this issue:\\n'\n                        f'   1. Export \"{dep_type!r}\" from some module\\n'\n                        f'   2. Add module which exports \"{dep_type!r}\" to \"{module!r}\" imports'\n                    )\n                    errors.append(ValidationError(err_msg))\n\n    return errors\n</code></pre>"},{"location":"reference/#waku.ext.validation.rules.DIScopeMismatch","title":"DIScopeMismatch","text":"<p>               Bases: <code>ValidationRule</code></p> <p>Check if Singleton and Object providers don't depend on Scoped and Transient ones.</p>"},{"location":"reference/#waku.ext.validation.rules.DIScopeMismatch.validate","title":"validate","text":"<pre><code>validate(context)\n</code></pre> Source code in <code>src/waku/ext/validation/rules.py</code> <pre><code>@override\ndef validate(self, context: ValidationContext) -&gt; list[ValidationError]:\n    lifespan_scoped: UnionType = Singleton | Object  # pyright: ignore [reportMissingTypeArgument]\n    scope_scoped: UnionType = Scoped | Transient  # pyright: ignore [reportMissingTypeArgument]\n\n    providers: _Providers[Any] = defaultdict(list)\n    for provider in self._all_providers(context.app):\n        providers[provider.type_].append(provider)\n\n    errors: list[ValidationError] = []\n    for provider in chain.from_iterable(list(providers.values())):\n        for dependency in provider.collect_dependencies():\n            for dependency_provider in providers[dependency.inner_type]:\n                if isinstance(provider, Object):\n                    continue\n\n                if (\n                    isinstance(provider, lifespan_scoped)\n                    and isinstance(dependency_provider, scope_scoped)\n                    and not isinstance(dependency_provider, lifespan_scoped)\n                ):\n                    err_msg = (\n                        f'Application level provider \"{provider!r}\" depends on request level \"{dependency_provider!r}\"\\n'\n                        f'To resolve this issue, consider either:\\n'\n                        f'  - Making {provider!r} {Scoped.__name__} or {Transient.__name__}\\n'\n                        f'  - Making {dependency_provider!r} {Singleton.__name__} or {Object.__name__}'\n                    )\n                    errors.append(ValidationError(err_msg))\n\n    return errors\n</code></pre>"},{"location":"reference/#waku.extensions","title":"extensions","text":"<p>Extension protocols for the waku framework.</p> <p>This module defines protocols for extending module behavior. These protocols allow for hooking into various lifecycle events.</p>"},{"location":"reference/#waku.extensions.ApplicationExtension","title":"ApplicationExtension  <code>module-attribute</code>","text":"<pre><code>ApplicationExtension = (\n    OnApplicationInit | AfterApplicationInit\n)\n</code></pre>"},{"location":"reference/#waku.extensions.ModuleExtension","title":"ModuleExtension  <code>module-attribute</code>","text":"<pre><code>ModuleExtension = OnModuleConfigure | OnModuleInit\n</code></pre>"},{"location":"reference/#waku.extensions.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app)\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_app_init(self, app: Application) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app)\n</code></pre> <p>Perform actions after application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def after_app_init(self, app: Application) -&gt; None:\n    \"\"\"Perform actions after application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleConfigure","title":"OnModuleConfigure","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module configuration.</p>"},{"location":"reference/#waku.extensions.OnModuleConfigure.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata)\n</code></pre> <p>Perform actions before module metadata transformed to module.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    \"\"\"Perform actions before module metadata transformed to module.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module)\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.factory","title":"factory","text":""},{"location":"reference/#waku.factory.ApplicationFactory","title":"ApplicationFactory","text":""},{"location":"reference/#waku.factory.ApplicationFactory.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    root_module,\n    /,\n    dependency_provider,\n    lifespan=(),\n    extensions=DEFAULT_EXTENSIONS,\n)\n</code></pre> Source code in <code>src/waku/factory.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    root_module: ModuleType,\n    /,\n    dependency_provider: DependencyProvider,\n    lifespan: Sequence[LifespanFunc] = (),\n    extensions: Sequence[ApplicationExtension] = DEFAULT_EXTENSIONS,\n) -&gt; Application:\n    container = cls._build_container(root_module, dependency_provider)\n    return Application(container, lifespan, extensions)\n</code></pre>"},{"location":"reference/#waku.graph","title":"graph","text":""},{"location":"reference/#waku.graph.ModuleGraph","title":"ModuleGraph","text":"<pre><code>ModuleGraph(root_module)\n</code></pre> Source code in <code>src/waku/graph.py</code> <pre><code>def __init__(self, root_module: Module) -&gt; None:\n    self._root_module = root_module\n    self._adjacency: dict[UUID, set[Module]] = defaultdict(set)\n</code></pre>"},{"location":"reference/#waku.graph.ModuleGraph.add_node","title":"add_node","text":"<pre><code>add_node(module)\n</code></pre> Source code in <code>src/waku/graph.py</code> <pre><code>def add_node(self, module: Module) -&gt; None:\n    self._adjacency[module.id].add(module)\n</code></pre>"},{"location":"reference/#waku.graph.ModuleGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(from_module, to_module)\n</code></pre> Source code in <code>src/waku/graph.py</code> <pre><code>def add_edge(self, from_module: Module, to_module: Module) -&gt; None:\n    self._adjacency[from_module.id].add(to_module)\n</code></pre>"},{"location":"reference/#waku.graph.ModuleGraph.traverse","title":"traverse","text":"<pre><code>traverse(from_=None)\n</code></pre> Source code in <code>src/waku/graph.py</code> <pre><code>def traverse(self, from_: Module | None = None) -&gt; Iterable[Module]:\n    start_module = from_ or self._root_module\n    visited = {start_module.id}\n    queue = deque([start_module])\n\n    while queue:\n        vertex = queue.popleft()\n        yield vertex\n\n        for neighbor in self._adjacency[vertex.id]:\n            if neighbor.id not in visited:\n                visited.add(neighbor.id)\n                queue.append(neighbor)\n</code></pre>"},{"location":"reference/#waku.lifespan","title":"lifespan","text":""},{"location":"reference/#waku.lifespan.LifespanFunc","title":"LifespanFunc  <code>module-attribute</code>","text":"<pre><code>LifespanFunc = (\n    Callable[\n        ['Application'], AbstractAsyncContextManager[None]\n    ]\n    | AbstractAsyncContextManager[None]\n)\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper","title":"LifespanWrapper","text":"<pre><code>LifespanWrapper(lifespan_func)\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>def __init__(self, lifespan_func: LifespanFunc) -&gt; None:\n    self._lifespan_func = lifespan_func\n</code></pre>"},{"location":"reference/#waku.lifespan.LifespanWrapper.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app)\n</code></pre> Source code in <code>src/waku/lifespan.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def lifespan(self, app: Application) -&gt; AsyncIterator[None]:\n    ctx_manager = (\n        self._lifespan_func\n        if isinstance(self._lifespan_func, AbstractAsyncContextManager)\n        else self._lifespan_func(app)\n    )\n    async with ctx_manager:\n        yield\n</code></pre>"},{"location":"reference/#waku.mediator","title":"mediator","text":""},{"location":"reference/#waku.mediator.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id=uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.mediator.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.mediator.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.mediator.Mediator","title":"Mediator","text":"<pre><code>Mediator(dependency_provider, middlewares, event_publisher)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default mediator implementation.</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>def __init__(\n    self,\n    dependency_provider: DependencyProvider,\n    middlewares: Sequence[AnyMiddleware],\n    event_publisher: EventPublisher,\n) -&gt; None:\n    self._dependency_provider = dependency_provider\n    self._middleware_chain = MiddlewareChain(middlewares)\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.mediator.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request)\n</code></pre> <p>Send a request through the mediator middleware chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the mediator middleware chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.mediator.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event)\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.mediator.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a mediator to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.mediator.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event)\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request)\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the mediator to be handled by multiple handlers.</p>"},{"location":"reference/#waku.mediator.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event)\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the mediator middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.mediator.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request)\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.MiddlewareChain","title":"MiddlewareChain","text":"<pre><code>MiddlewareChain(middlewares=())\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def __init__(self, middlewares: Sequence[AnyMiddleware] = ()) -&gt; None:\n    self._middlewares: list[AnyMiddleware] = list(middlewares)\n</code></pre>"},{"location":"reference/#waku.mediator.MiddlewareChain.wrap","title":"wrap","text":"<pre><code>wrap(handle)\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def wrap(self, handle: HandleType[RequestT, ResponseT]) -&gt; HandleType[RequestT, ResponseT]:\n    original_handle = handle\n    for middleware in reversed(self._middlewares):\n        handle = functools.update_wrapper(\n            wrapper=functools.partial(middleware.__call__, handle=handle),\n            wrapped=original_handle,\n        )\n    return handle\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type=Mediator,\n    event_publisher=SequentialEventPublisher,\n    middlewares=(),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the mediator pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the mediator interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>middlewares</code> <p>A sequence of middleware classes that will be applied to the mediator pipeline. Middlewares are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[AnyMiddleware]]</code> </p> Example <pre><code>config = MediatorConfig(\n    mediator_implementation_type=CustomMediator,\n    middlewares=[LoggingMiddleware, ValidationMiddleware],\n)\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type = Mediator\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher = SequentialEventPublisher\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig.middlewares","title":"middlewares  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>middlewares = ()\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(request_type, handler_type)\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(event_type, handler_types)\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata)\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.mediator.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(config=None)\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    return DynamicModule(\n        parent_module=cls,\n        providers=list(cls._create_providers(config or MediatorConfig())),\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.mediator.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request)\n</code></pre> Source code in <code>src/waku/mediator/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap.bind","title":"bind","text":"<pre><code>bind(request_type, handler_type)\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        msg = f'{request_type.__name__} already exists in registry'\n        raise RequestHandlerAlreadyRegistered(msg, request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.RequestMap.merge","title":"merge","text":"<pre><code>merge(other)\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.contracts","title":"contracts","text":""},{"location":"reference/#waku.mediator.contracts.event","title":"event","text":""},{"location":"reference/#waku.mediator.contracts.event.EventT","title":"EventT  <code>module-attribute</code>","text":"<pre><code>EventT = TypeVar(\n    'EventT', bound='Event', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.event.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for events.</p>"},{"location":"reference/#waku.mediator.contracts.request","title":"request","text":""},{"location":"reference/#waku.mediator.contracts.request.RequestT","title":"RequestT  <code>module-attribute</code>","text":"<pre><code>RequestT = TypeVar(\n    'RequestT', bound='Request[Any]', contravariant=True\n)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.request.ResponseT","title":"ResponseT  <code>module-attribute</code>","text":"<pre><code>ResponseT = TypeVar(\n    'ResponseT',\n    bound='Response | None',\n    default=None,\n    covariant=True,\n)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id=uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.mediator.contracts.request.Request.request_id","title":"request_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_id = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts.request.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.mediator.events","title":"events","text":""},{"location":"reference/#waku.mediator.events.handler","title":"handler","text":""},{"location":"reference/#waku.mediator.events.handler.EventHandlerType","title":"EventHandlerType  <code>module-attribute</code>","text":"<pre><code>EventHandlerType = type[EventHandler[EventT]]\n</code></pre>"},{"location":"reference/#waku.mediator.events.handler.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventT]</code></p> <p>The event handler interface.</p> <p>Usage::</p> <p>class UserJoinedEventHandler(EventHandler[UserJoinedEvent])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, event: UserJoinedEvent) -&gt; None:\n      await self._meetings_api.notify_room(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"reference/#waku.mediator.events.handler.EventHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(event)\n</code></pre> Source code in <code>src/waku/mediator/events/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: EventT) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.mediator.events.map","title":"map","text":""},{"location":"reference/#waku.mediator.events.map.EventMapRegistry","title":"EventMapRegistry  <code>module-attribute</code>","text":"<pre><code>EventMapRegistry = MutableMapping[\n    type[EventT], list[EventHandlerType[EventT]]\n]\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap","title":"EventMap","text":"<pre><code>EventMap()\n</code></pre> Source code in <code>src/waku/mediator/events/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: EventMapRegistry[Any] = defaultdict(list)\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap.bind","title":"bind","text":"<pre><code>bind(event_type, handler_types)\n</code></pre> Source code in <code>src/waku/mediator/events/map.py</code> <pre><code>def bind(self, event_type: type[EventT], handler_types: list[EventHandlerType[EventT]]) -&gt; Self:\n    for handler_type in handler_types:\n        if handler_type in self._registry[event_type]:\n            msg = f'{handler_type.__name__} already registered for {event_type.__name__} event'\n            raise EventHandlerAlreadyRegistered(msg, event_type, handler_type)\n        self._registry[event_type].append(handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.events.map.EventMap.merge","title":"merge","text":"<pre><code>merge(other)\n</code></pre> Source code in <code>src/waku/mediator/events/map.py</code> <pre><code>def merge(self, other: EventMap) -&gt; Self:\n    for event_type, handlers in other.registry.items():\n        self.bind(event_type, handlers)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.events.publish","title":"publish","text":""},{"location":"reference/#waku.mediator.events.publish.EventPublisher","title":"EventPublisher","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#waku.mediator.events.publish.SequentialEventPublisher","title":"SequentialEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.mediator.events.publish.GroupEventPublisher","title":"GroupEventPublisher","text":"<p>               Bases: <code>EventPublisher</code></p>"},{"location":"reference/#waku.mediator.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.mediator.exceptions.MediatorError","title":"MediatorError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all mediator-related errors.</p>"},{"location":"reference/#waku.mediator.exceptions.ImproperlyConfiguredError","title":"ImproperlyConfiguredError","text":"<p>               Bases: <code>MediatorError</code></p> <p>Raised when mediator configuration is invalid.</p>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerAlreadyRegistered","title":"RequestHandlerAlreadyRegistered","text":"<pre><code>RequestHandlerAlreadyRegistered(\n    msg, request_type, handler_type\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a request handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> TYPE: <code>type[Request[Any]]</code> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> TYPE: <code>RequestHandlerType[Any, Any]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(\n    self,\n    msg: str,\n    request_type: type[Request[Any]],\n    handler_type: RequestHandlerType[Any, Any],\n) -&gt; None:\n    super().__init__(msg)\n    self.request_type = request_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerAlreadyRegistered.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerNotFound","title":"RequestHandlerNotFound","text":"<pre><code>RequestHandlerNotFound(msg, request_type)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when a request handler is not found.</p> ATTRIBUTE DESCRIPTION <code>request_type</code> <p>The type of request that caused the error.</p> <p> TYPE: <code>type[Request[Any]]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(self, msg: str, request_type: type[Request[Any]]) -&gt; None:\n    super().__init__(msg)\n    self.request_type = request_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerNotFound.request_type","title":"request_type  <code>instance-attribute</code>","text":"<pre><code>request_type = request_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerAlreadyRegistered","title":"EventHandlerAlreadyRegistered","text":"<pre><code>EventHandlerAlreadyRegistered(\n    msg, event_type, handler_type\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when an event handler is already registered.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> TYPE: <code>type[Event]</code> </p> <code>handler_type</code> <p>The type of handler that was already registered.</p> <p> TYPE: <code>EventHandlerType[Any]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(\n    self,\n    msg: str,\n    event_type: type[Event],\n    handler_type: EventHandlerType[Any],\n) -&gt; None:\n    super().__init__(msg)\n    self.event_type = event_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerAlreadyRegistered.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type = event_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerAlreadyRegistered.handler_type","title":"handler_type  <code>instance-attribute</code>","text":"<pre><code>handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerNotFound","title":"EventHandlerNotFound","text":"<pre><code>EventHandlerNotFound(msg, event_type)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when an event handler is not found.</p> ATTRIBUTE DESCRIPTION <code>event_type</code> <p>The type of event that caused the error.</p> <p> TYPE: <code>type[Event]</code> </p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(self, msg: str, event_type: type[Event]) -&gt; None:\n    super().__init__(msg)\n    self.event_type = event_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerNotFound.event_type","title":"event_type  <code>instance-attribute</code>","text":"<pre><code>event_type = event_type\n</code></pre>"},{"location":"reference/#waku.mediator.impl","title":"impl","text":""},{"location":"reference/#waku.mediator.impl.Mediator","title":"Mediator","text":"<pre><code>Mediator(dependency_provider, middlewares, event_publisher)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default mediator implementation.</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>def __init__(\n    self,\n    dependency_provider: DependencyProvider,\n    middlewares: Sequence[AnyMiddleware],\n    event_publisher: EventPublisher,\n) -&gt; None:\n    self._dependency_provider = dependency_provider\n    self._middleware_chain = MiddlewareChain(middlewares)\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.mediator.impl.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request)\n</code></pre> <p>Send a request through the mediator middleware chain.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request to process</p> <p> TYPE: <code>Request[ResponseT]</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>Response from the handler</p> RAISES DESCRIPTION <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the mediator middleware chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.mediator.impl.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event)\n</code></pre> <p>Publish an event to all registered handlers.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to publish</p> <p> TYPE: <code>Event</code> </p> RAISES DESCRIPTION <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces","title":"interfaces","text":""},{"location":"reference/#waku.mediator.interfaces.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the mediator middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.mediator.interfaces.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request)\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the mediator to be handled by multiple handlers.</p>"},{"location":"reference/#waku.mediator.interfaces.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event)\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a mediator to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.mediator.interfaces.IMediator.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event)\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IMediator.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request)\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares","title":"middlewares","text":""},{"location":"reference/#waku.mediator.middlewares.HandleType","title":"HandleType  <code>module-attribute</code>","text":"<pre><code>HandleType = Callable[[RequestT], Awaitable[ResponseT]]\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.AnyMiddleware","title":"AnyMiddleware  <code>module-attribute</code>","text":"<pre><code>AnyMiddleware = Middleware[Any, Any]\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.Middleware","title":"Middleware","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p>"},{"location":"reference/#waku.mediator.middlewares.NoopMiddleware","title":"NoopMiddleware","text":"<p>               Bases: <code>Middleware[RequestT, ResponseT]</code></p>"},{"location":"reference/#waku.mediator.middlewares.MiddlewareChain","title":"MiddlewareChain","text":"<pre><code>MiddlewareChain(middlewares=())\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def __init__(self, middlewares: Sequence[AnyMiddleware] = ()) -&gt; None:\n    self._middlewares: list[AnyMiddleware] = list(middlewares)\n</code></pre>"},{"location":"reference/#waku.mediator.middlewares.MiddlewareChain.wrap","title":"wrap","text":"<pre><code>wrap(handle)\n</code></pre> Source code in <code>src/waku/mediator/middlewares.py</code> <pre><code>def wrap(self, handle: HandleType[RequestT, ResponseT]) -&gt; HandleType[RequestT, ResponseT]:\n    original_handle = handle\n    for middleware in reversed(self._middlewares):\n        handle = functools.update_wrapper(\n            wrapper=functools.partial(middleware.__call__, handle=handle),\n            wrapped=original_handle,\n        )\n    return handle\n</code></pre>"},{"location":"reference/#waku.mediator.modules","title":"modules","text":""},{"location":"reference/#waku.mediator.modules.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type=Mediator,\n    event_publisher=SequentialEventPublisher,\n    middlewares=(),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the mediator pattern implementation in the application.</p> ATTRIBUTE DESCRIPTION <code>mediator_implementation_type</code> <p>The concrete implementation class for the mediator interface (IMediator). Defaults to the standard Mediator class.</p> <p> TYPE: <code>type[IMediator]</code> </p> <code>event_publisher</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <p> TYPE: <code>type[EventPublisher]</code> </p> <code>middlewares</code> <p>A sequence of middleware classes that will be applied to the mediator pipeline. Middlewares are executed in the order they are defined. Defaults to an empty sequence.</p> <p> TYPE: <code>Sequence[type[AnyMiddleware]]</code> </p> Example <pre><code>config = MediatorConfig(\n    mediator_implementation_type=CustomMediator,\n    middlewares=[LoggingMiddleware, ValidationMiddleware],\n)\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorConfig.mediator_implementation_type","title":"mediator_implementation_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mediator_implementation_type = Mediator\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorConfig.event_publisher","title":"event_publisher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_publisher = SequentialEventPublisher\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorConfig.middlewares","title":"middlewares  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>middlewares = ()\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.mediator.modules.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(config=None)\n</code></pre> <p>Application-level module for Mediator setup.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the Mediator extension.</p> <p> TYPE: <code>MediatorConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    return DynamicModule(\n        parent_module=cls,\n        providers=list(cls._create_providers(config or MediatorConfig())),\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension","title":"MediatorExtension","text":"<pre><code>MediatorExtension()\n</code></pre> <p>               Bases: <code>OnModuleConfigure</code></p> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._request_map = RequestMap()\n    self._event_map = EventMap()\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension.bind_request","title":"bind_request","text":"<pre><code>bind_request(request_type, handler_type)\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_request(\n    self,\n    request_type: type[RequestT],\n    handler_type: RequestHandlerType[RequestT, ResponseT],\n) -&gt; Self:\n    self._request_map.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension.bind_event","title":"bind_event","text":"<pre><code>bind_event(event_type, handler_types)\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def bind_event(\n    self,\n    event_type: type[EventT],\n    handler_types: list[EventHandlerType[EventT]],\n) -&gt; Self:\n    self._event_map.bind(event_type, handler_types)\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorExtension.on_module_configure","title":"on_module_configure","text":"<pre><code>on_module_configure(metadata)\n</code></pre> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>def on_module_configure(self, metadata: ModuleMetadata) -&gt; None:\n    metadata.providers.extend(\n        chain(\n            self._create_request_handler_providers(),\n            self._create_event_handler_providers(),\n        ),\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.requests","title":"requests","text":""},{"location":"reference/#waku.mediator.requests.handler","title":"handler","text":""},{"location":"reference/#waku.mediator.requests.handler.RequestHandlerType","title":"RequestHandlerType  <code>module-attribute</code>","text":"<pre><code>RequestHandlerType = type[\n    RequestHandler[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.mediator.requests.handler.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.mediator.requests.handler.RequestHandler.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(request)\n</code></pre> Source code in <code>src/waku/mediator/requests/handler.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, request: RequestT) -&gt; ResponseT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map","title":"map","text":""},{"location":"reference/#waku.mediator.requests.map.RequestMapRegistry","title":"RequestMapRegistry  <code>module-attribute</code>","text":"<pre><code>RequestMapRegistry = MutableMapping[\n    type[RequestT], RequestHandlerType[RequestT, ResponseT]\n]\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap","title":"RequestMap","text":"<pre><code>RequestMap()\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._registry: RequestMapRegistry[Any, Any] = {}\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap.bind","title":"bind","text":"<pre><code>bind(request_type, handler_type)\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def bind(self, request_type: type[RequestT], handler_type: RequestHandlerType[RequestT, ResponseT]) -&gt; Self:\n    if request_type in self._registry:\n        msg = f'{request_type.__name__} already exists in registry'\n        raise RequestHandlerAlreadyRegistered(msg, request_type, handler_type)\n    self._registry[request_type] = handler_type\n    return self\n</code></pre>"},{"location":"reference/#waku.mediator.requests.map.RequestMap.merge","title":"merge","text":"<pre><code>merge(other)\n</code></pre> Source code in <code>src/waku/mediator/requests/map.py</code> <pre><code>def merge(self, other: RequestMap) -&gt; Self:\n    for request_type, handler_type in other.registry.items():\n        self.bind(request_type, handler_type)\n    return self\n</code></pre>"},{"location":"reference/#waku.modules","title":"modules","text":""},{"location":"reference/#waku.modules.ModuleType","title":"ModuleType  <code>module-attribute</code>","text":"<pre><code>ModuleType = 'type[object | HasModuleMetadata]'\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule","title":"DynamicModule  <code>dataclass</code>","text":"<pre><code>DynamicModule(\n    *,\n    providers=list(),\n    imports=list(),\n    exports=list(),\n    extensions=list(),\n    is_global=False,\n    id=uuid4(),\n    parent_module,\n)\n</code></pre> <p>               Bases: <code>ModuleMetadata</code></p>"},{"location":"reference/#waku.modules.DynamicModule.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.DynamicModule.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports = field(default_factory=list)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports = field(default_factory=list)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.DynamicModule.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = field(default_factory=list)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.DynamicModule.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.DynamicModule.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.DynamicModule.parent_module","title":"parent_module  <code>instance-attribute</code>","text":"<pre><code>parent_module\n</code></pre>"},{"location":"reference/#waku.modules.ModuleCompiler","title":"ModuleCompiler","text":""},{"location":"reference/#waku.modules.ModuleCompiler.extract_metadata","title":"extract_metadata","text":"<pre><code>extract_metadata(module_type)\n</code></pre> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def extract_metadata(self, module_type: ModuleType | DynamicModule) -&gt; tuple[ModuleType, ModuleMetadata]:\n    try:\n        return self._extract_metadata(cast(Hashable, module_type))\n    except AttributeError:\n        msg = f'{type(module_type).__name__} is not module'\n        raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata","title":"ModuleMetadata  <code>dataclass</code>","text":"<pre><code>ModuleMetadata(\n    *,\n    providers=list(),\n    imports=list(),\n    exports=list(),\n    extensions=list(),\n    is_global=False,\n    id=uuid4(),\n)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers = field(default_factory=list)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports = field(default_factory=list)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports = field(default_factory=list)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = field(default_factory=list)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id = field(default_factory=uuid4)\n</code></pre>"},{"location":"reference/#waku.modules.Module","title":"Module","text":"<pre><code>Module(module_type, metadata)\n</code></pre> Source code in <code>src/waku/modules/_module.py</code> <pre><code>def __init__(self, module_type: ModuleType, metadata: ModuleMetadata) -&gt; None:\n    self.id: Final[UUID] = metadata.id\n    self.target: Final[ModuleType] = module_type\n    self.distance: Final[int] = sys.maxsize if metadata.is_global else 0\n\n    self.providers: Final[Sequence[Provider[Any]]] = metadata.providers\n    self.imports: Final[Sequence[ModuleType | DynamicModule]] = metadata.imports\n    self.exports: Final[Sequence[object | ModuleType]] = metadata.exports\n    self.extensions: Final[Sequence[ModuleExtension]] = metadata.extensions\n    self.is_global: Final[bool] = metadata.is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id = id\n</code></pre>"},{"location":"reference/#waku.modules.Module.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target = module_type\n</code></pre>"},{"location":"reference/#waku.modules.Module.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance = maxsize if is_global else 0\n</code></pre>"},{"location":"reference/#waku.modules.Module.providers","title":"providers  <code>instance-attribute</code>","text":"<pre><code>providers = providers\n</code></pre>"},{"location":"reference/#waku.modules.Module.imports","title":"imports  <code>instance-attribute</code>","text":"<pre><code>imports = imports\n</code></pre>"},{"location":"reference/#waku.modules.Module.exports","title":"exports  <code>instance-attribute</code>","text":"<pre><code>exports = exports\n</code></pre>"},{"location":"reference/#waku.modules.Module.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions = extensions\n</code></pre>"},{"location":"reference/#waku.modules.Module.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global = is_global\n</code></pre>"},{"location":"reference/#waku.modules.Module.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre>"},{"location":"reference/#waku.modules.module","title":"module","text":"<pre><code>module(\n    *,\n    providers=(),\n    imports=(),\n    exports=(),\n    extensions=(),\n    is_global=False,\n)\n</code></pre> <p>Decorator to define a module.</p> PARAMETER DESCRIPTION <code>providers</code> <p>Sequence of providers for dependency injection.</p> <p> TYPE: <code>Sequence[Provider[Any]]</code> DEFAULT: <code>()</code> </p> <code>imports</code> <p>Sequence of modules imported by this module.</p> <p> TYPE: <code>Sequence[ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>exports</code> <p>Sequence of types or modules exported by this module.</p> <p> TYPE: <code>Sequence[object | ModuleType | DynamicModule]</code> DEFAULT: <code>()</code> </p> <code>extensions</code> <p>Sequence of module extensions for lifecycle hooks.</p> <p> TYPE: <code>Sequence[ModuleExtension]</code> DEFAULT: <code>()</code> </p> <code>is_global</code> <p>Whether this module is global or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/waku/modules/_metadata.py</code> <pre><code>def module(\n    *,\n    providers: Sequence[Provider[Any]] = (),\n    imports: Sequence[ModuleType | DynamicModule] = (),\n    exports: Sequence[object | ModuleType | DynamicModule] = (),\n    extensions: Sequence[ModuleExtension] = (),\n    is_global: bool = False,\n) -&gt; Callable[[type[_T]], type[_T]]:\n    \"\"\"Decorator to define a module.\n\n    Args:\n        providers: Sequence of providers for dependency injection.\n        imports: Sequence of modules imported by this module.\n        exports: Sequence of types or modules exported by this module.\n        extensions: Sequence of module extensions for lifecycle hooks.\n        is_global: Whether this module is global or not.\n    \"\"\"\n\n    def decorator(cls: type[_T]) -&gt; type[_T]:\n        metadata = ModuleMetadata(\n            providers=list(providers),\n            imports=list(imports),\n            exports=list(exports),\n            extensions=list(extensions),\n            is_global=is_global,\n        )\n        setattr(cls, MODULE_METADATA_KEY, metadata)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering a contribution to <code>waku</code>! \ud83c\udf89</p> <p>This guide will help you get started and ensure a smooth process.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher</li> <li>uv - A modern Python package manager</li> <li>Task - A task runner for automating development workflows.   We recommend setting up auto-completion for Task.</li> <li>Git</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Install UV (if not already installed):</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# For other platforms, see:\n# https://docs.astral.sh/uv/getting-started/installation/\n\n# If uv is already installed, ensure it\u2019s up to date:\nuv self update\n</code></pre> </li> <li> <p>Install Task (if not already installed):</p> <pre><code># Using the install script\nsh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin\n\n# For other installation options, see:\n# https://taskfile.dev/installation/\n</code></pre> </li> <li> <p>Setup development environment:</p> <pre><code># Install dependencies and configure pre-commit hooks\ntask install\n</code></pre> <p>Tip: Run <code>task -l</code> after setup to verify everything is working and see available commands.</p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a new branch for your changes:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> </li> <li> <p>Make your changes following our code style guidelines</p> </li> <li> <p>Write tests for your changes</p> </li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Ensure your changes are thoroughly tested by running the following commands:</p> <pre><code># Run all checks (recommended)\ntask\n\n# Run linters and type checkers\ntask check\n\n# Run specific checks\ntask test         # Run tests only\ntask test:cov     # Run tests with coverage\ntask lint         # Run linters only\ntask format       # Format code\ntask typecheck    # Run type checkers only\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Ruff for linting and formatting</li> <li>MyPy and basedpyright for type checking</li> <li>pre-commit for running checks before commits and pushes</li> </ul> <p>Key style guidelines:</p> <ul> <li>Maximum line length: 120 characters</li> <li>Use explicit type annotations throughout the codebase</li> <li>Follow PEP 8 conventions</li> <li>Write descriptive docstrings using the Google style</li> </ul>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"contributing/#issues","title":"Issues","text":"<p>Before creating an issue:</p> <ol> <li>Search existing issues to avoid duplicates.</li> <li>Use the appropriate issue template.</li> <li>Provide as much context as possible (e.g., steps to reproduce, environment details).</li> </ol> <p>We welcome:</p> <ul> <li>Bug reports</li> <li>Feature requests</li> <li>Documentation improvements</li> <li>General questions or ideas</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Discuss significant changes by creating an issue first.</li> <li>Ensure all tests pass and code is formatted.</li> <li>Update documentation if your changes affect it.</li> <li>Follow the pull request template.</li> <li>Link related issues in your PR description (e.g., \"Fixes #123\").</li> </ol> <p>Pull request checklist:</p> <ul> <li> Tests added or updated</li> <li> Documentation updated (if applicable)</li> <li> Type hints added or refined</li> <li> Commit messages include a detailed description for the changelog</li> <li> All checks pass</li> </ul>"},{"location":"contributing/#development-commands","title":"Development Commands","text":"<p>Use these common <code>task</code> commands during development:</p> <pre><code>task install     # Install dependencies and set up pre-commit hooks\ntask format      # Format code using Ruff\ntask lint        # Run all linters\ntask typecheck   # Run type checkers (MyPy and basedpyright)\ntask test        # Run tests\ntask test:cov    # Run tests with coverage\ntask clean       # Clean build artifacts\ntask -l          # List all available commands\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Need help? Feel free to:</p> <ul> <li>Open an issue</li> <li>Start a discussion</li> <li>Contact the maintainers directly</li> </ul> <p>Thank you for contributing to <code>waku</code>! \ud83d\ude4f</p>"},{"location":"contributing/docs/","title":"Documentation","text":""},{"location":"contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub or by opening an issue.</p>"},{"location":"contributing/docs/#how-to-get-started","title":"How to get started","text":"<ol> <li>Follow the steps for development setup in the contributing guide</li> <li> <p>Start the local documentation server for live preview of changes     <pre><code>mkdocs serve\n</code></pre></p> </li> <li> <p>Go to the <code>docs/</code> directory and make your changes</p> </li> </ol> <p>After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"examples/mediator/","title":"Mediator (CQRS)","text":"<p>Based on the CQRS pattern, the mediator is used to decouple the command and query logic from the domain model.</p> <p>Implementation heavily inspired by C# MediatR library.</p> <p>For full documentation, visit the Mediator (CQRS) section.</p>"},{"location":"examples/mediator/#code","title":"Code","text":"<pre><code>import asyncio\nimport logging\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom uuid import UUID, uuid4\n\nfrom waku import Application, ApplicationFactory\nfrom waku.di import Injected, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\nfrom waku.mediator import (\n    IMediator,\n    MediatorConfig,\n    MediatorModule,\n    Request,\n    RequestHandler,\n    Response,\n)\nfrom waku.mediator.contracts.event import Event\nfrom waku.mediator.contracts.request import RequestT, ResponseT\nfrom waku.mediator.events.handler import EventHandler\nfrom waku.mediator.middlewares import HandleType, Middleware\nfrom waku.mediator.modules import MediatorExtension\nfrom waku.modules import module\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CreateMeetingResult(Response):\n    meeting_id: UUID\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CreateMeetingCommand(Request[CreateMeetingResult]):\n    user_id: UUID\n\n\n@dataclass(frozen=True, kw_only=True)\nclass MeetingCreatedEvent(Event):\n    user_id: UUID\n    meeting_id: UUID\n\n\nclass CreatingMeetingCommandHandler(RequestHandler[CreateMeetingCommand, CreateMeetingResult]):\n    def __init__(self, mediator: IMediator) -&gt; None:\n        self._mediator = mediator\n\n    async def handle(self, request: CreateMeetingCommand) -&gt; CreateMeetingResult:\n        meeting_id = uuid4()\n        logger.info('new meeting created user_id=%s', request.user_id)\n        await self._mediator.publish(MeetingCreatedEvent(user_id=request.user_id, meeting_id=meeting_id))\n        return CreateMeetingResult(meeting_id=meeting_id)\n\n\nclass MeetingCreatedEventHandler(EventHandler[MeetingCreatedEvent]):\n    async def handle(self, event: MeetingCreatedEvent) -&gt; None:\n        logger.info('meeting created event handled user_id=%s', event.user_id)\n\n\nclass LogMiddleware(Middleware[RequestT, ResponseT]):\n    async def __call__(self, request: RequestT, handle: HandleType[RequestT, ResponseT]) -&gt; ResponseT:\n        logger.info('request=%s', request)\n        response = await handle(request)\n        logger.info('response=%s', response)\n        return response\n\n\n@asynccontextmanager\nasync def lifespan(_: Application) -&gt; AsyncIterator[None]:\n    logger.info('Lifespan startup')\n    yield\n    logger.info('Lifespan shutdown')\n\n\n@module(\n    extensions=[\n        (\n            MediatorExtension()\n            .bind_request(CreateMeetingCommand, CreatingMeetingCommandHandler)\n            .bind_event(MeetingCreatedEvent, [MeetingCreatedEventHandler])\n        ),\n    ],\n)\nclass SomeModule:\n    pass\n\n\n@module(\n    imports=[\n        SomeModule,\n        MediatorModule.register(MediatorConfig(middlewares=[LogMiddleware])),\n    ],\n)\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(mediator: Injected[IMediator]) -&gt; None:\n    command = CreateMeetingCommand(user_id=uuid4())\n    await mediator.send(command)\n\n\nasync def main() -&gt; None:\n    dp = AioinjectDependencyProvider()\n    app = ApplicationFactory.create(\n        AppModule,\n        dependency_provider=dp,\n        lifespan=[lifespan],\n    )\n\n    async with app, app.container.context():\n        await handler()  # type: ignore[call-arg]\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/modularity/","title":"Modularity","text":"<p>Example of how to use modules, dynamic modules and linking them together to build an application.</p> <p>For full documentation on modules, visit the Modules section.</p>"},{"location":"examples/modularity/#code","title":"Code","text":"<pre><code>import asyncio\nimport logging\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\n\nfrom waku import Application\nfrom waku.di import Injected, Scoped, Singleton, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\nfrom waku.factory import ApplicationFactory\nfrom waku.modules import DynamicModule, module\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n# Define your providers and modules\nclass ConfigService:\n    def get(self, option: str) -&gt; str:\n        return option\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # You can select providers based on `env` for example\n        logger.info('Loading config for env=%s', env)\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Singleton(ConfigService)],\n            exports=[ConfigService],\n        )\n\n\nclass UserService:\n    async def great(self, name: str) -&gt; str:\n        return f'Hello, {name}!'\n\n\n@module(\n    providers=[Scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n\n\n@module(imports=[UserModule])\nclass IAMModule:\n    pass\n\n\n@module(imports=[UserModule, IAMModule])\nclass AdminModule:\n    pass\n\n\n# Define the application composition root module\n@module(\n    imports=[\n        AdminModule,\n        ConfigModule.register(env='prod'),\n    ],\n    exports=[ConfigModule],\n)\nclass AppModule:\n    pass\n\n\n# Define entrypoints\n# In real world this can be FastAPI routes, etc.\n@inject\nasync def handler(\n    user_service: Injected[UserService],\n    config_service: Injected[ConfigService],\n) -&gt; None:\n    print(await user_service.great('World'))\n    print(config_service.get('TEST=1'))\n\n\n@asynccontextmanager\nasync def lifespan(_: Application) -&gt; AsyncIterator[None]:\n    logger.info('Lifespan startup')\n    yield\n    logger.info('Lifespan shutdown')\n\n\n# Create application via factory\ndef bootstrap() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n        lifespan=[lifespan],\n    )\n\n\n# Run the application\n# In real world this would be run by a 3rd party framework like FastAPI\nasync def main() -&gt; None:\n    application = bootstrap()\n    async with application, application.container.context():\n        await handler()  # type: ignore[call-arg]\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"integrations/asgi/","title":"ASGI Integration","text":"<p><code>waku</code> can be seamlessly integrated into any ASGI application. To achieve this, set up <code>waku</code> as you normally would, then add the <code>ApplicationMiddleware</code> to your ASGI application\u2019s middleware stack.</p>"},{"location":"integrations/asgi/#example-with-fastapi","title":"Example with FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.middleware import Middleware\nfrom waku import Application\nfrom waku.contrib.asgi import ApplicationMiddleware\n\n\ndef bootstrap_application() -&gt; Application:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the FastAPI app with the waku middleware\napp = FastAPI(\n    middleware=[\n        Middleware(ApplicationMiddleware, application=application),\n    ],\n)\n</code></pre> <p>In this example, the <code>ApplicationMiddleware</code> bridges <code>waku</code> with FastAPI, allowing dependency injection and module management within your ASGI routes.</p>"},{"location":"integrations/litestar/","title":"Litestar Integration","text":"<p><code>waku</code> can be seamlessly integrated with Litestar using the <code>ApplicationPlugin</code>. To do this, set up <code>waku</code> as usual and then include the plugin in your Litestar application configuration.</p>"},{"location":"integrations/litestar/#example","title":"Example","text":"<p>Here\u2019s how to integrate <code>waku</code> with a Litestar application:</p> <pre><code>from litestar import Litestar\nfrom waku import Application\nfrom waku.contrib.litestar import ApplicationPlugin\n\n\ndef bootstrap_application() -&gt; Application:\n    # Replace with your actual waku app setup (e.g., ApplicationFactory.create)\n    ...\n\n\n# Create the waku application\napplication = bootstrap_application()\n\n# Create the Litestar app with the waku plugin\napp = Litestar(plugins=[ApplicationPlugin(application)])\n</code></pre> <p>In this example, the <code>ApplicationPlugin</code> enables <code>waku</code> dependency injection and module system within your Litestar application.</p>"},{"location":"usage/lifespan/","title":"Lifespan","text":""},{"location":"usage/modules/","title":"Modules","text":"<p><code>waku</code> modularity system is heavily inspired by the NestJS and Tramvai frameworks.</p> <p>The concept of modularity is well-explained with examples in the NestJS documentation.</p>"},{"location":"usage/modules/#module","title":"Module","text":"<p>A module is a class annotated with the <code>@module()</code> decorator. This decorator attaches metadata to the class, which <code>waku</code> uses to construct the application graph.</p> <p>Every <code>waku</code> application has at least one module: the root module, also known as the composition root. This module serves as the starting point for <code>waku</code> to build the entire application graph.</p> Parameter Description <code>providers</code> List of providers for dependency injection <code>imports</code> List of modules imported by this module <code>exports</code> List of types or modules exported by this module <code>extensions</code> List of module extensions for lifecycle hooks <code>is_global</code> Whether this module is global or not <p>The module encapsulates providers by default, meaning you can only inject providers that are either part of the current module or explicitly exported from other imported modules. The exported providers from a module essentially serve as the module's public interface or API.</p> <pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.config.module import ConfigModule\n\n\nclass UsersService:\n    pass\n\n\n@module(\n    providers=[Scoped(UsersService)],  # Register the service with a scoped lifetime\n    imports=[ConfigModule],  # Import another module\n    exports=[UsersService],  # Expose the service to other modules\n)\nclass UsersModule:\n    pass\n\n\n@module(imports=[UsersModule])  # Root module importing UsersModule\nclass AppModule:\n    pass\n</code></pre> <p>Note</p> <p>Encapsulation is enforced by validators, which you can disable at runtime if needed. However, disabling them entirely is not recommended, as they help maintain modularity.</p>"},{"location":"usage/modules/#module-re-exporting","title":"Module Re-exporting","text":"<p>You can re-export a module by including it in the <code>exports</code> list of another module. This is useful for exposing a module\u2019s providers to other modules that import the re-exporting module.</p> <pre><code>@module(\n    imports=[UsersModule],\n    exports=[UsersModule],\n)\nclass IAMModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#global-modules","title":"Global modules","text":"<p>If you need to import the same set of modules across your application, you can mark a module as global. Once a module is global, its providers can be injected anywhere in the application without requiring explicit imports in every module.</p> <p>To make a module global, set the <code>is_global</code> param to <code>True</code> in the <code>@module()</code> decorator.</p> <p>Note</p> <p>Root module are always global.</p> <p>Warning</p> <p>Global modules are not recommended for large applications, as they can lead to tight coupling and make the application harder to maintain.</p> <pre><code>from waku import module\n\n\n@module(is_global=True)\nclass UsersModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#dynamic-module","title":"Dynamic Module","text":"<p>Dynamic modules allow you to create modules dynamically based on conditions, such as the runtime environment of your application.</p> <pre><code>from waku import DynamicModule, module\nfrom waku.di import Scoped\n\n\nclass ConfigService:\n    pass\n\n\nclass DevConfigService(ConfigService):\n    pass\n\n\nclass DefaultConfigService(ConfigService):\n    pass\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # Choose the config provider based on the environment\n        config_provider = DevConfigService if env == 'dev' else DefaultConfigService\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Scoped(config_provider, type_=ConfigService)],  # Register with interface type\n        )\n</code></pre> <p>And then you can use it in any of your modules or in the root module:</p> <pre><code>from waku import module\n\nfrom app.modules.config.module import ConfigModule\n\n\n@module(\n    imports=[\n        ConfigModule.register(env='dev'),\n    ],\n)\nclass AppModule:\n    pass\n</code></pre> <p>You can also make a dynamic module global by setting <code>is_global=True</code> in the <code>DynamicModule</code> constructor.</p> <p>Note</p> <p>While you can use any method name instead of <code>register</code>, we recommend sticking with <code>register</code> for consistency.</p>"},{"location":"usage/providers/","title":"Providers","text":""},{"location":"usage/providers/#introduction","title":"Introduction","text":"<p>Providers are the core of <code>waku</code> dependency injection system. Idea behind a provider is that it can be injected as a dependency into other provider constructors, allowing objects to form various relationships with each other.</p> <p><code>waku</code> responsibility is to \"wire up\" all the providers using DI framework and manage the lifecycle its lifecycle. This way you can focus on writing your application logic.</p>"},{"location":"usage/providers/#dependency-injection","title":"Dependency Injection","text":"<p><code>waku</code> is designed to be modular and extensible. To support this principle, it provides a flexible dependency injection (DI) system that integrates seamlessly with various DI frameworks. <code>waku</code> itself acts like an IoC-container, allowing you to register and resolve dependencies using modules system.</p> <p>Note</p> <p>Instead of relying on a specific DI framework, <code>waku</code> uses an interface called <code>DependencyProvider</code>. This allows you to choose any DI framework you prefer (see Included Dependency Providers) or even create your own provider.</p>"},{"location":"usage/providers/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that addresses the issue of tightly coupled code by decoupling the creation and management of dependencies from the classes that rely on them. In traditional approaches, classes directly instantiate their dependencies, resulting in rigid, hard-to-maintain code. DI solves this problem by enabling dependencies to be supplied externally, typically through mechanisms like constructor or setter injection.</p> <p>By shifting the responsibility of dependency management outside the class, DI promotes loose coupling, allowing classes to focus on their core functionality rather than how dependencies are created. This separation enhances maintainability, testability, and flexibility, as dependencies can be easily swapped or modified without altering the class's code. Ultimately, DI improves system design by reducing interdependencies and making code more modular and scalable.</p> Manual DI Example <pre><code>from abc import ABC, abstractmethod\n\n\n# Use an interface to define contract for clients\n# This allows us injecting different implementations\nclass IClient(ABC):\n    @abstractmethod\n    def request(self, url: str) -&gt; str:\n        pass\n\n\n# Regular implementation\nclass RealClient(IClient):\n    def request(self, url: str) -&gt; str:\n        # Some HTTP requesting logic\n        return f'\"{url}\" call result'\n\n\n# Implementation for tests\nclass MockClient(IClient):\n    def __init__(self, return_data: str) -&gt; None:\n        self._return_data = return_data\n\n    def request(self, url: str) -&gt; str:\n        # Mocked behavior for testing\n        return f'{self._return_data} from \"{url}\"'\n\n\nclass Service:\n    # Accepts any IClient implementation\n    def __init__(self, client: IClient) -&gt; None:\n        self._client = client\n\n    def do_something(self) -&gt; str:\n        return self._client.request('https://example.com')\n\n\n# Usage in regular code\nreal_client = RealClient()\nservice = Service(real_client)\nprint(service.do_something())  # Output: \"https://example.com\" call result\n\n# Usage in tests\nmocked_client = MockClient('mocked data')\nservice = Service(mocked_client)\nprint(service.do_something())  # Output: mocked data from \"https://example.com\"\n</code></pre> <p>Here, a <code>MockClient</code> is injected into <code>Service</code>, making it easy to test <code>Service</code> in isolation without relying on a real client implementation.</p>"},{"location":"usage/providers/#what-is-ioc-container","title":"What is IoC-container?","text":"<p>An IoC container is a framework that automates object creation and dependency management based on the Inversion of Control (IoC) principle. It centralizes the configuration and instantiation of components, reducing tight coupling and simplifying code maintenance. By handling dependency resolution, an IoC container promotes modular, testable, and scalable application design.</p> <p>With power of IoC-container you can leverage all the benefits of DI without manually managing dependencies.</p>"},{"location":"usage/providers/#providers_1","title":"Providers","text":"<p><code>Provider</code> is an object that holds dependency metadata, such as its type, lifetime scope and factory.</p> <p>In <code>waku</code> there are four types of providers, for one for each scope:</p> <ul> <li><code>Transient</code></li> <li><code>Scoped</code></li> <li><code>Singleton</code></li> <li><code>Object</code></li> </ul> <p>Each provider take two arguments:</p> <ul> <li><code>factory</code>: type or callable that returns or yields an instance of the dependency.</li> <li><code>type_</code>: type of the dependency. If not provided, it will be inferred from the factory function's return type.</li> </ul> <p>Note</p> <p><code>Object</code> provider is a special case, it first argument named <code>object</code> instead of a <code>factory</code> because you should pass already instantiated object directly, not a factory function.</p>"},{"location":"usage/providers/#scopes","title":"Scopes","text":"<p><code>waku</code> supports four different lifetime scopes for providers, inspired by the service lifetimes in .NET Core\u2019s DI system.</p>"},{"location":"usage/providers/#transient","title":"Transient","text":"<p>Dependency defined with the <code>Transient</code> provider are created each time they\u2019re requested.</p> <pre><code>from waku import ApplicationFactory, module\nfrom waku.di import inject, Injected, Transient\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Transient(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj_1: Injected[list], obj_2: Injected[list]) -&gt; None:\n    assert obj_1 is not obj_2\n\n\nasync def main() -&gt; None:\n    application = ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#scoped","title":"Scoped","text":"<p>Dependency defined with the <code>Scoped</code> provider are created once per dependency provider context entrance and disposed when the context exits.</p> <pre><code>from waku import ApplicationFactory, module\nfrom waku.di import inject, Injected, Scoped\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Scoped(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj_1: Injected[list], obj_2: Injected[list]) -&gt; None:\n    assert obj_1 is obj_2\n\n\nasync def main() -&gt; None:\n    application = ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n        # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#singleton","title":"Singleton","text":"<p>Dependency defined with the <code>Singleton</code> provider are created the first time they\u2019re requested and disposed when the application lifecycle ends.</p> <pre><code>from waku import ApplicationFactory, module\nfrom waku.di import inject, Injected, Singleton\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module(providers=[Singleton(list)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj: Injected[list]) -&gt; list:\n    return obj\n\n\nasync def main() -&gt; None:\n    application = ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            obj_1 = await handler()\n\n        async with application.container.context():\n            obj_2 = await handler()\n\n        assert obj_1 is obj_2\n\n    # Providers are disposed at this point\n</code></pre>"},{"location":"usage/providers/#object","title":"Object","text":"<p>Dependency defined with the <code>Object</code> provider behave like <code>Singleton</code>, but you must provide the implementation instance directly to the provide and manage its lifecycle manually, outside the IoC-container.</p> <pre><code>from waku import ApplicationFactory, module\nfrom waku.di import inject, Injected, Object\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\nsome_object = (1, 2, 3)\n\n\n@module(providers=[Object(some_object, type_=tuple)])\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(obj: Injected[tuple]) -&gt; None:\n    assert obj is some_object\n\n\nasync def main() -&gt; None:\n    application = ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n    async with application:\n        async with application.container.context():\n            await handler()\n\n    # Providers are not disposed at this point automatically\n</code></pre>"},{"location":"usage/providers/#where-and-how-to-inject-dependencies","title":"Where and how to inject dependencies?","text":"<p>To inject dependencies with <code>waku</code> you need:</p> <ol> <li>Register them to <code>providers</code> with desired scope in modules.</li> <li>Identify your application entrypoints and decorate them with <code>@inject</code>.</li> <li>Add dependencies as arguments to your entrypoint signature using <code>Injected</code> type hint.</li> </ol> <pre><code>from waku import module\nfrom waku.di import Injected, inject, Scoped\n\n\nclass Service:\n    def great(self, name: str) -&gt; None:\n        print(f'Hello, {name}!')\n\n\n@module(\n    providers=[Scoped(Service)],\n)\nclass SomeModule:\n    pass\n\n\n@inject\nasync def some_handler(service: Injected[Service]) -&gt; None:\n    service.great('waku')\n</code></pre>"},{"location":"usage/providers/#included-dependency-providers","title":"Included Dependency Providers","text":"<p><code>waku</code> includes out-of-the-box support for several popular DI frameworks through its dependency provider system.</p>"},{"location":"usage/providers/#aioinject","title":"Aioinject","text":"<p><code>waku</code> dependency provider interface is heavily inspired by Aioinject, making it our recommended default choice. Aioinject integrates seamlessly with <code>waku</code> and offers all the necessary features:</p> <ul> <li>Support for all providers scopes (transient, singleton, scoped, object)</li> <li>Container lifecycle management</li> <li>Providers overriding</li> <li>Custom context passing</li> </ul> <p>Available by installing <code>waku</code> with <code>aioinject</code> extra or by directly installing <code>aioinject</code>:</p> uvpip <pre><code>uv add \"waku[aioinject]\"\n# or\nuv add aioinject\n</code></pre> <pre><code>pip install \"waku[aioinject]\"\n# or\npip install aioinject\n</code></pre>"},{"location":"usage/providers/#basic-usage","title":"Basic Usage","text":"<pre><code>from waku import ApplicationFactory, module\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n@module()\nclass AppModule:\n    pass\n\n\n# Create application with AioinjectDependencyProvider\napplication = ApplicationFactory.create(\n    AppModule,\n    dependency_provider=AioinjectDependencyProvider(),\n)\n</code></pre>"},{"location":"usage/providers/#custom-container-configuration","title":"Custom Container Configuration","text":"<p>You can provide your own pre-configured <code>aioinject</code> container:</p> <pre><code>import aioinject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n# Create and configure a custom aioinject container\ncustom_container = aioinject.Container(extensions=[...])\ncustom_container.register(aioinject.Scoped(MyService))  # Example registration\n# ... configure container\n\n# Use the custom container with waku\ndp = AioinjectDependencyProvider(container=custom_container)\n</code></pre>"},{"location":"usage/providers/#dishka","title":"Dishka","text":"<p>Currently not supported but planned.</p>"},{"location":"usage/providers/#writing-custom-dependency-provider","title":"Writing Custom Dependency Provider","text":"<p>To create custom dependency provider you need to implement <code>DependencyProvider</code> interface.</p>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"waku","text":"<p> <sup>waku [\u67a0] means framework in Japanese.</sup> </p> <p> </p> <p> </p> <p><code>waku</code> is a microframework for building modular and loosely coupled applications.</p> <p>This project is heavily inspired by NestJS &amp; Tramvai frameworks.</p>"},{"location":"#overview","title":"Overview","text":"<p><code>waku</code> helps you build maintainable Python applications by providing:</p> <ul> <li>Clean architecture patterns</li> <li>Dependency injection</li> <li>Module system</li> <li>Extension system</li> <li>Command/Query handling (CQRS)</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#-modular-architecture","title":"\ud83c\udfd7\ufe0f Modular Architecture","text":"<ul> <li>Build modular monoliths with clear boundaries</li> <li>Enforce loose coupling between components</li> <li>Validate dependency graphs automatically</li> <li>Control module visibility and access</li> </ul>"},{"location":"#-extensible-plugin-system","title":"\ud83d\udd0c Extensible Plugin System","text":"<ul> <li>Built-in extension mechanism</li> <li>Lifecycle hooks for modules and applications</li> <li>Custom extension points</li> <li>Rich ecosystem of built-in extensions</li> </ul>"},{"location":"#-flexible-dependency-injection","title":"\ud83d\udc89 Flexible Dependency Injection","text":"<ul> <li>Framework-agnostic DI implementation</li> <li>Providers with different lifetimes (singleton, scoped, transient)</li> <li>Easy testing and mocking</li> </ul>"},{"location":"#-command-query-responsibility-segregation-cqrs","title":"\ud83c\udfae Command Query Responsibility Segregation (CQRS)","text":"<ul> <li>Built-in CQRS extension</li> <li>Command/Query requests handling</li> <li>Event handling</li> <li>Middleware support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#using-pip","title":"Using pip","text":"<pre><code>pip install waku\n</code></pre>"},{"location":"#using-uv-recommended","title":"Using UV (recommended)","text":"<pre><code>uv add waku\n</code></pre>"},{"location":"#using-poetry","title":"Using poetry","text":"<pre><code>poetry add waku\n</code></pre>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>import asyncio\nfrom typing import Literal\n\nfrom waku import Application, ApplicationFactory, DynamicModule, module\nfrom waku.di import Scoped, Injected, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\n\n# Define your providers\nclass UserService:\n    async def get_user(self, user_id: str) -&gt; dict[str, str]:\n        return {'id': user_id, 'name': 'John Doe'}\n\n\n# Define a module\n@module(providers=[Scoped(UserService)], exports=[UserService])\nclass UserModule:\n    pass\n\n\n# Dynamic module example\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: Literal['dev', 'prod'] = 'prod') -&gt; DynamicModule:\n        # You can select providers based on `env` for example\n        if env == 'dev':\n            providers = [...]\n        else:\n            providers = [...]\n\n        return DynamicModule(parent_module=cls, providers=providers)\n\n\n# Define the application composition root module\n@module(\n    imports=[\n        UserModule,\n        ConfigModule.register('dev'),\n    ]\n)\nclass AppModule:\n    pass\n\n\n# Define entrypoints\n# In real world this can be FastAPI routes, etc.\n@inject\nasync def handler(user_service: Injected[UserService]) -&gt; dict[str, str]:\n    return await user_service.get_user(user_id='123')\n\n\n# Create application via factory\ndef bootstrap() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n    )\n\n\n# Run the application\n# In real world this would be run by a 3rd party framework like FastAPI\nasync def main() -&gt; None:\n    application = bootstrap()\n    async with application, application.container.context():\n        result = await handler()  # type: ignore[call-arg]\n        print(result)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed documentation, visit our documentation site.</p>"},{"location":"#key-topics","title":"Key Topics","text":"<ul> <li>Getting Started</li> <li>Module System</li> <li>Dependency Injection</li> <li>Extensions</li> <li>CQRS</li> <li>Integrations</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details.</p>"},{"location":"#development-setup","title":"Development Setup","text":"<p>See out contributing guide for development setup.</p>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#v040-2025-03-16","title":"v0.4.0 (2025-03-16)","text":""},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Setup mkdocs and improve documentation   (<code>d5166d7</code>)</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add ability to pass custom context to dependency provider   (<code>a0e055f</code>)</li> </ul>"},{"location":"changelog/#v031-2025-02-13","title":"v0.3.1 (2025-02-13)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Do not unwrap generic annotations in <code>collect_dependencies</code>   (<code>c5f1b7c</code>)</li> </ul>"},{"location":"changelog/#v030-2025-02-10","title":"v0.3.0 (2025-02-10)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Refactor module system   (<code>43a102a</code>)</li> </ul>"},{"location":"changelog/#v020-2025-01-12","title":"v0.2.0 (2025-01-12)","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li> <p>Add docstrings to mediator related stuff   (<code>10728c0</code>)</p> </li> <li> <p>Deploy mkdocs to github pages #17   (<code>23872d7</code>)</p> </li> <li> <p>Improve readme and contributing guide   (<code>93529d1</code>)</p> </li> <li> <p>Trigger docs deploy #17   (<code>096876f</code>)</p> </li> <li> <p>Use org bot for pages deploy #17   (<code>dfd1786</code>)</p> </li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li> <p>Eliminate maps usage in mediator   (<code>16679d7</code>)</p> </li> <li> <p>Refactor mediator extension, add events handling support   (<code>3441375</code>)</p> </li> </ul> <p>Resolves #12 Fixes #16</p>"},{"location":"changelog/#v016-2024-12-20","title":"v0.1.6 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Skip ci in release commit   (<code>9adbc58</code>)</li> </ul>"},{"location":"changelog/#v015-2024-12-20","title":"v0.1.5 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Remove unused version var from init, run gitlint only for prs   (<code>7a270d4</code>)</li> </ul>"},{"location":"changelog/#v014-2024-12-20","title":"v0.1.4 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Attempt to fix contextvar from different context error   (<code>d98c2f8</code>)</li> </ul>"},{"location":"changelog/#v013-2024-12-20","title":"v0.1.3 (2024-12-20)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>ext: Make mediator middlewares work   (<code>4e4a593</code>)</li> </ul>"},{"location":"changelog/#build-system","title":"Build System","text":"<ul> <li>Make patch release only for <code>fix</code> &amp; <code>perf</code> tags   (<code>b9cf6bf</code>)</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>Add readme and contributing guide   (<code>32043d7</code>)</li> </ul>"},{"location":"changelog/#v012-2024-12-19","title":"v0.1.2 (2024-12-19)","text":""},{"location":"changelog/#continuous-integration","title":"Continuous Integration","text":"<ul> <li> <p>Fix semantic release step   (<code>c516322</code>)</p> </li> <li> <p>Fix semantic release step 2   (<code>176a466</code>)</p> </li> <li> <p>Setup github actions pipelines   (<code>3f0ec58</code>)</p> </li> </ul>"},{"location":"changelog/#v011-2024-12-19","title":"v0.1.1 (2024-12-19)","text":""},{"location":"changelog/#chores","title":"Chores","text":"<ul> <li>deps: Use litestar-msgspec with litestar extra on all python version   (<code>ef60b04</code>)</li> </ul>"},{"location":"changelog/#v010-2024-12-18","title":"v0.1.0 (2024-12-18)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Module validation   (<code>45c58b1</code>)</li> </ul>"},{"location":"changelog/#chores_1","title":"Chores","text":"<ul> <li> <p>Adjust dev workflow, add semantic release config   (<code>ab3313a</code>)</p> </li> <li> <p>ci: Try fix ci   (<code>2bf8383</code>)</p> </li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li> <p>Add providers registration, fix validation   (<code>35ef7f3</code>)</p> </li> <li> <p>Add semantic release, rename package   (<code>a8addaf</code>)</p> </li> <li> <p>Implement di &amp; mediator extension   (<code>f7ebdb9</code>)</p> </li> <li> <p>Improve app &amp; di lifespan, add check for app providers   (<code>d5b3a31</code>)</p> </li> <li> <p>Improve providers validation &amp; add imports to init files   (<code>7bd5999</code>)</p> </li> <li> <p>Make application module itself, improve aioinject provider   (<code>9ae70a2</code>)</p> </li> </ul>"},{"location":"contributing/","title":"Contributing to Waku","text":"<p>First off, thanks for taking the time to contribute! \ud83c\udf89</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher</li> <li>uv - Modern Python package installer</li> <li>Task - Task runner.   Also, it's recommended to set up auto-completion for Task.</li> <li>Git</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:</p> <pre><code>git clone git@github.com:&lt;your-username&gt;/waku.git\ncd waku\n</code></pre> </li> <li> <p>Install UV (if not already installed):</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# For other platforms, see:\n# https://docs.astral.sh/uv/getting-started/installation/\n\n# If UV is already installed, make sure it's up to date:\nuv self update\n</code></pre> </li> <li> <p>Install Task (if not already installed):</p> <pre><code># Using the install script\nsh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin\n\n# For other installation options:\n# https://taskfile.dev/installation/\n</code></pre> </li> <li> <p>Setup development environment:</p> <pre><code># Install dependencies and setup pre-commit hooks\ntask install\n</code></pre> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a new branch for your changes:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> </li> <li> <p>Make your changes following our code style guidelines</p> </li> <li> <p>Write tests for your changes</p> </li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Run the test suite before submitting your changes:</p> <pre><code># Run all checks (recommended)\ntask\n\n# Run specific checks\ntask test        # Run tests only\ntask test:cov    # Run tests with coverage\ntask lint        # Run linters only\ntask format      # Format code\ntask typecheck   # Run type checker only\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Ruff for linting and formatting</li> <li>MyPy for type checking</li> <li>Type hints are required for all public APIs</li> </ul> <p>Key style points:</p> <ul> <li>Maximum line length is 120 characters</li> <li>Use explicit type annotations</li> <li>Follow PEP 8 guidelines</li> <li>Write descriptive   docstrings (Google style)</li> </ul>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"contributing/#issues","title":"Issues","text":"<p>Before creating an issue:</p> <ol> <li>Search existing issues to avoid duplicates</li> <li>Use the appropriate issue template</li> <li>Provide as much context as possible</li> </ol> <p>We welcome:</p> <ul> <li>Bug reports</li> <li>Feature requests</li> <li>Documentation improvements</li> <li>General questions</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Create an issue first to discuss significant changes</li> <li>Ensure all tests pass and code is formatted</li> <li>Update documentation if needed</li> <li>Follow the pull request template</li> <li>Link related issues in your PR description</li> </ol>"},{"location":"contributing/#pull-request-checklist","title":"Pull request checklist:","text":"<ul> <li> Tests added/updated</li> <li> Documentation updated</li> <li> Type hints added</li> <li> Changelog updated</li> <li> All checks passing</li> </ul>"},{"location":"contributing/#development-commands","title":"Development Commands","text":"<p>Common <code>task</code> commands:</p> <pre><code>task install     # Install dependencies and setup pre-commit hooks\ntask format      # Format code using ruff\ntask lint        # Run all linters\ntask typecheck   # Run type checker (mypy)\ntask test        # Run tests\ntask test:cov    # Run tests with coverage\ntask clean       # Clean build artifacts\ntask -l          # List all available commands\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have questions, feel free to:</p> <ul> <li>Open an issue</li> <li>Start a Discussion</li> <li>Reach out to maintainers</li> </ul> <p>Thank you for contributing to Waku! \ud83d\ude4f</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#waku.ext","title":"ext","text":""},{"location":"reference/#waku.ext.validation","title":"validation","text":""},{"location":"reference/#waku.ext.validation.rules","title":"rules","text":""},{"location":"reference/#waku.ext.validation.rules.DependenciesAccessible","title":"DependenciesAccessible","text":"<p>               Bases: <code>ValidationRule</code></p> <p>Check if all dependencies of providers are accessible.</p> <p>This validation rule ensures that all dependencies required by providers are either: 1. Available globally 2. Provided by the current module 3. Provided by any of the imported modules</p>"},{"location":"reference/#waku.ext.validation.rules.DIScopeMismatch","title":"DIScopeMismatch","text":"<p>               Bases: <code>ValidationRule</code></p> <p>Check if Singleton and Object providers don't depend on Scoped and Transient ones.</p>"},{"location":"reference/#waku.extensions","title":"extensions","text":"<p>Extension protocols for the Waku microframework.</p> <p>This module defines protocols for extending module behavior. These protocols allow for hooking into various lifecycle events.</p>"},{"location":"reference/#waku.extensions.OnApplicationInit","title":"OnApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application pre-initialization actions.</p>"},{"location":"reference/#waku.extensions.OnApplicationInit.on_app_init","title":"on_app_init  <code>async</code>","text":"<pre><code>on_app_init(app: Application) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_app_init(self, app: Application) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.AfterApplicationInit","title":"AfterApplicationInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for application post-initialization actions.</p>"},{"location":"reference/#waku.extensions.AfterApplicationInit.after_app_init","title":"after_app_init  <code>async</code>","text":"<pre><code>after_app_init(app: Application) -&gt; None\n</code></pre> <p>Perform actions after application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def after_app_init(self, app: Application) -&gt; None:\n    \"\"\"Perform actions after application initialization.\"\"\"\n</code></pre>"},{"location":"reference/#waku.extensions.OnModuleInit","title":"OnModuleInit","text":"<p>               Bases: <code>Protocol</code></p> <p>Extension for module initialization.</p>"},{"location":"reference/#waku.extensions.OnModuleInit.on_module_init","title":"on_module_init  <code>async</code>","text":"<pre><code>on_module_init(module: Module) -&gt; None\n</code></pre> <p>Perform actions before application initialization.</p> Source code in <code>src/waku/extensions.py</code> <pre><code>async def on_module_init(self, module: Module) -&gt; None:\n    \"\"\"Perform actions before application initialization.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#waku.mediator","title":"mediator","text":""},{"location":"reference/#waku.mediator.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.mediator.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.mediator.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    dependency_provider: DependencyProvider,\n    middlewares: Sequence[AnyMiddleware],\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default mediator implementation.</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>def __init__(\n    self,\n    dependency_provider: DependencyProvider,\n    middlewares: Sequence[AnyMiddleware],\n    event_publisher: EventPublisher,\n) -&gt; None:\n    self._dependency_provider = dependency_provider\n    self._middleware_chain = MiddlewareChain(middlewares)\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.mediator.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the mediator middleware chain.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request[ResponseT]</code> <p>The request to process</p> required <p>Returns:</p> Type Description <code>ResponseT</code> <p>Response from the handler</p> <p>Raises:</p> Type Description <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the mediator middleware chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.mediator.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to publish</p> required <p>Raises:</p> Type Description <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.mediator.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a mediator to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.mediator.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the mediator to be handled by multiple handlers.</p>"},{"location":"reference/#waku.mediator.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the mediator middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.mediator.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    middlewares: Sequence[type[AnyMiddleware]] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the mediator pattern implementation in the application.</p> <p>Attributes:</p> Name Type Description <code>mediator_implementation_type</code> <code>type[IMediator]</code> <p>The concrete implementation class for the mediator interface (IMediator). Defaults to the standard Mediator class.</p> <code>event_publisher</code> <code>type[EventPublisher]</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <code>middlewares</code> <code>Sequence[type[AnyMiddleware]]</code> <p>A sequence of middleware classes that will be applied to the mediator pipeline. Middlewares are executed in the order they are defined. Defaults to an empty sequence.</p> Example <pre><code>config = MediatorConfig(\n    mediator_implementation_type=CustomMediator,\n    middlewares=[LoggingMiddleware, ValidationMiddleware],\n)\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.mediator.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MediatorConfig | None</code> <p>Configuration for the Mediator extension.</p> <code>None</code> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    return DynamicModule(\n        parent_module=cls,\n        providers=list(cls._create_providers(config or MediatorConfig())),\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.MediatorProvidersCreator","title":"MediatorProvidersCreator","text":""},{"location":"reference/#waku.mediator.MediatorProvidersCreator.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    *,\n    request_map: RequestMap | None = None,\n    event_map: EventMap | None = None,\n) -&gt; list[Provider[Any]]\n</code></pre> <p>Mediator module.</p> <p>Parameters:</p> Name Type Description Default <code>request_map</code> <code>RequestMap | None</code> <p>Optional request handler map for the module.</p> <code>None</code> <code>event_map</code> <code>EventMap | None</code> <p>Optional event handlers map for the module.</p> <code>None</code> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    *,\n    request_map: RequestMap | None = None,\n    event_map: EventMap | None = None,\n) -&gt; list[Provider[Any]]:\n    \"\"\"Mediator module.\n\n    Args:\n        request_map: Optional request handler map for the module.\n        event_map: Optional event handlers map for the module.\n    \"\"\"\n    providers: list[Provider[Any]] = []\n    if request_map:\n        providers.extend(cls._create_request_handler_providers(request_map))\n    if event_map:\n        providers.extend(cls._create_event_handler_providers(event_map))\n\n    return providers\n</code></pre>"},{"location":"reference/#waku.mediator.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.mediator.contracts","title":"contracts","text":""},{"location":"reference/#waku.mediator.contracts.event","title":"event","text":""},{"location":"reference/#waku.mediator.contracts.event.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for events.</p>"},{"location":"reference/#waku.mediator.contracts.request","title":"request","text":""},{"location":"reference/#waku.mediator.contracts.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(*, request_id: UUID = uuid4())\n</code></pre> <p>               Bases: <code>Generic[ResponseT]</code></p> <p>Base class for request-type objects.</p>"},{"location":"reference/#waku.mediator.contracts.request.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response()\n</code></pre> <p>Base class for response type objects.</p>"},{"location":"reference/#waku.mediator.events","title":"events","text":""},{"location":"reference/#waku.mediator.events.handler","title":"handler","text":""},{"location":"reference/#waku.mediator.events.handler.EventHandler","title":"EventHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventT]</code></p> <p>The event handler interface.</p> <p>Usage::</p> <p>class UserJoinedEventHandler(EventHandler[UserJoinedEvent])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, event: UserJoinedEvent) -&gt; None:\n      await self._meetings_api.notify_room(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions","title":"exceptions","text":""},{"location":"reference/#waku.mediator.exceptions.MediatorError","title":"MediatorError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all mediator-related errors.</p>"},{"location":"reference/#waku.mediator.exceptions.ImproperlyConfiguredError","title":"ImproperlyConfiguredError","text":"<p>               Bases: <code>MediatorError</code></p> <p>Raised when mediator configuration is invalid.</p>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerAlreadyRegistered","title":"RequestHandlerAlreadyRegistered","text":"<pre><code>RequestHandlerAlreadyRegistered(\n    msg: str,\n    request_type: type[Request[Any]],\n    handler_type: RequestHandlerType[Any, Any],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when a request handler is already registered.</p> <p>Attributes:</p> Name Type Description <code>request_type</code> <code>type[Request[Any]]</code> <p>The type of request that caused the error.</p> <code>handler_type</code> <code>RequestHandlerType[Any, Any]</code> <p>The type of handler that was already registered.</p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(\n    self,\n    msg: str,\n    request_type: type[Request[Any]],\n    handler_type: RequestHandlerType[Any, Any],\n) -&gt; None:\n    super().__init__(msg)\n    self.request_type = request_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.RequestHandlerNotFound","title":"RequestHandlerNotFound","text":"<pre><code>RequestHandlerNotFound(\n    msg: str, request_type: type[Request[Any]]\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when a request handler is not found.</p> <p>Attributes:</p> Name Type Description <code>request_type</code> <code>type[Request[Any]]</code> <p>The type of request that caused the error.</p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(self, msg: str, request_type: type[Request[Any]]) -&gt; None:\n    super().__init__(msg)\n    self.request_type = request_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerAlreadyRegistered","title":"EventHandlerAlreadyRegistered","text":"<pre><code>EventHandlerAlreadyRegistered(\n    msg: str,\n    event_type: type[Event],\n    handler_type: EventHandlerType[Any],\n)\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>KeyError</code></p> <p>Raised when an event handler is already registered.</p> <p>Attributes:</p> Name Type Description <code>event_type</code> <code>type[Event]</code> <p>The type of event that caused the error.</p> <code>handler_type</code> <code>EventHandlerType[Any]</code> <p>The type of handler that was already registered.</p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(\n    self,\n    msg: str,\n    event_type: type[Event],\n    handler_type: EventHandlerType[Any],\n) -&gt; None:\n    super().__init__(msg)\n    self.event_type = event_type\n    self.handler_type = handler_type\n</code></pre>"},{"location":"reference/#waku.mediator.exceptions.EventHandlerNotFound","title":"EventHandlerNotFound","text":"<pre><code>EventHandlerNotFound(msg: str, event_type: type[Event])\n</code></pre> <p>               Bases: <code>MediatorError</code>, <code>TypeError</code></p> <p>Raised when an event handler is not found.</p> <p>Attributes:</p> Name Type Description <code>event_type</code> <code>type[Event]</code> <p>The type of event that caused the error.</p> Source code in <code>src/waku/mediator/exceptions.py</code> <pre><code>def __init__(self, msg: str, event_type: type[Event]) -&gt; None:\n    super().__init__(msg)\n    self.event_type = event_type\n</code></pre>"},{"location":"reference/#waku.mediator.impl","title":"impl","text":""},{"location":"reference/#waku.mediator.impl.Mediator","title":"Mediator","text":"<pre><code>Mediator(\n    dependency_provider: DependencyProvider,\n    middlewares: Sequence[AnyMiddleware],\n    event_publisher: EventPublisher,\n)\n</code></pre> <p>               Bases: <code>IMediator</code></p> <p>Default mediator implementation.</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>def __init__(\n    self,\n    dependency_provider: DependencyProvider,\n    middlewares: Sequence[AnyMiddleware],\n    event_publisher: EventPublisher,\n) -&gt; None:\n    self._dependency_provider = dependency_provider\n    self._middleware_chain = MiddlewareChain(middlewares)\n    self._event_publisher = event_publisher\n</code></pre>"},{"location":"reference/#waku.mediator.impl.Mediator.send","title":"send  <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Send a request through the mediator middleware chain.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request[ResponseT]</code> <p>The request to process</p> required <p>Returns:</p> Type Description <code>ResponseT</code> <p>Response from the handler</p> <p>Raises:</p> Type Description <code>RequestHandlerNotFound</code> <p>If no handler is registered for the request type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Send a request through the mediator middleware chain.\n\n    Args:\n        request: The request to process\n\n    Returns:\n        Response from the handler\n\n    Raises:\n        RequestHandlerNotFound: If no handler is registered for the request type\n    \"\"\"\n    request_type = type(request)\n    handler = await self._resolve_request_handler(request_type)\n    return await self._handle_request(handler, request)\n</code></pre>"},{"location":"reference/#waku.mediator.impl.Mediator.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Publish an event to all registered handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to publish</p> required <p>Raises:</p> Type Description <code>EventHandlerNotFound</code> <p>If no handlers are registered for the event type</p> Source code in <code>src/waku/mediator/impl.py</code> <pre><code>@override\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event to all registered handlers.\n\n    Args:\n        event: The event to publish\n\n    Raises:\n        EventHandlerNotFound: If no handlers are registered for the event type\n    \"\"\"\n    event_type = type(event)\n    handlers = await self._resolve_event_handlers(event_type)\n    await self._event_publisher(handlers, event)\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces","title":"interfaces","text":""},{"location":"reference/#waku.mediator.interfaces.ISender","title":"ISender","text":"<p>               Bases: <code>ABC</code></p> <p>Send a request through the mediator middleware chain to be handled by a single handler.</p>"},{"location":"reference/#waku.mediator.interfaces.ISender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(request: Request[ResponseT]) -&gt; ResponseT\n</code></pre> <p>Asynchronously send a request to a single handler.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def send(self, request: Request[ResponseT]) -&gt; ResponseT:\n    \"\"\"Asynchronously send a request to a single handler.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IPublisher","title":"IPublisher","text":"<p>               Bases: <code>ABC</code></p> <p>Publish event through the mediator to be handled by multiple handlers.</p>"},{"location":"reference/#waku.mediator.interfaces.IPublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(event: Event) -&gt; None\n</code></pre> <p>Asynchronously send event to multiple handlers.</p> Source code in <code>src/waku/mediator/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def publish(self, event: Event) -&gt; None:\n    \"\"\"Asynchronously send event to multiple handlers.\"\"\"\n</code></pre>"},{"location":"reference/#waku.mediator.interfaces.IMediator","title":"IMediator","text":"<p>               Bases: <code>ISender</code>, <code>IPublisher</code>, <code>ABC</code></p> <p>Defines a mediator to encapsulate request/response and publishing interaction patterns.</p>"},{"location":"reference/#waku.mediator.modules","title":"modules","text":""},{"location":"reference/#waku.mediator.modules.MediatorConfig","title":"MediatorConfig  <code>dataclass</code>","text":"<pre><code>MediatorConfig(\n    *,\n    mediator_implementation_type: type[\n        IMediator\n    ] = Mediator,\n    event_publisher: type[\n        EventPublisher\n    ] = SequentialEventPublisher,\n    middlewares: Sequence[type[AnyMiddleware]] = (),\n)\n</code></pre> <p>Configuration for the Mediator extension.</p> <p>This class defines the configuration options for setting up the mediator pattern implementation in the application.</p> <p>Attributes:</p> Name Type Description <code>mediator_implementation_type</code> <code>type[IMediator]</code> <p>The concrete implementation class for the mediator interface (IMediator). Defaults to the standard Mediator class.</p> <code>event_publisher</code> <code>type[EventPublisher]</code> <p>The implementation class for publishing events. Defaults to <code>SequentialEventPublisher</code>.</p> <code>middlewares</code> <code>Sequence[type[AnyMiddleware]]</code> <p>A sequence of middleware classes that will be applied to the mediator pipeline. Middlewares are executed in the order they are defined. Defaults to an empty sequence.</p> Example <pre><code>config = MediatorConfig(\n    mediator_implementation_type=CustomMediator,\n    middlewares=[LoggingMiddleware, ValidationMiddleware],\n)\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorModule","title":"MediatorModule","text":""},{"location":"reference/#waku.mediator.modules.MediatorModule.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(\n    config: MediatorConfig | None = None,\n) -&gt; DynamicModule\n</code></pre> <p>Application-level module for Mediator setup.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MediatorConfig | None</code> <p>Configuration for the Mediator extension.</p> <code>None</code> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef register(cls, config: MediatorConfig | None = None, /) -&gt; DynamicModule:\n    \"\"\"Application-level module for Mediator setup.\n\n    Args:\n        config: Configuration for the Mediator extension.\n    \"\"\"\n    return DynamicModule(\n        parent_module=cls,\n        providers=list(cls._create_providers(config or MediatorConfig())),\n        is_global=True,\n    )\n</code></pre>"},{"location":"reference/#waku.mediator.modules.MediatorProvidersCreator","title":"MediatorProvidersCreator","text":""},{"location":"reference/#waku.mediator.modules.MediatorProvidersCreator.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    *,\n    request_map: RequestMap | None = None,\n    event_map: EventMap | None = None,\n) -&gt; list[Provider[Any]]\n</code></pre> <p>Mediator module.</p> <p>Parameters:</p> Name Type Description Default <code>request_map</code> <code>RequestMap | None</code> <p>Optional request handler map for the module.</p> <code>None</code> <code>event_map</code> <code>EventMap | None</code> <p>Optional event handlers map for the module.</p> <code>None</code> Source code in <code>src/waku/mediator/modules.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    *,\n    request_map: RequestMap | None = None,\n    event_map: EventMap | None = None,\n) -&gt; list[Provider[Any]]:\n    \"\"\"Mediator module.\n\n    Args:\n        request_map: Optional request handler map for the module.\n        event_map: Optional event handlers map for the module.\n    \"\"\"\n    providers: list[Provider[Any]] = []\n    if request_map:\n        providers.extend(cls._create_request_handler_providers(request_map))\n    if event_map:\n        providers.extend(cls._create_event_handler_providers(event_map))\n\n    return providers\n</code></pre>"},{"location":"reference/#waku.mediator.requests","title":"requests","text":""},{"location":"reference/#waku.mediator.requests.handler","title":"handler","text":""},{"location":"reference/#waku.mediator.requests.handler.RequestHandler","title":"RequestHandler","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RequestT, ResponseT]</code></p> <p>The request handler interface.</p> <p>The request handler is an object, which gets a request as input and may return a response as a result.</p> <p>Command handler example::</p> <p>class JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: JoinMeetingCommand) -&gt; None:\n      await self._meetings_api.join_user(request.user_id, request.meeting_id)\n</code></pre> <p>Query handler example::</p> <p>class ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult])       def init(self, meetings_api: MeetingAPIProtocol) -&gt; None:           self._meetings_api = meetings_api</p> <pre><code>  async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n      link = await self._meetings_api.get_link(request.meeting_id)\n      return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre>"},{"location":"reference/#waku.modules","title":"modules","text":""},{"location":"reference/#waku.modules.ModuleMetadata","title":"ModuleMetadata  <code>dataclass</code>","text":"<pre><code>ModuleMetadata(\n    *,\n    providers: Sequence[Provider[Any]] = list(),\n    imports: Sequence[ModuleType | DynamicModule] = list(),\n    exports: Sequence[\n        object | ModuleType | DynamicModule\n    ] = list(),\n    extensions: Sequence[ModuleExtension] = list(),\n    is_global: bool = False,\n    id: UUID = uuid4(),\n)\n</code></pre>"},{"location":"reference/#waku.modules.ModuleMetadata.providers","title":"providers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>providers: Sequence[Provider[Any]] = field(\n    default_factory=list\n)\n</code></pre> <p>List of providers for dependency injection.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports: Sequence[ModuleType | DynamicModule] = field(\n    default_factory=list\n)\n</code></pre> <p>List of modules imported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.exports","title":"exports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exports: Sequence[object | ModuleType | DynamicModule] = (\n    field(default_factory=list)\n)\n</code></pre> <p>List of types or modules exported by this module.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Sequence[ModuleExtension] = field(\n    default_factory=list\n)\n</code></pre> <p>List of module extensions for lifecycle hooks.</p>"},{"location":"reference/#waku.modules.ModuleMetadata.is_global","title":"is_global  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_global: bool = False\n</code></pre> <p>Whether this module is global or not.</p>"},{"location":"examples/basic/","title":"Basic usage","text":"<p>Example of how to use modules, dynamic modules and linking them together to build a simple application.</p>"},{"location":"examples/basic/#code","title":"Code","text":"<pre><code>import asyncio\nimport logging\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\n\nfrom waku import Application\nfrom waku.di import Injected, Scoped, Singleton, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\nfrom waku.factory import ApplicationFactory\nfrom waku.modules import DynamicModule, module\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n# Define your providers and modules\nclass ConfigService:\n    def get(self, option: str) -&gt; str:  # noqa: PLR6301\n        return option\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        # You can select providers based on `env` for example\n        logger.info('Loading config for env=%s', env)\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Singleton(ConfigService)],\n            exports=[ConfigService],\n        )\n\n\nclass UserService:\n    async def great(self, name: str) -&gt; str:  # noqa: PLR6301\n        return f'Hello, {name}!'\n\n\n@module(\n    providers=[Scoped(UserService)],\n    exports=[UserService],\n)\nclass UserModule:\n    pass\n\n\n@module(imports=[UserModule])\nclass IAMModule:\n    pass\n\n\n@module(imports=[UserModule, IAMModule])\nclass AdminModule:\n    pass\n\n\n# Define the application composition root module\n@module(\n    imports=[\n        AdminModule,\n        ConfigModule.register(env='prod'),\n    ],\n    exports=[ConfigModule],\n    is_global=True,\n)\nclass AppModule:\n    pass\n\n\n# Define entrypoints\n# In real world this can be FastAPI routes, etc.\n@inject\nasync def handler(\n    user_service: Injected[UserService],\n    config_service: Injected[ConfigService],\n) -&gt; None:\n    print(await user_service.great('World'))\n    print(config_service.get('TEST=1'))\n\n\n@asynccontextmanager\nasync def lifespan(_: Application) -&gt; AsyncIterator[None]:  # noqa: RUF029\n    logger.info('Lifespan startup')\n    yield\n    logger.info('Lifespan shutdown')\n\n\n# Create application via factory\ndef bootstrap() -&gt; Application:\n    return ApplicationFactory.create(\n        AppModule,\n        dependency_provider=AioinjectDependencyProvider(),\n        lifespan=[lifespan],\n    )\n\n\n# Run the application\n# In real world this would be run by a 3rd party framework like FastAPI\nasync def main() -&gt; None:\n    application = bootstrap()\n    async with application, application.container.context():\n        await handler()  # type: ignore[call-arg]\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/mediator/","title":"Mediator (CQRS)","text":"<p>Based on the CQRS pattern, the mediator pattern is used to decouple the command and query logic from the domain model.</p> <p>Implementation based on C# MediatR library.</p>"},{"location":"examples/mediator/#code","title":"Code","text":"<pre><code>import asyncio\nimport logging\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom uuid import UUID, uuid4\n\nfrom waku import Application, ApplicationFactory\nfrom waku.di import Injected, inject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\nfrom waku.mediator import (\n    IMediator,\n    MediatorConfig,\n    MediatorModule,\n    Request,\n    RequestHandler,\n    RequestMap,\n    Response,\n)\nfrom waku.mediator.contracts.event import Event\nfrom waku.mediator.contracts.request import RequestT, ResponseT\nfrom waku.mediator.events.handler import EventHandler\nfrom waku.mediator.events.map import EventMap\nfrom waku.mediator.middlewares import HandleType, Middleware\nfrom waku.mediator.modules import MediatorProvidersCreator\nfrom waku.modules import module\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CreateMeetingResult(Response):\n    meeting_id: UUID\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CreateMeetingCommand(Request[CreateMeetingResult]):\n    user_id: UUID\n\n\n@dataclass(frozen=True, kw_only=True)\nclass MeetingCreatedEvent(Event):\n    user_id: UUID\n    meeting_id: UUID\n\n\nclass CreatingMeetingCommandHandler(RequestHandler[CreateMeetingCommand, CreateMeetingResult]):\n    def __init__(self, mediator: IMediator) -&gt; None:\n        self._mediator = mediator\n\n    async def handle(self, request: CreateMeetingCommand) -&gt; CreateMeetingResult:\n        meeting_id = uuid4()\n        logger.info('new meeting created user_id=%s', request.user_id)\n        await self._mediator.publish(MeetingCreatedEvent(user_id=request.user_id, meeting_id=meeting_id))\n        return CreateMeetingResult(meeting_id=meeting_id)\n\n\nclass MeetingCreatedEventHandler(EventHandler[MeetingCreatedEvent]):\n    async def handle(self, event: MeetingCreatedEvent) -&gt; None:  # noqa: PLR6301\n        logger.info('meeting created event handled user_id=%s', event.user_id)\n\n\nclass LogMiddleware(Middleware[RequestT, ResponseT]):\n    async def __call__(self, request: RequestT, handle: HandleType[RequestT, ResponseT]) -&gt; ResponseT:\n        logger.info('request=%s', request)\n        response = await handle(request)\n        logger.info('response=%s', response)\n        return response\n\n\n@asynccontextmanager\nasync def lifespan(_: Application) -&gt; AsyncIterator[None]:  # noqa: RUF029\n    logger.info('Lifespan startup')\n    yield\n    logger.info('Lifespan shutdown')\n\n\n@module(\n    providers=[\n        *MediatorProvidersCreator.create(\n            request_map=RequestMap().bind(CreateMeetingCommand, CreatingMeetingCommandHandler),\n            event_map=EventMap().bind(MeetingCreatedEvent, [MeetingCreatedEventHandler]),\n        ),\n    ],\n    exports=[CreatingMeetingCommandHandler],\n)\nclass SomeModule:\n    pass\n\n\n@module(\n    imports=[\n        SomeModule,\n        MediatorModule.register(MediatorConfig(middlewares=[LogMiddleware])),\n    ],\n    is_global=True,\n)\nclass AppModule:\n    pass\n\n\n@inject\nasync def handler(mediator: Injected[IMediator]) -&gt; None:\n    command = CreateMeetingCommand(user_id=uuid4())\n    await mediator.send(command)\n\n\nasync def main() -&gt; None:\n    dp = AioinjectDependencyProvider()\n    app = ApplicationFactory.create(\n        AppModule,\n        dependency_provider=dp,\n        lifespan=[lifespan],\n    )\n\n    async with app, app.container.context():\n        await handler()  # type: ignore[call-arg]\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"extensions/lifecycle/","title":"Lifecycle hooks","text":""},{"location":"extensions/validation/","title":"Validation","text":""},{"location":"usage/cqrs/","title":"CQRS","text":""},{"location":"usage/dp/","title":"Dependency providers","text":"<p>Waku designed to be modular and extensible. To follow this principle, it designed to be DI agnostic framework.</p> <p>Instead of using a concrete DI framework, Waku uses a dependency provider interface. This allows you to use any DI framework you want, or even write your own.</p>"},{"location":"usage/dp/#included-providers","title":"Included providers","text":"<p>Waku provides several dependency providers for popular DI frameworks out of the box:</p>"},{"location":"usage/dp/#aioinject","title":"Aioinject","text":"<p>Waku dependency provider interface are heavily inspired by aioinject. So, it's recommended to use aioinject as a dependency provider. It's fits perfectly with Waku and provides all needed features.</p>"},{"location":"usage/dp/#usage","title":"Usage","text":"<pre><code>from waku.di.contrib.aioinject import AioinjectDependencyProvider\n\ndp = AioinjectDependencyProvider()\n</code></pre> <p>You can also use it with your own container:</p> <pre><code>import aioinject\nfrom waku.di.contrib.aioinject import AioinjectDependencyProvider\n\ncontainer = aioinject.Container()\ndp = AioinjectDependencyProvider(container=container)\n</code></pre> <p>It supports all aioinject features:</p> <ul> <li>All providers scopes (transient, singleton, scoped, object).</li> <li>Providers overriding.</li> <li>Custom context.</li> <li>Extensions (via custom <code>aioinject.Container</code> passed to <code>AioinjectDependencyProvider</code>)</li> </ul>"},{"location":"usage/dp/#dishka","title":"Dishka","text":"<p>Currently not supported but planned.</p>"},{"location":"usage/modules/","title":"Modules","text":"<p>Waku modularity system are heavily inspired by NestJS &amp; Tramvai frameworks. Modularity concept is well explained in NestJS documentation.</p>"},{"location":"usage/modules/#module","title":"Module","text":"<p>A module is a class that is annotated with the <code>@module()</code> decorator. This decorator used to attach metadata to class that Waku later use to build the application graph.</p> <p>Every application has at least one module, a root module, also called composition root. The root module is the starting point Waku uses to build the entire application graph.</p> Parameter Description <code>providers</code> List of providers for dependency injection <code>imports</code> List of modules imported by this module <code>exports</code> List of types or modules exported by this module <code>extensions</code> List of module extensions for lifecycle hooks <code>is_global</code> Whether this module is global or not <p>The module encapsulates providers by default, meaning you can only inject providers that are either part of the current module or explicitly exported from other imported modules. The exported providers from a module essentially serve as the module's public interface or API.</p> <pre><code>from waku import module\nfrom waku.di import Scoped\n\nfrom app.modules.config.module import ConfigModule\n\nclass UsersService:\n    pass\n\n\n@module(\n    providers=[Scoped(UsersService)],\n    imports=[ConfigModule],\n    exports=[UsersService],\n)\nclass UsersModule:\n    pass\n\n\n@module(imports=[UsersModule])\nclass AppModule:\n    pass\n</code></pre> <p>Note</p> <p>Encapsulation enforcements currently are implemented by validators, so you can always disable them at runtime and use only what you need. But it's not recommended to completely disable them.</p>"},{"location":"usage/modules/#module-re-exporting","title":"Module re-exporting","text":"<p>You can re-export a module by adding it to the <code>exports</code> list of another module. This is useful when you want to expose a module's providers to other modules that import the re-exporting module.</p> <pre><code>@module(\n    imports=[UsersModule],\n    exports=[UsersModule],\n)\nclass IAMModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#global-modules","title":"Global modules","text":"<p>If you have to import the same set of modules everywhere, you can make a module global. Once a module is global, you can inject it providers to any part of your application without having to import it in every module.</p> <p>To make a module global, set the <code>is_global</code> param to <code>True</code> in the <code>@module()</code> decorator.</p> <pre><code>from waku import module\n\n\n@module(is_global=True)\nclass UsersModule:\n    pass\n</code></pre>"},{"location":"usage/modules/#dynamic-module","title":"Dynamic Module","text":"<p>With dynamic modules, you can create modules on the fly, based on some conditions, for example, based on the environment your application is running in.</p> <pre><code>from waku import DynamicModule, module\nfrom waku.di import Scoped\n\n\nclass ConfigService:\n    pass\n\n\nclass DevConfigService(ConfigService):\n    pass\n\n\nclass DefaultConfigService(ConfigService):\n    pass\n\n\n@module()\nclass ConfigModule:\n    @classmethod\n    def register(cls, env: str = 'dev') -&gt; DynamicModule:\n        if env == 'dev':\n            return DynamicModule(\n                parent_module=cls,\n                providers=[Scoped(DevConfigService, type_=ConfigService)],\n            )\n\n        return DynamicModule(\n            parent_module=cls,\n            providers=[Scoped(DefaultConfigService, type_=ConfigService)],\n        )\n</code></pre> <p>And then use it in your application root module:</p> <pre><code>from waku import module\n\nfrom app.modules.config.module import ConfigModule\n\n\n@module(\n    imports=[\n        ConfigModule.register(env='dev'),\n    ],\n)\nclass AppModule:\n    pass\n</code></pre> <p>You can also register dynamic modules in the global scope by setting the <code>is_global</code> param to <code>True</code> in the <code>DynamicModule</code> class instantiation.</p> <p>Note</p> <p>You can use any method name instead of <code>register</code> but it's recommended to use <code>register</code> to keep the convention.</p>"},{"location":"usage/quickstart/","title":"Quickstart","text":""}]}